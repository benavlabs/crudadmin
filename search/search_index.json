{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CRUDAdmin","text":"<p> Modern admin interface for FastAPI with built-in authentication, event tracking, and security features </p> <p> </p> <p> CRUDAdmin is a robust admin interface generator for FastAPI applications, offering secure authentication, comprehensive event tracking, and essential monitoring features. Built with FastCRUD and HTMX, it helps you create production-ready admin panels with minimal configuration. </p> <p>Experimental Status</p> <p>CRUDAdmin is still experimental. While actively developed and tested, APIs may change between versions. Upgrade with caution in production environments, always carefuly reading the changelog.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd12 Multi-Backend Session Management: Flexible session storage with Memory, Redis, Memcached, Database, and Hybrid backends</li> <li>\ud83d\udee1\ufe0f Built-in Security: CSRF protection, rate limiting, IP restrictions, HTTPS enforcement, and secure cookie handling</li> <li>\ud83d\udea6 Rate Limiting: Login attempt protection with IP and username-based tracking</li> <li>\ud83d\udcdd Event Tracking &amp; Audit Logs: Comprehensive audit trails for all admin actions with user agent parsing and attribution</li> <li>\ud83d\udcca Auto-generated Interface: Creates admin UI directly from your SQLAlchemy models with intelligent field detection</li> <li>\ud83d\udd0d Advanced Filtering: Type-aware field filtering, search, and pagination with bulk operations</li> <li>\ud83c\udf17 Modern UI: Clean, responsive interface built with HTMX and FastCRUD</li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Here's how simple it is to get a complete admin interface running:</p> Define your SQLAlchemy models (click to expand) <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    username = Column(String, unique=True)\n    email = Column(String)\n    role = Column(String)\n</code></pre> Define your Pydantic schemas (click to expand) <pre><code>from pydantic import BaseModel, EmailStr\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    role: str = \"user\"\n\nclass UserUpdate(BaseModel):\n    email: EmailStr | None = None\n    role: str | None = None\n</code></pre> <p>Now, create your admin interface:</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom crudadmin import CRUDAdmin\n\n# Database setup\nengine = create_async_engine(\"sqlite+aiosqlite:///app.db\")\nsession = AsyncSession(engine)\n\n# Create admin interface\nadmin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=\"your-secret-key-here\",\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"secure_password123\"\n    }\n)\n\n# Add models to admin\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}\n)\n\n# Setup FastAPI with proper initialization\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Initialize database tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    # Initialize admin interface\n    await admin.initialize()\n    yield\n\n# Create and mount the app\napp = FastAPI(lifespan=lifespan)\napp.mount(\"/admin\", admin.app)\n</code></pre> <p>And it's all done! Navigate to <code>/admin</code> to access your admin interface with:</p> <ul> <li>User authentication</li> <li>CRUD operations for your models</li> <li>Responsive UI with dark/light themes</li> <li>Built-in security features</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing CRUDAdmin, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: CRUDAdmin is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>FastCRUD: CRUDAdmin is built on top of FastCRUD for CRUD operations (which requires SQLAlchemy 2.0+ for database operations and Pydantic 2.0+ for data validation and serialization).</li> <li>aiosqlite: Required for async SQLite operations (automatically installed as a dependency).</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>uv add crudadmin\n</code></pre> <p>Or, if using pip:</p> <pre><code>pip install crudadmin\n</code></pre>"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<p>For production use with different session backends:</p> <pre><code># For Redis sessions (recommended for production)\nuv add \"crudadmin[redis]\"\n\n# For Memcached sessions  \nuv add \"crudadmin[memcached]\"\n\n# For PostgreSQL/MySQL admin databases\nuv add \"crudadmin[postgres]\"  # PostgreSQL\nuv add \"crudadmin[mysql]\"     # MySQL\n</code></pre> <p>You can also combine multiple extras:</p> <pre><code># Redis sessions + PostgreSQL admin database\nuv add \"crudadmin[redis,postgres]\"\n\n# All session and database options\nuv add \"crudadmin[redis,memcached,postgres,mysql]\"\n</code></pre>"},{"location":"#development-installation","title":"Development Installation","text":"<p>For development with all extras:</p> <pre><code>uv add \"crudadmin[dev]\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>CRUDAdmin offers flexible configuration options for different deployment scenarios:</p>"},{"location":"#basic-development-setup","title":"Basic Development Setup","text":"<pre><code>from crudadmin import CRUDAdmin\n\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=\"your-secret-key\",\n    initial_admin={\n        \"username\": \"admin\", \n        \"password\": \"admin123\"\n    }\n)\n\n# Add your models\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate\n)\n\n# Mount to FastAPI\napp.mount(\"/admin\", admin.app)\n</code></pre>"},{"location":"#production-configuration-with-security","title":"Production Configuration with Security","text":"<pre><code>admin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=os.environ[\"ADMIN_SECRET_KEY\"],\n\n    # Security features\n    allowed_ips=[\"10.0.0.1\"],\n    allowed_networks=[\"192.168.1.0/24\"],\n    secure_cookies=True,\n    enforce_https=True,\n\n    # Session management\n    max_sessions_per_user=3,\n    session_timeout_minutes=15,\n\n    # Event tracking\n    track_events=True,\n    track_sessions_in_db=True,\n    admin_db_url=\"postgresql+asyncpg://user:pass@localhost/admin\"\n\n).use_redis_sessions(\n    redis_url=\"redis://localhost:6379\"\n)\n</code></pre>"},{"location":"#advanced-model-configuration","title":"Advanced Model Configuration","text":"<pre><code>from crudadmin.admin_interface.model_view import PasswordTransformer\n\n# Password handling for user models\npassword_transformer = PasswordTransformer(\n    password_field=\"password\",\n    hashed_field=\"hashed_password\", \n    hash_function=hash_password,\n    required_fields=[\"username\", \"email\"]\n)\n\nadmin.add_view(\n    model=User,\n    create_schema=UserCreateWithPassword,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"},\n    password_transformer=password_transformer\n)\n\n# Read-only audit logs\nadmin.add_view(\n    model=AuditLog,\n    create_schema=AuditLogSchema,\n    update_schema=AuditLogSchema,\n    allowed_actions={\"view\"}  # Read-only\n)\n</code></pre>"},{"location":"#session-backend-configuration","title":"Session Backend Configuration","text":"<pre><code># Redis Sessions (Recommended for Production)\nadmin.use_redis_sessions(\n    redis_url=\"redis://localhost:6379\",\n    password=\"redis-password\"\n)\n\n# Memcached Sessions\nadmin.use_memcached_sessions(\n    servers=[\"localhost:11211\"]\n)\n\n# Hybrid Sessions (Redis + Database)\nadmin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=SECRET_KEY,\n    track_sessions_in_db=True\n).use_redis_sessions(\n    redis_url=\"redis://localhost:6379\"\n)\n</code></pre>"},{"location":"#what-you-get","title":"What You Get","text":"<p>Once set up, CRUDAdmin provides:</p> <ul> <li>Admin Dashboard: Overview of your models and system health</li> <li>Model Management: Auto-generated forms for CRUD operations</li> <li>User Authentication: Secure login/logout with session management  </li> <li>Event Logs: Track all admin actions with full audit trails</li> <li>Health Monitoring: Real-time system status and diagnostics</li> <li>Security Features: CSRF protection, rate limiting, IP restrictions</li> <li>Responsive UI: Works on desktop and mobile devices</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start: Get up and running in 5 minutes</li> <li>Basic Configuration: Detailed configuration options</li> <li>Advanced Topics: Production features and advanced configurations</li> <li>API Reference: Complete API documentation</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Get CRUDAdmin up and running in just a few minutes! This guide will walk you through creating your first admin interface.</p>"},{"location":"quick-start/#requirements","title":"Requirements","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python: Version 3.9 or newer</li> <li>FastAPI: CRUDAdmin is built to work with FastAPI</li> <li>FastCRUD: CRUDAdmin is built on top of FastCRUD for CRUD operations (which requires SQLAlchemy 2.0+ for database operations and Pydantic 2.0+ for data validation and serialization)</li> <li>aiosqlite: Required for async SQLite operations (automatically installed as a dependency)</li> </ul>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>Install CRUDAdmin:</p> <pre><code>uv add crudadmin\n</code></pre> <p>Or using pip:</p> <pre><code>pip install crudadmin\n</code></pre> <p>For production with Redis sessions (recommended):</p> <pre><code>uv add \"crudadmin[redis]\"\n</code></pre>"},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your SQLAlchemy model, Pydantic schemas and database connection, just skip to Using CRUDAdmin</p>"},{"location":"quick-start/#basic-setup","title":"Basic Setup","text":"Define your SQLAlchemy model (click to expand) <pre><code>from sqlalchemy import Column, Integer, String, Boolean, DateTime, func\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    username = Column(String(50), unique=True, nullable=False)\n    email = Column(String(100), unique=True, nullable=False)\n    role = Column(String(20), default=\"user\")\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> Define your Pydantic schemas (click to expand) <pre><code>from pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    role: str = \"user\"\n    is_active: bool = True\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    role: Optional[str] = None\n    is_active: Optional[bool] = None\n</code></pre> Set up your database connection (click to expand) <pre><code>from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"sqlite+aiosqlite:///./admin_demo.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"quick-start/#using-crudadmin","title":"Using CRUDAdmin","text":"<p>Create your admin interface and mount it to your FastAPI application</p> main.py<pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nimport os\n\nfrom crudadmin import CRUDAdmin\n# Import your setup (models, schemas, database)\n\n# Create admin interface\nadmin = CRUDAdmin(\n    session=async_session,  # Your session factory\n    SECRET_KEY=os.environ.get(\"SECRET_KEY\", \"your-secret-key-for-development\"),\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"admin123\"  # Change this in production!\n    }\n)\n\n# Add your models to the admin interface\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n\n# Initialize database and admin\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Create tables\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    # Initialize admin interface\n    await admin.initialize()\n    yield\n\n# Create FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# Mount admin interface\napp.mount(\"/admin\", admin.app)\n</code></pre> <p>And you're all done! </p>"},{"location":"quick-start/#accessing-your-admin-interface","title":"Accessing Your Admin Interface","text":"<ol> <li> <p>Start your FastAPI server: <pre><code>uvicorn main:app --reload\n</code></pre></p> </li> <li> <p>Navigate to the admin interface: <pre><code>http://localhost:8000/admin\n</code></pre></p> </li> <li> <p>Log in with your admin credentials:</p> <ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin123</code></li> </ul> </li> <li> <p>Start managing your data:</p> <ul> <li>View existing users</li> <li>Create new users  </li> <li>Edit user information</li> <li>Delete users (if enabled)</li> </ul> </li> </ol>"},{"location":"quick-start/#what-you-get-out-of-the-box","title":"What You Get Out of the Box","text":"<p>\u2705 Secure Authentication - Login/logout with session management \u2705 Auto-Generated Forms - Create and edit forms built from your Pydantic schemas \u2705 Data Tables - Paginated, sortable tables for viewing your data \u2705 CRUD Operations - Full Create, Read, Update, Delete functionality \u2705 Responsive UI - Works on desktop and mobile devices \u2705 Dark/Light Themes - Toggle between themes \u2705 Input Validation - Built-in validation using your Pydantic schemas  </p>"},{"location":"quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic admin interface running, you might want to:</p> <ul> <li>Add more models to your admin interface</li> <li>Learn the interface to effectively manage your data</li> <li>Set up admin users for access control</li> <li>Explore common patterns for real-world scenarios</li> <li>Advanced Topics for production features and security</li> </ul>"},{"location":"quick-start/#production-considerations","title":"Production Considerations","text":"<p>Security Notice</p> <p>The example above uses a simple password and secret key for demonstration. In production:</p> <ul> <li>Use strong, randomly generated secret keys</li> <li>Use environment variables for sensitive configuration</li> <li>Consider using Redis for session storage: <code>uv add \"crudadmin[redis]\"</code></li> <li>Enable HTTPS and secure cookies</li> <li>Set up proper logging and monitoring</li> </ul> <p>For production deployment and advanced configurations, see the Advanced Topics section.</p>"},{"location":"advanced/overview/","title":"Advanced Topics","text":"<p>Welcome to the Advanced section of CRUDAdmin documentation. This section covers production-grade features, scalability patterns, and sophisticated configurations for enterprise deployments.</p>"},{"location":"advanced/overview/#what-youll-find-here","title":"What You'll Find Here","text":"<p>The Advanced section is designed for production deployments and complex use cases that go beyond basic CRUDAdmin setup.</p>"},{"location":"advanced/overview/#planned-advanced-topics","title":"Planned Advanced Topics","text":""},{"location":"advanced/overview/#advanced-security","title":"\ud83d\udd12 Advanced Security","text":"<p>Coming Soon</p>"},{"location":"advanced/overview/#session-management","title":"\ud83d\udcca Session Management","text":"<p>Coming Soon</p>"},{"location":"advanced/overview/#event-tracking-audit-logging","title":"\ud83d\udcdd Event Tracking &amp; Audit Logging","text":"<p>Coming Soon</p>"},{"location":"advanced/overview/#deployment-scaling","title":"\ud83d\ude80 Deployment &amp; Scaling","text":"<p>Coming Soon</p>"},{"location":"advanced/overview/#advanced-configuration","title":"\u2699\ufe0f Advanced Configuration","text":"<p>Coming Soon</p>"},{"location":"advanced/overview/#prerequisites","title":"Prerequisites","text":"<p>Before diving into advanced topics, ensure you have:</p> <ul> <li>\u2705 Completed the Usage Guide</li> <li>\u2705 Implemented basic CRUDAdmin setup</li> <li>\u2705 Understanding of FastAPI and SQLAlchemy</li> <li>\u2705 Experience with production deployments</li> </ul>"},{"location":"advanced/overview/#getting-started","title":"Getting Started","text":"<p>The advanced topics will be released progressively. Each section will include:</p> <ul> <li>Real-world examples from production environments</li> <li>Complete configuration samples ready for deployment</li> <li>Performance benchmarks and optimization guides</li> <li>Security best practices and compliance guidance</li> <li>Troubleshooting guides for common production issues</li> </ul>"},{"location":"advanced/overview/#stay-updated","title":"Stay Updated","text":"<p>Check back regularly for new advanced topics as they become available. Each new section will provide comprehensive, production-tested guidance for sophisticated CRUDAdmin deployments.</p> <p>Note: If you have specific advanced topics you'd like to see covered, please let us know through our github. </p>"},{"location":"api/admin_site/","title":"AdminSite Class API Reference","text":""},{"location":"api/admin_site/#class-definition","title":"Class Definition","text":"<p>Core admin interface site handler managing authentication, routing, and views.</p> <p>Handles the core functionality of the admin interface including: - Authentication and session management - Route configuration and URL handling - Template rendering and context management - Dashboard and model views - Event logging and audit trails - Security and access control</p> <p>The AdminSite class serves as the central coordinator for all admin functionality, managing user sessions, handling authentication flows, and providing secure access to administrative features.</p> <p>Parameters:</p> Name Type Description Default <code>database_config</code> <code>DatabaseConfig</code> <p>Database configuration for admin interface</p> required <code>templates_directory</code> <code>str</code> <p>Path to template files</p> required <code>models</code> <code>Dict[str, Any]</code> <p>Dictionary of registered models</p> required <code>admin_authentication</code> <code>AdminAuthentication</code> <p>Authentication handler</p> required <code>mount_path</code> <code>str</code> <p>URL prefix for admin routes</p> required <code>theme</code> <code>str</code> <p>Active UI theme</p> required <code>secure_cookies</code> <code>bool</code> <p>Enable secure cookie flags</p> required <code>event_integration</code> <code>Optional[Any]</code> <p>Optional event logging integration</p> <code>None</code> <code>session_manager</code> <code>Optional[SessionManager]</code> <p>Optional session manager</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>db_config</code> <code>DatabaseConfig</code> <p>Database configuration instance</p> <code>router</code> <code>APIRouter</code> <p>FastAPI router for admin endpoints</p> <code>templates</code> <code>Jinja2Templates</code> <p>Jinja2 template handler</p> <code>models</code> <code>Dict[str, Any]</code> <p>Dictionary of registered models</p> <code>admin_user_service</code> <code>AdminUserService</code> <p>Service for user management</p> <code>admin_authentication</code> <code>AdminAuthentication</code> <p>Authentication handler</p> <code>mount_path</code> <code>str</code> <p>URL prefix for admin routes</p> <code>theme</code> <code>str</code> <p>Active UI theme</p> <code>event_integration</code> <code>Optional[Any]</code> <p>Event logging handler</p> <code>session_manager</code> <p>Session tracking service</p> <code>secure_cookies</code> <code>bool</code> <p>Cookie security flag</p> <p>Examples:</p> <p>Basic setup with SQLite: <pre><code>from fastapi.templating import Jinja2Templates\nfrom .auth import AdminAuthentication\nfrom .db import DatabaseConfig\n\nadmin_site = AdminSite(\n    database_config=db_config,\n    templates_directory=\"templates\",\n    models={},  # Empty initially\n    admin_authentication=auth_handler,\n    mount_path=\"/admin\",\n    theme=\"dark-theme\",\n    secure_cookies=True\n)\n\n# Add routes\nadmin_site.setup_routes()\n</code></pre></p> <p>Production configuration: <pre><code>admin_site = AdminSite(\n    database_config=db_config,\n    templates_directory=templates_path,\n    models=model_registry,\n    admin_authentication=auth_handler,\n    mount_path=\"/admin\",\n    theme=\"dark-theme\",\n    secure_cookies=True,\n    event_integration=event_logger\n)\n</code></pre></p> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>class AdminSite:\n    \"\"\"\n    Core admin interface site handler managing authentication, routing, and views.\n\n    **Handles the core functionality of the admin interface including:**\n    - Authentication and session management\n    - Route configuration and URL handling\n    - Template rendering and context management\n    - Dashboard and model views\n    - Event logging and audit trails\n    - Security and access control\n\n    The AdminSite class serves as the central coordinator for all admin functionality,\n    managing user sessions, handling authentication flows, and providing secure access\n    to administrative features.\n\n    Args:\n        database_config: Database configuration for admin interface\n        templates_directory: Path to template files\n        models: Dictionary of registered models\n        admin_authentication: Authentication handler\n        mount_path: URL prefix for admin routes\n        theme: Active UI theme\n        secure_cookies: Enable secure cookie flags\n        event_integration: Optional event logging integration\n        session_manager: Optional session manager\n\n    Attributes:\n        db_config: Database configuration instance\n        router: FastAPI router for admin endpoints\n        templates: Jinja2 template handler\n        models: Dictionary of registered models\n        admin_user_service: Service for user management\n        admin_authentication: Authentication handler\n        mount_path: URL prefix for admin routes\n        theme: Active UI theme\n        event_integration: Event logging handler\n        session_manager: Session tracking service\n        secure_cookies: Cookie security flag\n\n    Examples:\n        Basic setup with SQLite:\n        ```python\n        from fastapi.templating import Jinja2Templates\n        from .auth import AdminAuthentication\n        from .db import DatabaseConfig\n\n        admin_site = AdminSite(\n            database_config=db_config,\n            templates_directory=\"templates\",\n            models={},  # Empty initially\n            admin_authentication=auth_handler,\n            mount_path=\"/admin\",\n            theme=\"dark-theme\",\n            secure_cookies=True\n        )\n\n        # Add routes\n        admin_site.setup_routes()\n        ```\n\n        Production configuration:\n        ```python\n        admin_site = AdminSite(\n            database_config=db_config,\n            templates_directory=templates_path,\n            models=model_registry,\n            admin_authentication=auth_handler,\n            mount_path=\"/admin\",\n            theme=\"dark-theme\",\n            secure_cookies=True,\n            event_integration=event_logger\n        )\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        database_config: DatabaseConfig,\n        templates_directory: str,\n        models: Dict[str, Any],\n        admin_authentication: AdminAuthentication,\n        mount_path: str,\n        theme: str,\n        secure_cookies: bool,\n        event_integration: Optional[Any] = None,\n        session_manager: Optional[SessionManager] = None,\n    ) -&gt; None:\n        self.db_config: DatabaseConfig = database_config\n        self.router: APIRouter = APIRouter()\n        self.templates: Jinja2Templates = Jinja2Templates(directory=templates_directory)\n        self.models: Dict[str, Any] = models\n        self.admin_authentication: AdminAuthentication = admin_authentication\n        self.admin_user_service: AdminUserService = admin_authentication.user_service\n\n        self.mount_path: str = mount_path\n        self.theme: str = theme\n        self.event_integration: Optional[Any] = event_integration\n\n        if session_manager:\n            self.session_manager = session_manager\n        else:\n            storage: AbstractSessionStorage[SessionData] = get_session_storage(\n                backend=\"memory\",\n                model_type=SessionData,\n                prefix=\"session:\",\n                expiration=30 * 60,\n            )\n\n            self.session_manager = SessionManager(\n                session_storage=storage,\n                max_sessions_per_user=5,\n                session_timeout_minutes=30,\n                cleanup_interval_minutes=15,\n            )\n\n        self.secure_cookies: bool = secure_cookies\n\n    def setup_routes(self) -&gt; None:\n        \"\"\"\n        Configure all admin interface routes including auth, dashboard and model views.\n\n        Routes Created:\n            **Auth Routes:**\n                - POST /login - Handle login form submission\n                - GET /login - Display login page\n                - GET /logout - Process user logout\n\n            **Dashboard Routes:**\n                - GET / - Main dashboard view\n                - GET /dashboard-content - HTMX dashboard updates\n\n        Notes:\n            - All routes except login require authentication\n            - Routes use Jinja2 templates for rendering\n            - HTMX integration for dynamic updates\n            - Event logging integration if enabled\n\n        Example:\n            ```python\n            admin_site = AdminSite(...)\n            admin_site.setup_routes()\n            app.include_router(admin_site.router)\n            ```\n        \"\"\"\n        self.router.add_api_route(\n            \"/login\",\n            self.login_page(),\n            methods=[\"POST\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/logout\",\n            self.logout_endpoint(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/login\",\n            self.admin_login_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/dashboard-content\",\n            self.dashboard_content(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(self.admin_authentication.get_current_user)],\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/\",\n            self.dashboard_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(self.admin_authentication.get_current_user)],\n            response_model=None,\n        )\n\n    def login_page(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create login form handler for admin authentication.\n\n        Returns:\n            FastAPI route handler that processes login form submission.\n\n        Notes:\n            - Validates credentials and creates user session on success\n            - Sets secure cookies with session ID\n            - Logs login attempts if event tracking enabled\n        \"\"\"\n\n        @log_auth_action(EventType.LOGIN)\n        async def login_page_inner(\n            request: Request,\n            response: Response,\n            form_data: OAuth2PasswordRequestForm = Depends(),\n            db: AsyncSession = Depends(self.db_config.get_admin_db),\n            event_integration: Optional[Any] = Depends(lambda: self.event_integration),\n        ) -&gt; RouteResponse:\n            logger.info(\"Processing login attempt...\")\n            try:\n                user = await self.admin_user_service.authenticate_user(\n                    form_data.username, form_data.password, db=db\n                )\n                if not user:\n                    logger.warning(\n                        f\"Authentication failed for user: {form_data.username}\"\n                    )\n                    return self.templates.TemplateResponse(\n                        \"auth/login.html\",\n                        {\n                            \"request\": request,\n                            \"error\": \"Invalid credentials. Please try again.\",\n                            \"mount_path\": self.mount_path,\n                            \"theme\": self.theme,\n                        },\n                    )\n\n                request.state.user = user\n                logger.info(\"User authenticated successfully, creating session\")\n\n                try:\n                    logger.info(\"Creating user session...\")\n                    session_id, csrf_token = await self.session_manager.create_session(\n                        request=request,\n                        user_id=user[\"id\"],\n                        metadata={\n                            \"login_type\": \"password\",\n                            \"username\": user[\"username\"],\n                            \"creation_time\": datetime.now(UTC).isoformat(),\n                        },\n                    )\n\n                    if not session_id:\n                        logger.error(\"Failed to create session\")\n                        raise Exception(\"Session creation failed\")\n\n                    logger.info(f\"Session created successfully: {session_id}\")\n\n                    response = RedirectResponse(\n                        url=f\"/{self.mount_path}/\", status_code=303\n                    )\n\n                    self.session_manager.set_session_cookies(\n                        response=response,\n                        session_id=session_id,\n                        csrf_token=csrf_token,\n                        secure=self.secure_cookies,\n                        path=f\"/{self.mount_path}\",\n                    )\n\n                    await db.commit()\n                    logger.info(\"Login completed successfully\")\n                    return response\n\n                except Exception as e:\n                    logger.error(\n                        f\"Error during session creation: {str(e)}\", exc_info=True\n                    )\n                    await db.rollback()\n                    return self.templates.TemplateResponse(\n                        \"auth/login.html\",\n                        {\n                            \"request\": request,\n                            \"error\": f\"Error creating session: {str(e)}\",\n                            \"mount_path\": self.mount_path,\n                            \"theme\": self.theme,\n                        },\n                    )\n\n            except Exception as e:\n                logger.error(f\"Error during login: {str(e)}\", exc_info=True)\n                return self.templates.TemplateResponse(\n                    \"auth/login.html\",\n                    {\n                        \"request\": request,\n                        \"error\": \"An error occurred during login. Please try again.\",\n                        \"mount_path\": self.mount_path,\n                        \"theme\": self.theme,\n                    },\n                )\n\n        return cast(EndpointCallable, login_page_inner)\n\n    def logout_endpoint(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create logout handler for admin authentication.\n\n        Returns:\n            FastAPI route handler that terminates session and clears auth cookies.\n\n        Notes:\n            - Revokes access tokens\n            - Terminates active sessions\n            - Cleans up auth cookies\n            - Logs logout events if tracking enabled\n        \"\"\"\n\n        @log_auth_action(EventType.LOGOUT)\n        async def logout_endpoint_inner(\n            request: Request,\n            response: Response,\n            db: AsyncSession = Depends(self.db_config.get_admin_db),\n            session_id: Optional[str] = Cookie(None),\n            event_integration: Optional[Any] = Depends(lambda: self.event_integration),\n        ) -&gt; RouteResponse:\n            if session_id:\n                await self.session_manager.terminate_session(session_id=session_id)\n\n            response = RedirectResponse(\n                url=f\"/{self.mount_path}/login\", status_code=303\n            )\n\n            self.session_manager.clear_session_cookies(\n                response=response,\n                path=f\"/{self.mount_path}\",\n            )\n\n            return response\n\n        return cast(EndpointCallable, logout_endpoint_inner)\n\n    def admin_login_page(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create login page handler for the admin interface.\n\n        Returns:\n            FastAPI route handler for login page\n\n        Notes:\n            - Checks for existing auth cookies\n            - Validates active sessions\n            - Redirects authenticated users to dashboard\n            - Displays login form with any error messages\n        \"\"\"\n\n        async def admin_login_page_inner(\n            request: Request,\n            db: AsyncSession = Depends(self.db_config.get_admin_db),\n        ) -&gt; RouteResponse:\n            try:\n                session_id = request.cookies.get(\"session_id\")\n\n                if session_id:\n                    is_valid_session = await self.session_manager.validate_session(\n                        session_id=session_id\n                    )\n\n                    if is_valid_session:\n                        return RedirectResponse(\n                            url=f\"/{self.mount_path}/\", status_code=303\n                        )\n\n            except Exception:\n                pass\n\n            error = request.query_params.get(\"error\")\n            return self.templates.TemplateResponse(\n                \"auth/login.html\",\n                {\n                    \"request\": request,\n                    \"mount_path\": self.mount_path,\n                    \"theme\": self.theme,\n                    \"error\": error,\n                },\n            )\n\n        return cast(EndpointCallable, admin_login_page_inner)\n\n    def dashboard_content(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create dashboard content handler for HTMX dynamic updates.\n\n        Returns:\n            FastAPI route handler for dashboard content\n        \"\"\"\n\n        async def dashboard_content_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            app_db: AsyncSession = Depends(\n                cast(\n                    Callable[..., AsyncGenerator[AsyncSession, None]],\n                    self.db_config.session,\n                )\n            ),\n        ) -&gt; RouteResponse:\n            \"\"\"\n            Renders partial content for the dashboard (HTMX).\n            \"\"\"\n            context = await self.get_base_context(admin_db=admin_db, app_db=app_db)\n            context.update({\"request\": request})\n            return self.templates.TemplateResponse(\n                \"admin/dashboard/dashboard_content.html\", context\n            )\n\n        return cast(EndpointCallable, dashboard_content_inner)\n\n    async def get_base_context(\n        self, admin_db: AsyncSession, app_db: AsyncSession\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get common context data needed for base template.\n\n        Args:\n            admin_db: Admin database session for authentication queries\n            app_db: Application database session for model queries\n\n        Returns:\n            Dictionary containing auth tables, model data, and config\n\n        Notes:\n            - Queries model counts asynchronously\n            - Includes auth model stats and status\n            - Required by all admin templates\n        \"\"\"\n        auth_model_counts: Dict[str, int] = {}\n        for model_name, model_data in self.admin_authentication.auth_models.items():\n            crud_obj = cast(FastCRUD, model_data[\"crud\"])\n            if model_name == \"AdminSession\":\n                total_count = await crud_obj.count(self.db_config.admin_session)\n                active_count = await crud_obj.count(\n                    self.db_config.admin_session, is_active=True\n                )\n                auth_model_counts[model_name] = total_count\n                auth_model_counts[f\"{model_name}_active\"] = active_count\n            else:\n                count = await crud_obj.count(self.db_config.admin_session)\n                auth_model_counts[model_name] = count\n\n        model_counts: Dict[str, int] = {}\n        for model_name, model_data in self.models.items():\n            crud = cast(FastCRUD, model_data[\"crud\"])\n            cnt = await crud.count(app_db)\n            model_counts[model_name] = cnt\n\n        return {\n            \"auth_table_names\": self.admin_authentication.auth_models.keys(),\n            \"table_names\": self.models.keys(),\n            \"auth_model_counts\": auth_model_counts,\n            \"model_counts\": model_counts,\n            \"mount_path\": self.mount_path,\n            \"track_events\": self.event_integration is not None,\n            \"theme\": self.theme,\n        }\n\n    def dashboard_page(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create main dashboard page handler.\n\n        Returns:\n            FastAPI route handler for the admin dashboard\n        \"\"\"\n\n        async def dashboard_page_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            app_db: AsyncSession = Depends(\n                cast(\n                    Callable[..., AsyncGenerator[AsyncSession, None]],\n                    self.db_config.session,\n                )\n            ),\n        ) -&gt; RouteResponse:\n            context = await self.get_base_context(admin_db=admin_db, app_db=app_db)\n            context.update({\"request\": request, \"include_sidebar_and_header\": True})\n            return self.templates.TemplateResponse(\n                \"admin/dashboard/dashboard.html\", context\n            )\n\n        return cast(EndpointCallable, dashboard_page_inner)\n\n    def admin_auth_model_page(self, model_key: str) -&gt; EndpointCallable:\n        \"\"\"\n        Create page handler for authentication model views.\n\n        Args:\n            model_key: Name of authentication model to display\n\n        Returns:\n            FastAPI route handler for auth model list view\n\n        Notes:\n            - Handles pagination and sorting\n            - Formats special fields like JSON\n            - Integrates with event logging if enabled\n        \"\"\"\n\n        async def admin_auth_model_page_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            db: AsyncSession = Depends(self.db_config.get_admin_db),\n        ) -&gt; RouteResponse:\n            auth_model = self.admin_authentication.auth_models[model_key]\n            sqlalchemy_model = cast(Any, auth_model[\"model\"])\n\n            table_columns = []\n            if hasattr(sqlalchemy_model, \"__table__\"):\n                table_columns = [\n                    column.key for column in sqlalchemy_model.__table__.columns\n                ]\n\n            page_str = request.query_params.get(\"page\", \"1\")\n            limit_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n\n            try:\n                page = int(page_str)\n                limit = int(limit_str)\n            except ValueError:\n                page = 1\n                limit = 10\n\n            offset = (page - 1) * limit\n            items: Dict[str, Any] = {\"data\": [], \"total_count\": 0}\n            try:\n                crud = cast(FastCRUD, auth_model[\"crud\"])\n                fetched = await crud.get_multi(db=admin_db, offset=offset, limit=limit)\n                items = dict(fetched)\n\n                logger.info(f\"Retrieved items for {model_key}: {items}\")\n                total_items = items.get(\"total_count\", 0)\n\n                if model_key == \"AdminSession\":\n                    formatted_items = []\n                    data = items[\"data\"]\n                    for item in data:\n                        if not isinstance(item, dict):\n                            item = {\n                                k: v\n                                for k, v in vars(item).items()\n                                if not k.startswith(\"_\")\n                            }\n                        if \"device_info\" in item and isinstance(\n                            item[\"device_info\"], dict\n                        ):\n                            item[\"device_info\"] = str(item[\"device_info\"])\n                        if \"session_metadata\" in item and isinstance(\n                            item[\"session_metadata\"], dict\n                        ):\n                            item[\"session_metadata\"] = str(item[\"session_metadata\"])\n                        formatted_items.append(item)\n                    items[\"data\"] = formatted_items\n            except Exception as e:\n                logger.error(\n                    f\"Error retrieving {model_key} data: {str(e)}\", exc_info=True\n                )\n                total_items = 0\n\n            total_pages = max(1, (total_items + limit - 1) // limit)\n\n            context = await self.get_base_context(admin_db=admin_db, app_db=db)\n            context.update(\n                {\n                    \"request\": request,\n                    \"model_items\": items[\"data\"],\n                    \"model_name\": model_key,\n                    \"table_columns\": table_columns,\n                    \"current_page\": page,\n                    \"rows_per_page\": limit,\n                    \"total_items\": total_items,\n                    \"total_pages\": total_pages,\n                    \"primary_key_info\": self.db_config.get_primary_key_info(\n                        cast(Any, sqlalchemy_model)\n                    ),\n                    \"sort_column\": None,\n                    \"sort_order\": \"asc\",\n                    \"include_sidebar_and_header\": True,\n                }\n            )\n\n            return self.templates.TemplateResponse(\"admin/model/list.html\", context)\n\n        return cast(EndpointCallable, admin_auth_model_page_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.admin_auth_model_page","title":"<code>admin_auth_model_page(model_key)</code>","text":"<p>Create page handler for authentication model views.</p> <p>Parameters:</p> Name Type Description Default <code>model_key</code> <code>str</code> <p>Name of authentication model to display</p> required <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for auth model list view</p> Notes <ul> <li>Handles pagination and sorting</li> <li>Formats special fields like JSON</li> <li>Integrates with event logging if enabled</li> </ul> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def admin_auth_model_page(self, model_key: str) -&gt; EndpointCallable:\n    \"\"\"\n    Create page handler for authentication model views.\n\n    Args:\n        model_key: Name of authentication model to display\n\n    Returns:\n        FastAPI route handler for auth model list view\n\n    Notes:\n        - Handles pagination and sorting\n        - Formats special fields like JSON\n        - Integrates with event logging if enabled\n    \"\"\"\n\n    async def admin_auth_model_page_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        db: AsyncSession = Depends(self.db_config.get_admin_db),\n    ) -&gt; RouteResponse:\n        auth_model = self.admin_authentication.auth_models[model_key]\n        sqlalchemy_model = cast(Any, auth_model[\"model\"])\n\n        table_columns = []\n        if hasattr(sqlalchemy_model, \"__table__\"):\n            table_columns = [\n                column.key for column in sqlalchemy_model.__table__.columns\n            ]\n\n        page_str = request.query_params.get(\"page\", \"1\")\n        limit_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n\n        try:\n            page = int(page_str)\n            limit = int(limit_str)\n        except ValueError:\n            page = 1\n            limit = 10\n\n        offset = (page - 1) * limit\n        items: Dict[str, Any] = {\"data\": [], \"total_count\": 0}\n        try:\n            crud = cast(FastCRUD, auth_model[\"crud\"])\n            fetched = await crud.get_multi(db=admin_db, offset=offset, limit=limit)\n            items = dict(fetched)\n\n            logger.info(f\"Retrieved items for {model_key}: {items}\")\n            total_items = items.get(\"total_count\", 0)\n\n            if model_key == \"AdminSession\":\n                formatted_items = []\n                data = items[\"data\"]\n                for item in data:\n                    if not isinstance(item, dict):\n                        item = {\n                            k: v\n                            for k, v in vars(item).items()\n                            if not k.startswith(\"_\")\n                        }\n                    if \"device_info\" in item and isinstance(\n                        item[\"device_info\"], dict\n                    ):\n                        item[\"device_info\"] = str(item[\"device_info\"])\n                    if \"session_metadata\" in item and isinstance(\n                        item[\"session_metadata\"], dict\n                    ):\n                        item[\"session_metadata\"] = str(item[\"session_metadata\"])\n                    formatted_items.append(item)\n                items[\"data\"] = formatted_items\n        except Exception as e:\n            logger.error(\n                f\"Error retrieving {model_key} data: {str(e)}\", exc_info=True\n            )\n            total_items = 0\n\n        total_pages = max(1, (total_items + limit - 1) // limit)\n\n        context = await self.get_base_context(admin_db=admin_db, app_db=db)\n        context.update(\n            {\n                \"request\": request,\n                \"model_items\": items[\"data\"],\n                \"model_name\": model_key,\n                \"table_columns\": table_columns,\n                \"current_page\": page,\n                \"rows_per_page\": limit,\n                \"total_items\": total_items,\n                \"total_pages\": total_pages,\n                \"primary_key_info\": self.db_config.get_primary_key_info(\n                    cast(Any, sqlalchemy_model)\n                ),\n                \"sort_column\": None,\n                \"sort_order\": \"asc\",\n                \"include_sidebar_and_header\": True,\n            }\n        )\n\n        return self.templates.TemplateResponse(\"admin/model/list.html\", context)\n\n    return cast(EndpointCallable, admin_auth_model_page_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.admin_login_page","title":"<code>admin_login_page()</code>","text":"<p>Create login page handler for the admin interface.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for login page</p> Notes <ul> <li>Checks for existing auth cookies</li> <li>Validates active sessions</li> <li>Redirects authenticated users to dashboard</li> <li>Displays login form with any error messages</li> </ul> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def admin_login_page(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create login page handler for the admin interface.\n\n    Returns:\n        FastAPI route handler for login page\n\n    Notes:\n        - Checks for existing auth cookies\n        - Validates active sessions\n        - Redirects authenticated users to dashboard\n        - Displays login form with any error messages\n    \"\"\"\n\n    async def admin_login_page_inner(\n        request: Request,\n        db: AsyncSession = Depends(self.db_config.get_admin_db),\n    ) -&gt; RouteResponse:\n        try:\n            session_id = request.cookies.get(\"session_id\")\n\n            if session_id:\n                is_valid_session = await self.session_manager.validate_session(\n                    session_id=session_id\n                )\n\n                if is_valid_session:\n                    return RedirectResponse(\n                        url=f\"/{self.mount_path}/\", status_code=303\n                    )\n\n        except Exception:\n            pass\n\n        error = request.query_params.get(\"error\")\n        return self.templates.TemplateResponse(\n            \"auth/login.html\",\n            {\n                \"request\": request,\n                \"mount_path\": self.mount_path,\n                \"theme\": self.theme,\n                \"error\": error,\n            },\n        )\n\n    return cast(EndpointCallable, admin_login_page_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.dashboard_content","title":"<code>dashboard_content()</code>","text":"<p>Create dashboard content handler for HTMX dynamic updates.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for dashboard content</p> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def dashboard_content(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create dashboard content handler for HTMX dynamic updates.\n\n    Returns:\n        FastAPI route handler for dashboard content\n    \"\"\"\n\n    async def dashboard_content_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        app_db: AsyncSession = Depends(\n            cast(\n                Callable[..., AsyncGenerator[AsyncSession, None]],\n                self.db_config.session,\n            )\n        ),\n    ) -&gt; RouteResponse:\n        \"\"\"\n        Renders partial content for the dashboard (HTMX).\n        \"\"\"\n        context = await self.get_base_context(admin_db=admin_db, app_db=app_db)\n        context.update({\"request\": request})\n        return self.templates.TemplateResponse(\n            \"admin/dashboard/dashboard_content.html\", context\n        )\n\n    return cast(EndpointCallable, dashboard_content_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.dashboard_page","title":"<code>dashboard_page()</code>","text":"<p>Create main dashboard page handler.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for the admin dashboard</p> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def dashboard_page(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create main dashboard page handler.\n\n    Returns:\n        FastAPI route handler for the admin dashboard\n    \"\"\"\n\n    async def dashboard_page_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        app_db: AsyncSession = Depends(\n            cast(\n                Callable[..., AsyncGenerator[AsyncSession, None]],\n                self.db_config.session,\n            )\n        ),\n    ) -&gt; RouteResponse:\n        context = await self.get_base_context(admin_db=admin_db, app_db=app_db)\n        context.update({\"request\": request, \"include_sidebar_and_header\": True})\n        return self.templates.TemplateResponse(\n            \"admin/dashboard/dashboard.html\", context\n        )\n\n    return cast(EndpointCallable, dashboard_page_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.get_base_context","title":"<code>get_base_context(admin_db, app_db)</code>  <code>async</code>","text":"<p>Get common context data needed for base template.</p> <p>Parameters:</p> Name Type Description Default <code>admin_db</code> <code>AsyncSession</code> <p>Admin database session for authentication queries</p> required <code>app_db</code> <code>AsyncSession</code> <p>Application database session for model queries</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing auth tables, model data, and config</p> Notes <ul> <li>Queries model counts asynchronously</li> <li>Includes auth model stats and status</li> <li>Required by all admin templates</li> </ul> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>async def get_base_context(\n    self, admin_db: AsyncSession, app_db: AsyncSession\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get common context data needed for base template.\n\n    Args:\n        admin_db: Admin database session for authentication queries\n        app_db: Application database session for model queries\n\n    Returns:\n        Dictionary containing auth tables, model data, and config\n\n    Notes:\n        - Queries model counts asynchronously\n        - Includes auth model stats and status\n        - Required by all admin templates\n    \"\"\"\n    auth_model_counts: Dict[str, int] = {}\n    for model_name, model_data in self.admin_authentication.auth_models.items():\n        crud_obj = cast(FastCRUD, model_data[\"crud\"])\n        if model_name == \"AdminSession\":\n            total_count = await crud_obj.count(self.db_config.admin_session)\n            active_count = await crud_obj.count(\n                self.db_config.admin_session, is_active=True\n            )\n            auth_model_counts[model_name] = total_count\n            auth_model_counts[f\"{model_name}_active\"] = active_count\n        else:\n            count = await crud_obj.count(self.db_config.admin_session)\n            auth_model_counts[model_name] = count\n\n    model_counts: Dict[str, int] = {}\n    for model_name, model_data in self.models.items():\n        crud = cast(FastCRUD, model_data[\"crud\"])\n        cnt = await crud.count(app_db)\n        model_counts[model_name] = cnt\n\n    return {\n        \"auth_table_names\": self.admin_authentication.auth_models.keys(),\n        \"table_names\": self.models.keys(),\n        \"auth_model_counts\": auth_model_counts,\n        \"model_counts\": model_counts,\n        \"mount_path\": self.mount_path,\n        \"track_events\": self.event_integration is not None,\n        \"theme\": self.theme,\n    }\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.login_page","title":"<code>login_page()</code>","text":"<p>Create login form handler for admin authentication.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler that processes login form submission.</p> Notes <ul> <li>Validates credentials and creates user session on success</li> <li>Sets secure cookies with session ID</li> <li>Logs login attempts if event tracking enabled</li> </ul> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def login_page(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create login form handler for admin authentication.\n\n    Returns:\n        FastAPI route handler that processes login form submission.\n\n    Notes:\n        - Validates credentials and creates user session on success\n        - Sets secure cookies with session ID\n        - Logs login attempts if event tracking enabled\n    \"\"\"\n\n    @log_auth_action(EventType.LOGIN)\n    async def login_page_inner(\n        request: Request,\n        response: Response,\n        form_data: OAuth2PasswordRequestForm = Depends(),\n        db: AsyncSession = Depends(self.db_config.get_admin_db),\n        event_integration: Optional[Any] = Depends(lambda: self.event_integration),\n    ) -&gt; RouteResponse:\n        logger.info(\"Processing login attempt...\")\n        try:\n            user = await self.admin_user_service.authenticate_user(\n                form_data.username, form_data.password, db=db\n            )\n            if not user:\n                logger.warning(\n                    f\"Authentication failed for user: {form_data.username}\"\n                )\n                return self.templates.TemplateResponse(\n                    \"auth/login.html\",\n                    {\n                        \"request\": request,\n                        \"error\": \"Invalid credentials. Please try again.\",\n                        \"mount_path\": self.mount_path,\n                        \"theme\": self.theme,\n                    },\n                )\n\n            request.state.user = user\n            logger.info(\"User authenticated successfully, creating session\")\n\n            try:\n                logger.info(\"Creating user session...\")\n                session_id, csrf_token = await self.session_manager.create_session(\n                    request=request,\n                    user_id=user[\"id\"],\n                    metadata={\n                        \"login_type\": \"password\",\n                        \"username\": user[\"username\"],\n                        \"creation_time\": datetime.now(UTC).isoformat(),\n                    },\n                )\n\n                if not session_id:\n                    logger.error(\"Failed to create session\")\n                    raise Exception(\"Session creation failed\")\n\n                logger.info(f\"Session created successfully: {session_id}\")\n\n                response = RedirectResponse(\n                    url=f\"/{self.mount_path}/\", status_code=303\n                )\n\n                self.session_manager.set_session_cookies(\n                    response=response,\n                    session_id=session_id,\n                    csrf_token=csrf_token,\n                    secure=self.secure_cookies,\n                    path=f\"/{self.mount_path}\",\n                )\n\n                await db.commit()\n                logger.info(\"Login completed successfully\")\n                return response\n\n            except Exception as e:\n                logger.error(\n                    f\"Error during session creation: {str(e)}\", exc_info=True\n                )\n                await db.rollback()\n                return self.templates.TemplateResponse(\n                    \"auth/login.html\",\n                    {\n                        \"request\": request,\n                        \"error\": f\"Error creating session: {str(e)}\",\n                        \"mount_path\": self.mount_path,\n                        \"theme\": self.theme,\n                    },\n                )\n\n        except Exception as e:\n            logger.error(f\"Error during login: {str(e)}\", exc_info=True)\n            return self.templates.TemplateResponse(\n                \"auth/login.html\",\n                {\n                    \"request\": request,\n                    \"error\": \"An error occurred during login. Please try again.\",\n                    \"mount_path\": self.mount_path,\n                    \"theme\": self.theme,\n                },\n            )\n\n    return cast(EndpointCallable, login_page_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.logout_endpoint","title":"<code>logout_endpoint()</code>","text":"<p>Create logout handler for admin authentication.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler that terminates session and clears auth cookies.</p> Notes <ul> <li>Revokes access tokens</li> <li>Terminates active sessions</li> <li>Cleans up auth cookies</li> <li>Logs logout events if tracking enabled</li> </ul> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def logout_endpoint(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create logout handler for admin authentication.\n\n    Returns:\n        FastAPI route handler that terminates session and clears auth cookies.\n\n    Notes:\n        - Revokes access tokens\n        - Terminates active sessions\n        - Cleans up auth cookies\n        - Logs logout events if tracking enabled\n    \"\"\"\n\n    @log_auth_action(EventType.LOGOUT)\n    async def logout_endpoint_inner(\n        request: Request,\n        response: Response,\n        db: AsyncSession = Depends(self.db_config.get_admin_db),\n        session_id: Optional[str] = Cookie(None),\n        event_integration: Optional[Any] = Depends(lambda: self.event_integration),\n    ) -&gt; RouteResponse:\n        if session_id:\n            await self.session_manager.terminate_session(session_id=session_id)\n\n        response = RedirectResponse(\n            url=f\"/{self.mount_path}/login\", status_code=303\n        )\n\n        self.session_manager.clear_session_cookies(\n            response=response,\n            path=f\"/{self.mount_path}\",\n        )\n\n        return response\n\n    return cast(EndpointCallable, logout_endpoint_inner)\n</code></pre>"},{"location":"api/admin_site/#crudadmin.admin_interface.admin_site.AdminSite.setup_routes","title":"<code>setup_routes()</code>","text":"<p>Configure all admin interface routes including auth, dashboard and model views.</p> Routes Created <p>Auth Routes:     - POST /login - Handle login form submission     - GET /login - Display login page     - GET /logout - Process user logout</p> <p>Dashboard Routes:     - GET / - Main dashboard view     - GET /dashboard-content - HTMX dashboard updates</p> Notes <ul> <li>All routes except login require authentication</li> <li>Routes use Jinja2 templates for rendering</li> <li>HTMX integration for dynamic updates</li> <li>Event logging integration if enabled</li> </ul> Example <pre><code>admin_site = AdminSite(...)\nadmin_site.setup_routes()\napp.include_router(admin_site.router)\n</code></pre> Source code in <code>crudadmin/admin_interface/admin_site.py</code> <pre><code>def setup_routes(self) -&gt; None:\n    \"\"\"\n    Configure all admin interface routes including auth, dashboard and model views.\n\n    Routes Created:\n        **Auth Routes:**\n            - POST /login - Handle login form submission\n            - GET /login - Display login page\n            - GET /logout - Process user logout\n\n        **Dashboard Routes:**\n            - GET / - Main dashboard view\n            - GET /dashboard-content - HTMX dashboard updates\n\n    Notes:\n        - All routes except login require authentication\n        - Routes use Jinja2 templates for rendering\n        - HTMX integration for dynamic updates\n        - Event logging integration if enabled\n\n    Example:\n        ```python\n        admin_site = AdminSite(...)\n        admin_site.setup_routes()\n        app.include_router(admin_site.router)\n        ```\n    \"\"\"\n    self.router.add_api_route(\n        \"/login\",\n        self.login_page(),\n        methods=[\"POST\"],\n        include_in_schema=False,\n        response_model=None,\n    )\n    self.router.add_api_route(\n        \"/logout\",\n        self.logout_endpoint(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        response_model=None,\n    )\n    self.router.add_api_route(\n        \"/login\",\n        self.admin_login_page(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        response_model=None,\n    )\n    self.router.add_api_route(\n        \"/dashboard-content\",\n        self.dashboard_content(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        dependencies=[Depends(self.admin_authentication.get_current_user)],\n        response_model=None,\n    )\n    self.router.add_api_route(\n        \"/\",\n        self.dashboard_page(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        dependencies=[Depends(self.admin_authentication.get_current_user)],\n        response_model=None,\n    )\n</code></pre>"},{"location":"api/crud_admin/","title":"CRUDAdmin Class API Reference","text":""},{"location":"api/crud_admin/#class-definition","title":"Class Definition","text":"<p>FastAPI-based admin interface for managing database models and authentication.</p> Features <ul> <li>Selective CRUD for added models</li> <li>Event logging and audit trails</li> <li>Health monitoring and dashboard</li> <li>IP restriction and HTTPS enforcement</li> <li>Session management</li> <li>Token-based authentication</li> </ul> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>Async SQLAlchemy session for database operations</p> required <code>SECRET_KEY</code> <code>str</code> <p>Secret key for session management and cookie signing. Generate securely using: Python one-liner (recommended) python -c \"import secrets; print(secrets.token_urlsafe(32))\"</p> <p>OpenSSL openssl rand -base64 32</p> <p>/dev/urandom (Unix/Linux) head -c 32 /dev/urandom | base64</p> <p>The secret key must be: - At least 32 bytes (256 bits) long - Stored securely (e.g., in environment variables) - Different for each environment - Not committed to version control</p> required <code>mount_path</code> <code>Optional[str]</code> <p>URL path where admin interface is mounted, default \"/admin\"</p> <code>'/admin'</code> <code>theme</code> <code>Optional[str]</code> <p>UI theme ('dark-theme' or 'light-theme'), default \"dark-theme\"</p> <code>'dark-theme'</code> <code>admin_db_url</code> <code>Optional[str]</code> <p>SQLite/PostgreSQL database URL for admin data</p> <code>None</code> <code>admin_db_path</code> <code>Optional[str]</code> <p>File path for SQLite admin database</p> <code>None</code> <code>db_config</code> <code>Optional[DatabaseConfig]</code> <p>Optional pre-configured DatabaseConfig</p> <code>None</code> <code>setup_on_initialization</code> <code>bool</code> <p>Whether to run setup on init, default True</p> <code>True</code> <code>initial_admin</code> <code>Optional[Union[dict, BaseModel]]</code> <p>Initial admin user credentials</p> <code>None</code> <code>allowed_ips</code> <code>Optional[List[str]]</code> <p>List of allowed IP addresses</p> <code>None</code> <code>allowed_networks</code> <code>Optional[List[str]]</code> <p>List of allowed IP networks in CIDR notation</p> <code>None</code> <code>max_sessions_per_user</code> <code>int</code> <p>Limit concurrent sessions, default 5</p> <code>5</code> <code>session_timeout_minutes</code> <code>int</code> <p>Session inactivity timeout, default 30 minutes</p> <code>30</code> <code>cleanup_interval_minutes</code> <code>int</code> <p>How often to remove expired sessions, default 15 minutes</p> <code>15</code> <code>secure_cookies</code> <code>bool</code> <p>Enable secure cookie flag, default True</p> <code>True</code> <code>enforce_https</code> <code>bool</code> <p>Redirect HTTP to HTTPS, default False</p> <code>False</code> <code>https_port</code> <code>int</code> <p>HTTPS port for redirects, default 443</p> <code>443</code> <code>track_events</code> <code>bool</code> <p>Enable event logging, default False</p> <code>False</code> <code>track_sessions_in_db</code> <code>bool</code> <p>Enable session tracking in database, default False</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If mount_path is invalid or theme is unsupported</p> <code>ImportError</code> <p>If required dependencies are missing</p> <code>RuntimeError</code> <p>If database connection fails</p> Notes <ul> <li>Database Configuration uses SQLite by default in ./crudadmin_data/admin.db</li> <li>Database is auto-initialized unless setup_on_initialization=False</li> </ul> Example <p>Basic setup with SQLite: <pre><code>from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import declarative_base\nfrom sqlalchemy import Column, Integer, String\nimport os\n\n# Generate secret key\nSECRET_KEY = os.environ.get(\"ADMIN_SECRET_KEY\") or os.urandom(32).hex()\n\n# Define models\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    username = Column(String, unique=True)\n    email = Column(String)\n    role = Column(String)\n\n# Setup database\nengine = create_async_engine(\"sqlite+aiosqlite:///app.db\")\nsession = AsyncSession(engine)\n\n# Create admin interface\nadmin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=SECRET_KEY,\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"secure_pass123\"\n    }\n)\n</code></pre></p> <p>Production setup with security features: <pre><code>admin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=SECRET_KEY,\n    # Security features\n    allowed_ips=[\"10.0.0.1\", \"10.0.0.2\"],\n    allowed_networks=[\"192.168.1.0/24\"],\n    secure_cookies=True,\n    enforce_https=True,\n    # Custom PostgreSQL admin database\n    admin_db_url=\"postgresql+asyncpg://user:pass@localhost/admin\",\n    # Session configuration\n    max_sessions_per_user=3,\n    session_timeout_minutes=15,\n    # Enable audit logging\n    track_events=True\n)\n</code></pre></p> <p>Session management configuration: <pre><code>admin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=SECRET_KEY,\n    # Session management settings\n    max_sessions_per_user=5,\n    session_timeout_minutes=30,\n    cleanup_interval_minutes=15,\n    # Secure cookie settings\n    secure_cookies=True,\n    # Initial admin user\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"very_secure_password_123\",\n        \"is_superuser\": True\n    }\n)\n</code></pre></p> <p>Setup with multiple models and custom schemas: <pre><code>from pydantic import BaseModel, EmailStr\nfrom decimal import Decimal\nfrom datetime import datetime\n\n# Models\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Decimal)\n    created_at = Column(DateTime)\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    total = Column(Decimal)\n    status = Column(String)\n    order_date = Column(DateTime)\n\n# Schemas\nclass ProductCreate(BaseModel):\n    name: str\n    price: Decimal\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = None\n    price: Optional[Decimal] = None\n\nclass OrderCreate(BaseModel):\n    user_id: int\n    total: Decimal\n    status: str = \"pending\"\n    order_date: datetime = Field(default_factory=datetime.utcnow)\n\nclass OrderUpdate(BaseModel):\n    status: Optional[str] = None\n    total: Optional[Decimal] = None\n\n# Add views\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    update_internal_schema=None,\n    delete_schema=None,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No deletion\n)\n\nadmin.add_view(\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    update_internal_schema=None,\n    delete_schema=None,\n    allowed_actions={\"view\", \"update\"}  # View and update only\n)\n</code></pre></p> <p>Event tracking and audit logs: <pre><code>admin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=SECRET_KEY,\n    track_events=True,  # Enable event tracking\n    # Custom admin database for logs\n    admin_db_url=\"postgresql+asyncpg://user:pass@localhost/admin_logs\",\n)\n\n# Events tracked automatically:\n# - User logins/logouts\n# - Model creates/updates/deletes\n# - Failed authentication attempts\n# - System health status\n</code></pre></p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>class CRUDAdmin:\n    \"\"\"\n    FastAPI-based admin interface for managing database models and authentication.\n\n    Features:\n        - Selective CRUD for added models\n        - Event logging and audit trails\n        - Health monitoring and dashboard\n        - IP restriction and HTTPS enforcement\n        - Session management\n        - Token-based authentication\n\n    Args:\n        session: Async SQLAlchemy session for database operations\n        SECRET_KEY: Secret key for session management and cookie signing. Generate securely using:\n            **Python one-liner (recommended)**\n            python -c \"import secrets; print(secrets.token_urlsafe(32))\"\n\n            **OpenSSL**\n            openssl rand -base64 32\n\n            **/dev/urandom (Unix/Linux)**\n            head -c 32 /dev/urandom | base64\n\n            **The secret key must be:**\n            - At least 32 bytes (256 bits) long\n            - Stored securely (e.g., in environment variables)\n            - Different for each environment\n            - Not committed to version control\n\n        mount_path: URL path where admin interface is mounted, default \"/admin\"\n        theme: UI theme ('dark-theme' or 'light-theme'), default \"dark-theme\"\n        admin_db_url: SQLite/PostgreSQL database URL for admin data\n        admin_db_path: File path for SQLite admin database\n        db_config: Optional pre-configured DatabaseConfig\n        setup_on_initialization: Whether to run setup on init, default True\n        initial_admin: Initial admin user credentials\n        allowed_ips: List of allowed IP addresses\n        allowed_networks: List of allowed IP networks in CIDR notation\n        max_sessions_per_user: Limit concurrent sessions, default 5\n        session_timeout_minutes: Session inactivity timeout, default 30 minutes\n        cleanup_interval_minutes: How often to remove expired sessions, default 15 minutes\n        secure_cookies: Enable secure cookie flag, default True\n        enforce_https: Redirect HTTP to HTTPS, default False\n        https_port: HTTPS port for redirects, default 443\n        track_events: Enable event logging, default False\n        track_sessions_in_db: Enable session tracking in database, default False\n\n    Raises:\n        ValueError: If mount_path is invalid or theme is unsupported\n        ImportError: If required dependencies are missing\n        RuntimeError: If database connection fails\n\n    Notes:\n        - Database Configuration uses SQLite by default in ./crudadmin_data/admin.db\n        - Database is auto-initialized unless setup_on_initialization=False\n\n    Example:\n        Basic setup with SQLite:\n        ```python\n        from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n        from sqlalchemy.orm import declarative_base\n        from sqlalchemy import Column, Integer, String\n        import os\n\n        # Generate secret key\n        SECRET_KEY = os.environ.get(\"ADMIN_SECRET_KEY\") or os.urandom(32).hex()\n\n        # Define models\n        Base = declarative_base()\n\n        class User(Base):\n            __tablename__ = \"users\"\n            id = Column(Integer, primary_key=True)\n            username = Column(String, unique=True)\n            email = Column(String)\n            role = Column(String)\n\n        # Setup database\n        engine = create_async_engine(\"sqlite+aiosqlite:///app.db\")\n        session = AsyncSession(engine)\n\n        # Create admin interface\n        admin = CRUDAdmin(\n            session=session,\n            SECRET_KEY=SECRET_KEY,\n            initial_admin={\n                \"username\": \"admin\",\n                \"password\": \"secure_pass123\"\n            }\n        )\n        ```\n\n        Production setup with security features:\n        ```python\n        admin = CRUDAdmin(\n            session=session,\n            SECRET_KEY=SECRET_KEY,\n            # Security features\n            allowed_ips=[\"10.0.0.1\", \"10.0.0.2\"],\n            allowed_networks=[\"192.168.1.0/24\"],\n            secure_cookies=True,\n            enforce_https=True,\n            # Custom PostgreSQL admin database\n            admin_db_url=\"postgresql+asyncpg://user:pass@localhost/admin\",\n            # Session configuration\n            max_sessions_per_user=3,\n            session_timeout_minutes=15,\n            # Enable audit logging\n            track_events=True\n        )\n        ```\n\n        Session management configuration:\n        ```python\n        admin = CRUDAdmin(\n            session=session,\n            SECRET_KEY=SECRET_KEY,\n            # Session management settings\n            max_sessions_per_user=5,\n            session_timeout_minutes=30,\n            cleanup_interval_minutes=15,\n            # Secure cookie settings\n            secure_cookies=True,\n            # Initial admin user\n            initial_admin={\n                \"username\": \"admin\",\n                \"password\": \"very_secure_password_123\",\n                \"is_superuser\": True\n            }\n        )\n        ```\n\n        Setup with multiple models and custom schemas:\n        ```python\n        from pydantic import BaseModel, EmailStr\n        from decimal import Decimal\n        from datetime import datetime\n\n        # Models\n        class Product(Base):\n            __tablename__ = \"products\"\n            id = Column(Integer, primary_key=True)\n            name = Column(String)\n            price = Column(Decimal)\n            created_at = Column(DateTime)\n\n        class Order(Base):\n            __tablename__ = \"orders\"\n            id = Column(Integer, primary_key=True)\n            user_id = Column(Integer, ForeignKey(\"users.id\"))\n            total = Column(Decimal)\n            status = Column(String)\n            order_date = Column(DateTime)\n\n        # Schemas\n        class ProductCreate(BaseModel):\n            name: str\n            price: Decimal\n            created_at: datetime = Field(default_factory=datetime.utcnow)\n\n        class ProductUpdate(BaseModel):\n            name: Optional[str] = None\n            price: Optional[Decimal] = None\n\n        class OrderCreate(BaseModel):\n            user_id: int\n            total: Decimal\n            status: str = \"pending\"\n            order_date: datetime = Field(default_factory=datetime.utcnow)\n\n        class OrderUpdate(BaseModel):\n            status: Optional[str] = None\n            total: Optional[Decimal] = None\n\n        # Add views\n        admin.add_view(\n            model=Product,\n            create_schema=ProductCreate,\n            update_schema=ProductUpdate,\n            update_internal_schema=None,\n            delete_schema=None,\n            allowed_actions={\"view\", \"create\", \"update\"}  # No deletion\n        )\n\n        admin.add_view(\n            model=Order,\n            create_schema=OrderCreate,\n            update_schema=OrderUpdate,\n            update_internal_schema=None,\n            delete_schema=None,\n            allowed_actions={\"view\", \"update\"}  # View and update only\n        )\n        ```\n\n        Event tracking and audit logs:\n        ```python\n        admin = CRUDAdmin(\n            session=session,\n            SECRET_KEY=SECRET_KEY,\n            track_events=True,  # Enable event tracking\n            # Custom admin database for logs\n            admin_db_url=\"postgresql+asyncpg://user:pass@localhost/admin_logs\",\n        )\n\n        # Events tracked automatically:\n        # - User logins/logouts\n        # - Model creates/updates/deletes\n        # - Failed authentication attempts\n        # - System health status\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: AsyncSession,\n        SECRET_KEY: str,\n        mount_path: Optional[str] = \"/admin\",\n        theme: Optional[str] = \"dark-theme\",\n        admin_db_url: Optional[str] = None,\n        admin_db_path: Optional[str] = None,\n        db_config: Optional[DatabaseConfig] = None,\n        setup_on_initialization: bool = True,\n        initial_admin: Optional[Union[dict, BaseModel]] = None,\n        allowed_ips: Optional[List[str]] = None,\n        allowed_networks: Optional[List[str]] = None,\n        max_sessions_per_user: int = 5,\n        session_timeout_minutes: int = 30,\n        cleanup_interval_minutes: int = 15,\n        secure_cookies: bool = True,\n        enforce_https: bool = False,\n        https_port: int = 443,\n        track_events: bool = False,\n        track_sessions_in_db: bool = False,\n    ) -&gt; None:\n        self.mount_path = mount_path.strip(\"/\") if mount_path else \"admin\"\n        self.theme = theme or \"dark-theme\"\n        self.track_events = track_events\n        self.track_sessions_in_db = track_sessions_in_db\n\n        self.templates_directory = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), \"..\", \"templates\"\n        )\n\n        self.static_directory = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), \"..\", \"static\"\n        )\n\n        self.app = FastAPI()\n        self.app.mount(\n            \"/static\", StaticFiles(directory=self.static_directory), name=\"admin_static\"\n        )\n\n        self.app.add_middleware(AdminAuthMiddleware, admin_instance=self)\n\n        from ..event import create_admin_audit_log, create_admin_event_log\n\n        event_log_model: Optional[Type[DeclarativeBase]] = None\n        audit_log_model: Optional[Type[DeclarativeBase]] = None\n\n        if self.track_events:\n            event_log_model = cast(\n                Type[DeclarativeBase], create_admin_event_log(AdminBase)\n            )\n            audit_log_model = cast(\n                Type[DeclarativeBase], create_admin_audit_log(AdminBase)\n            )\n\n        self.db_config = db_config or DatabaseConfig(\n            base=AdminBase,\n            session=session,\n            admin_db_url=admin_db_url,\n            admin_db_path=admin_db_path,\n            admin_event_log=event_log_model,\n            admin_audit_log=audit_log_model,\n        )\n\n        if self.track_events:\n            from ..event import init_event_system\n\n            self.event_service, self.event_integration = init_event_system(\n                self.db_config\n            )\n        else:\n            self.event_service = None\n            self.event_integration = None\n\n        self.SECRET_KEY = SECRET_KEY\n\n        self.admin_user_service = AdminUserService(db_config=self.db_config)\n        self.initial_admin = initial_admin\n        self.models: Dict[str, ModelConfig] = {}\n        self.router = APIRouter(tags=[\"admin\"])\n        self.oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f\"/{self.mount_path}/login\")\n        self.secure_cookies = secure_cookies\n\n        session_backend = getattr(self, \"_session_backend\", \"memory\")\n        backend_kwargs = getattr(self, \"_session_backend_kwargs\", {})\n\n        if self.track_sessions_in_db:\n            if session_backend == \"redis\":\n                actual_backend = \"hybrid\"\n                backend_kwargs[\"db_config\"] = self.db_config\n            else:\n                actual_backend = \"database\"\n                backend_kwargs[\"db_config\"] = self.db_config\n        else:\n            actual_backend = session_backend\n\n        storage: AbstractSessionStorage[SessionData] = get_session_storage(\n            backend=actual_backend,\n            model_type=SessionData,\n            prefix=\"session:\",\n            expiration=session_timeout_minutes * 60,\n            **backend_kwargs,\n        )\n\n        self.session_manager = SessionManager(\n            session_storage=storage,\n            max_sessions_per_user=max_sessions_per_user,\n            session_timeout_minutes=session_timeout_minutes,\n            cleanup_interval_minutes=cleanup_interval_minutes,\n        )\n\n        self.admin_authentication = AdminAuthentication(\n            database_config=self.db_config,\n            user_service=self.admin_user_service,\n            session_manager=self.session_manager,\n            oauth2_scheme=self.oauth2_scheme,\n            event_integration=self.event_integration,\n        )\n\n        self.templates = Jinja2Templates(directory=self.templates_directory)\n\n        if setup_on_initialization:\n            self.setup()\n\n        if allowed_ips or allowed_networks:\n            self.app.add_middleware(\n                IPRestrictionMiddleware,\n                allowed_ips=allowed_ips,\n                allowed_networks=allowed_networks,\n            )\n\n        if enforce_https:\n            from .middleware.https import HTTPSRedirectMiddleware\n\n            self.app.add_middleware(HTTPSRedirectMiddleware, https_port=https_port)\n\n        self.app.include_router(self.router)\n\n    async def initialize(self) -&gt; None:\n        \"\"\"\n        Initialize admin database tables and create initial admin user.\n\n        Creates required tables:\n        - AdminUser for user management\n        - AdminSession for session tracking\n        - AdminEventLog and AdminAuditLog if event tracking enabled\n\n        Also creates initial admin user if credentials were provided.\n\n        Raises:\n            AssertionError: If event log models are misconfigured\n            ValueError: If database initialization fails\n\n        Notes:\n            - This is called automatically if setup_on_initialization=True\n            - Tables are created with 'checkfirst' to avoid conflicts\n            - Initial admin is only created if no admin exists\n\n        Example:\n            Manual initialization:\n            ```python\n            admin = CRUDAdmin(\n                session=async_session,\n                SECRET_KEY=\"key\",\n                setup_on_initialization=False\n            )\n            await admin.initialize()\n            ```\n        \"\"\"\n        await self.db_config.initialize_admin_db()\n\n        if self.initial_admin:\n            await self._create_initial_admin(self.initial_admin)\n\n    def setup_event_routes(self) -&gt; None:\n        \"\"\"\n        Set up routes for event log management.\n\n        Creates endpoints:\n        - GET /management/events - Event log page\n        - GET /management/events/content - Event log data\n\n        Notes:\n            - Only created if track_events=True\n            - Routes require authentication\n        \"\"\"\n        if self.track_events:\n            self.router.add_api_route(\n                \"/management/events\",\n                self.event_log_page(),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                dependencies=[Depends(self.admin_authentication.get_current_user())],\n                response_model=None,\n            )\n            self.router.add_api_route(\n                \"/management/events/content\",\n                self.event_log_content(),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                dependencies=[Depends(self.admin_authentication.get_current_user())],\n                response_model=None,\n            )\n\n    def event_log_page(\n        self,\n    ) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n        \"\"\"\n        Create endpoint for event log main page.\n\n        Returns:\n            FastAPI route handler that renders event log template\n            with filtering options\n        \"\"\"\n\n        admin_db_db_dependency = cast(\n            Callable[..., AsyncSession], self.db_config.get_admin_db\n        )\n        app_db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n        async def event_log_page_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(admin_db_db_dependency),\n            app_db: AsyncSession = Depends(app_db_dependency),\n        ) -&gt; RouteResponse:\n            from ..event import EventStatus, EventType\n\n            users = await self.db_config.crud_users.get_multi(db=admin_db)\n\n            context = await self.admin_site.get_base_context(\n                admin_db=admin_db, app_db=app_db\n            )\n            context.update(\n                {\n                    \"request\": request,\n                    \"include_sidebar_and_header\": True,\n                    \"event_types\": [e.value for e in EventType],\n                    \"statuses\": [s.value for s in EventStatus],\n                    \"users\": users[\"data\"],\n                    \"mount_path\": self.mount_path,\n                }\n            )\n\n            return self.templates.TemplateResponse(\n                \"admin/management/events.html\", context\n            )\n\n        return event_log_page_inner\n\n    def event_log_content(self) -&gt; EndpointFunction:\n        \"\"\"\n        Create endpoint for event log data with filtering and pagination.\n\n        Returns:\n            FastAPI route handler that provides filtered event data\n            with user and audit details\n\n        Notes:\n            - Supports filtering by:\n            - Event type\n            - Status\n            - Username\n            - Date range\n            - Returns enriched events with:\n            - Username\n            - Resource details\n            - Audit trail data\n            - Includes pagination metadata\n\n        Examples:\n            Filter events:\n            GET /management/events/content?event_type=create&amp;status=success\n\n            Filter by date:\n            GET /management/events/content?start_date=2024-01-01&amp;end_date=2024-01-31\n        \"\"\"\n\n        admin_db_db_dependency = cast(\n            Callable[..., AsyncSession], self.db_config.get_admin_db\n        )\n\n        async def event_log_content_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(admin_db_db_dependency),\n            page: int = 1,\n            limit: int = 10,\n        ) -&gt; RouteResponse:\n            try:\n                if not self.db_config.AdminEventLog:\n                    raise ValueError(\"AdminEventLog is not configured\")\n\n                crud_events: FastCRUD = FastCRUD(self.db_config.AdminEventLog)\n\n                event_type = cast(Optional[str], request.query_params.get(\"event_type\"))\n                status = cast(Optional[str], request.query_params.get(\"status\"))\n                username = cast(Optional[str], request.query_params.get(\"username\"))\n                start_date = cast(Optional[str], request.query_params.get(\"start_date\"))\n                end_date = cast(Optional[str], request.query_params.get(\"end_date\"))\n\n                filter_criteria: Dict[str, Any] = {}\n                if event_type:\n                    filter_criteria[\"event_type\"] = event_type\n                if status:\n                    filter_criteria[\"status\"] = status\n\n                if username:\n                    user = await self.db_config.crud_users.get(\n                        db=admin_db, username=username\n                    )\n                    if user and isinstance(user, dict):\n                        filter_criteria[\"user_id\"] = user.get(\"id\")\n\n                if start_date:\n                    start = datetime.strptime(start_date, \"%Y-%m-%d\").replace(\n                        tzinfo=UTC\n                    )\n                    filter_criteria[\"timestamp__gte\"] = start\n\n                if end_date:\n                    end = (\n                        datetime.strptime(end_date, \"%Y-%m-%d\") + timedelta(days=1)\n                    ).replace(tzinfo=UTC)\n                    filter_criteria[\"timestamp__lt\"] = end\n\n                events = await crud_events.get_multi(\n                    db=admin_db,\n                    offset=(page - 1) * limit,\n                    limit=limit,\n                    sort_columns=[\"timestamp\"],\n                    sort_orders=[\"desc\"],\n                    **filter_criteria,\n                )\n\n                enriched_events = []\n                if isinstance(events[\"data\"], list):\n                    for event in events[\"data\"]:\n                        if isinstance(event, dict):\n                            event_data = dict(event)\n                            user = await self.db_config.crud_users.get(\n                                db=admin_db, id=event.get(\"user_id\")\n                            )\n                            if isinstance(user, dict):\n                                event_data[\"username\"] = user.get(\"username\", \"Unknown\")\n\n                            if event.get(\"resource_type\") and event.get(\"resource_id\"):\n                                if not self.db_config.AdminAuditLog:\n                                    raise ValueError(\"AdminAuditLog is not configured\")\n\n                                crud_audits: FastCRUD = FastCRUD(\n                                    self.db_config.AdminAuditLog\n                                )\n                                audit = await crud_audits.get(\n                                    db=admin_db, event_id=event.get(\"id\")\n                                )\n                                if audit and isinstance(audit, dict):\n                                    event_data[\"details\"] = {\n                                        \"resource_details\": {\n                                            \"model\": event.get(\"resource_type\"),\n                                            \"id\": event.get(\"resource_id\"),\n                                            \"changes\": audit.get(\"new_state\"),\n                                        }\n                                    }\n\n                            enriched_events.append(event_data)\n\n                total_items = events.get(\"total_count\", 0)\n                assert isinstance(total_items, int), (\n                    f\"'total_count' should be int, got {type(total_items)}\"\n                )\n\n                total_pages = max(1, (total_items + limit - 1) // limit)\n\n                return self.templates.TemplateResponse(\n                    \"admin/management/events_content.html\",\n                    {\n                        \"request\": request,\n                        \"events\": enriched_events,\n                        \"page\": page,\n                        \"total_pages\": total_pages,\n                        \"mount_path\": self.mount_path,\n                        \"start_date\": start_date,\n                        \"end_date\": end_date,\n                        \"selected_type\": event_type,\n                        \"selected_status\": status,\n                        \"selected_user\": username,\n                    },\n                )\n\n            except Exception as e:\n                logger.error(f\"Error retrieving events: {str(e)}\")\n                return self.templates.TemplateResponse(\n                    \"admin/management/events_content.html\",\n                    {\n                        \"request\": request,\n                        \"events\": [],\n                        \"page\": 1,\n                        \"total_pages\": 1,\n                        \"mount_path\": self.mount_path,\n                    },\n                )\n\n        return event_log_content_inner\n\n    def setup(\n        self,\n    ) -&gt; None:\n        \"\"\"\n        Set up admin interface routes and views.\n\n        Configures:\n        - Authentication routes and middleware\n        - Model CRUD views\n        - Management views (health check, events)\n        - Static files\n\n        Notes:\n            - Called automatically if setup_on_initialization=True\n            - Can be called manually after initialization\n            - Respects allowed_actions configuration\n        \"\"\"\n        self.admin_site = AdminSite(\n            database_config=self.db_config,\n            templates_directory=self.templates_directory,\n            models=self.models,\n            admin_authentication=self.admin_authentication,\n            mount_path=self.mount_path,\n            theme=self.theme,\n            secure_cookies=self.secure_cookies,\n            event_integration=self.event_integration if self.track_events else None,\n            session_manager=self.session_manager,\n        )\n\n        self.admin_site.setup_routes()\n\n        for model_name, data in self.admin_authentication.auth_models.items():\n            allowed_actions = {\n                \"AdminUser\": {\"view\", \"create\", \"update\"},\n                \"AdminSession\": {\"view\", \"delete\"},\n            }.get(model_name, {\"view\"})\n\n            model = cast(Type[DeclarativeBase], data[\"model\"])\n            create_schema = cast(Type[BaseModel], data[\"create_schema\"])\n            update_schema = cast(Type[BaseModel], data[\"update_schema\"])\n            update_internal_schema = cast(\n                Optional[Type[BaseModel]], data[\"update_internal_schema\"]\n            )\n            delete_schema = cast(Optional[Type[BaseModel]], data[\"delete_schema\"])\n\n            self.add_view(\n                model=model,\n                create_schema=create_schema,\n                update_schema=update_schema,\n                update_internal_schema=update_internal_schema,\n                delete_schema=delete_schema,\n                include_in_models=False,\n                allowed_actions=allowed_actions,\n            )\n\n        get_user_dependency = cast(\n            Callable[..., AsyncSession], self.admin_authentication.get_current_user\n        )\n\n        self.router.add_api_route(\n            \"/management/health\",\n            self.health_check_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(get_user_dependency)],\n            response_model=None,\n        )\n\n        self.router.add_api_route(\n            \"/management/health/content\",\n            self.health_check_content(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(get_user_dependency)],\n            response_model=None,\n        )\n\n        if self.track_events:\n            self.router.add_api_route(\n                \"/management/events\",\n                self.event_log_page(),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                dependencies=[Depends(get_user_dependency)],\n                response_model=None,\n            )\n            self.router.add_api_route(\n                \"/management/events/content\",\n                self.event_log_content(),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                dependencies=[Depends(get_user_dependency)],\n                response_model=None,\n            )\n\n        self.router.include_router(router=self.admin_site.router)\n\n    def add_view(\n        self,\n        model: Type[DeclarativeBase],\n        create_schema: Type[BaseModel],\n        update_schema: Type[BaseModel],\n        update_internal_schema: Optional[Type[BaseModel]],\n        delete_schema: Optional[Type[BaseModel]],\n        include_in_models: bool = True,\n        allowed_actions: Optional[set[str]] = None,\n        password_transformer: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Add CRUD view for a database model.\n\n        Creates a web interface for managing model instances with forms generated\n        from Pydantic schemas.\n\n        Args:\n            model: SQLAlchemy model class to manage\n            create_schema: Pydantic schema for create operations\n            update_schema: Pydantic schema for update operations\n            update_internal_schema: Internal schema for special update cases\n            delete_schema: Schema for delete operations\n            include_in_models: Show in models list in admin UI\n            allowed_actions: **Set of allowed operations:**\n                - **\"view\"**: Allow viewing records\n                - **\"create\"**: Allow creating new records\n                - **\"update\"**: Allow updating existing records\n                - **\"delete\"**: Allow deleting records\n                Defaults to all actions if None\n            password_transformer: PasswordTransformer instance for handling password field transformation\n\n        Raises:\n            ValueError: If schemas don't match model structure\n            TypeError: If model is not a SQLAlchemy model\n\n        Notes:\n            - Forms are auto-generated with field types determined from Pydantic schemas\n            - Actions controlled by allowed_actions parameter\n            - Use password_transformer for models with password fields that need hashing\n\n            URL Routes:\n            - List view: /admin/&lt;model_name&gt;/\n            - Create: /admin/&lt;model_name&gt;/create\n            - Update: /admin/&lt;model_name&gt;/update/&lt;id&gt;\n            - Delete: /admin/&lt;model_name&gt;/delete/&lt;id&gt;\n\n        Example:\n            Basic user management:\n            ```python\n            from pydantic import BaseModel, EmailStr, Field\n            from typing import Optional\n            from datetime import datetime\n\n            class UserCreate(BaseModel):\n                username: str = Field(..., min_length=3, max_length=50)\n                email: EmailStr\n                role: str = Field(default=\"user\")\n                active: bool = Field(default=True)\n                join_date: datetime = Field(default_factory=datetime.utcnow)\n\n            class UserUpdate(BaseModel):\n                email: Optional[EmailStr] = None\n                role: Optional[str] = None\n                active: Optional[bool] = None\n\n            admin.add_view(\n                model=User,\n                create_schema=UserCreate,\n                update_schema=UserUpdate,\n                update_internal_schema=None,\n                delete_schema=None,\n                allowed_actions={\"view\", \"create\", \"update\"}  # No deletion\n            )\n            ```\n\n            User with password handling:\n            ```python\n            from crudadmin.admin_interface.model_view import PasswordTransformer\n            import bcrypt\n\n            def hash_password(password: str) -&gt; str:\n                return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\n            class UserCreateWithPassword(BaseModel):\n                username: str\n                email: EmailStr\n                password: str  # This will be transformed to hashed_password\n\n            transformer = PasswordTransformer(\n                password_field=\"password\",\n                hashed_field=\"hashed_password\",\n                hash_function=hash_password,\n                required_fields=[\"username\", \"email\"]\n            )\n\n            admin.add_view(\n                model=User,\n                create_schema=UserCreateWithPassword,\n                update_schema=UserUpdate,\n                update_internal_schema=None,\n                delete_schema=None,\n                password_transformer=transformer\n            )\n            ```\n\n            Product catalog with custom validation:\n            ```python\n            from decimal import Decimal\n            from pydantic import Field, validator\n\n            class ProductCreate(BaseModel):\n                name: str = Field(..., min_length=2, max_length=100)\n                price: Decimal = Field(..., ge=0)\n                description: Optional[str] = Field(None, max_length=500)\n                category: str\n                in_stock: bool = True\n\n                @validator(\"price\")\n                def validate_price(cls, v):\n                    if v &gt; 1000000:\n                        raise ValueError(\"Price cannot exceed 1,000,000\")\n                    return v\n\n            class ProductUpdate(BaseModel):\n                name: Optional[str] = Field(None, min_length=2, max_length=100)\n                price: Optional[Decimal] = Field(None, ge=0)\n                description: Optional[str] = None\n                in_stock: Optional[bool] = None\n\n            admin.add_view(\n                model=Product,\n                create_schema=ProductCreate,\n                update_schema=ProductUpdate,\n                update_internal_schema=None,\n                delete_schema=None,\n                allowed_actions={\"view\", \"create\", \"update\"}\n            )\n            ```\n\n            Order management with enum and relationships:\n            ```python\n            from enum import Enum\n            from typing import List\n\n            class OrderStatus(str, Enum):\n                pending = \"pending\"\n                paid = \"paid\"\n                shipped = \"shipped\"\n                delivered = \"delivered\"\n                cancelled = \"cancelled\"\n\n            class OrderCreate(BaseModel):\n                user_id: int = Field(..., gt=0)\n                items: List[int] = Field(..., min_items=1)\n                shipping_address: str\n                status: OrderStatus = Field(default=OrderStatus.pending)\n                notes: Optional[str] = None\n\n                class Config:\n                    json_schema_extra = {\n                        \"example\": {\n                            \"user_id\": 1,\n                            \"items\": [1, 2, 3],\n                            \"shipping_address\": \"123 Main St\",\n                            \"status\": \"pending\"\n                        }\n                    }\n\n            class OrderUpdate(BaseModel):\n                status: Optional[OrderStatus] = None\n                notes: Optional[str] = None\n\n            # Custom delete schema with soft delete\n            class OrderDelete(BaseModel):\n                archive: bool = Field(default=False, description=\"Archive instead of delete\")\n                reason: Optional[str] = Field(None, max_length=200)\n\n            admin.add_view(\n                model=Order,\n                create_schema=OrderCreate,\n                update_schema=OrderUpdate,\n                update_internal_schema=None,\n                delete_schema=OrderDelete,\n                allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n            )\n            ```\n\n            Read-only audit log:\n            ```python\n            class AuditLogSchema(BaseModel):\n                id: int\n                timestamp: datetime\n                user_id: int\n                action: str\n                details: dict\n\n                class Config:\n                    orm_mode = True\n\n            admin.add_view(\n                model=AuditLog,\n                create_schema=AuditLogSchema,\n                update_schema=AuditLogSchema,\n                update_internal_schema=None,\n                delete_schema=None,\n                allowed_actions={\"view\"},  # Read-only\n                include_in_models=False  # Hide from nav\n            )\n            ```\n        \"\"\"\n        model_key = model.__name__\n        if include_in_models:\n            self.models[model_key] = {\n                \"model\": model,\n                \"create_schema\": create_schema,\n                \"update_schema\": update_schema,\n                \"update_internal_schema\": update_internal_schema,\n                \"delete_schema\": delete_schema,\n                \"crud\": FastCRUD(model),\n            }\n\n        allowed_actions = allowed_actions or {\"view\", \"create\", \"update\", \"delete\"}\n\n        admin_view = ModelView(\n            database_config=self.db_config,\n            templates=self.templates,\n            model=model,\n            create_schema=create_schema,\n            update_schema=update_schema,\n            update_internal_schema=update_internal_schema,\n            delete_schema=delete_schema,\n            admin_site=self.admin_site,\n            allowed_actions=allowed_actions,\n            event_integration=self.event_integration,\n            password_transformer=password_transformer,\n        )\n\n        if self.track_events and self.event_integration:\n            admin_view.event_integration = self.event_integration\n\n        current_user_dep = cast(\n            Callable[..., Any], self.admin_site.admin_authentication.get_current_user\n        )\n        self.app.include_router(\n            admin_view.router,\n            prefix=f\"/{model_key}\",\n            dependencies=[Depends(current_user_dep)],\n            include_in_schema=False,\n        )\n\n    def health_check_page(\n        self,\n    ) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n        \"\"\"\n        Create endpoint for system health check page.\n\n        Returns:\n            FastAPI route handler that renders health check template\n        \"\"\"\n\n        admin_db_db_dependency = cast(\n            Callable[..., AsyncSession], self.db_config.get_admin_db\n        )\n        app_db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n        async def health_check_page_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(admin_db_db_dependency),\n            app_db: AsyncSession = Depends(app_db_dependency),\n        ) -&gt; RouteResponse:\n            context = await self.admin_site.get_base_context(\n                admin_db=admin_db, app_db=app_db\n            )\n            context.update({\"request\": request, \"include_sidebar_and_header\": True})\n\n            return self.templates.TemplateResponse(\n                \"admin/management/health.html\", context\n            )\n\n        return health_check_page_inner\n\n    def health_check_content(\n        self,\n    ) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n        \"\"\"\n        Create endpoint for health check data.\n\n        Returns:\n            FastAPI route handler that checks:\n            - Database connectivity\n            - Session management\n            - Token service\n        \"\"\"\n\n        db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n        async def health_check_content_inner(\n            request: Request, db: AsyncSession = Depends(db_dependency)\n        ) -&gt; RouteResponse:\n            health_checks = {}\n\n            start_time = time.time()\n            try:\n                await db.execute(text(\"SELECT 1\"))\n                latency = (time.time() - start_time) * 1000\n                health_checks[\"database\"] = {\n                    \"status\": \"healthy\",\n                    \"message\": \"Connected successfully\",\n                    \"latency\": latency,\n                }\n            except Exception as e:\n                health_checks[\"database\"] = {\"status\": \"unhealthy\", \"message\": str(e)}\n\n            try:\n                await self.session_manager.cleanup_expired_sessions()\n                health_checks[\"session_management\"] = {\n                    \"status\": \"healthy\",\n                    \"message\": \"Session cleanup working\",\n                }\n            except Exception as e:\n                health_checks[\"session_management\"] = {\n                    \"status\": \"unhealthy\",\n                    \"message\": str(e),\n                }\n\n            context = {\n                \"request\": request,\n                \"health_checks\": health_checks,\n                \"last_checked\": datetime.now(UTC),\n            }\n\n            return self.templates.TemplateResponse(\n                \"admin/management/health_content.html\", context\n            )\n\n        return health_check_content_inner\n\n    async def _create_initial_admin(self, admin_data: Union[dict, BaseModel]) -&gt; None:\n        \"\"\"\n        Create initial admin user if none exists.\n\n        Args:\n            admin_data: Admin credentials as dict or Pydantic model\n\n        Raises:\n            ValueError: If admin_data has invalid format\n            Exception: If database operations fail\n\n        Notes:\n            - Only creates admin if no users exist\n            - Handles both dict and Pydantic model input\n            - Password is hashed before storage\n        \"\"\"\n        async for admin_session in self.db_config.get_admin_db():\n            try:\n                admins_count = await self.db_config.crud_users.count(admin_session)\n\n                if admins_count &lt; 1:\n                    if isinstance(admin_data, dict):\n                        create_data = AdminUserCreate(**admin_data)\n                    elif isinstance(admin_data, BaseModel):\n                        if isinstance(admin_data, AdminUserCreate):\n                            create_data = admin_data\n                        else:\n                            create_data = AdminUserCreate(**admin_data.dict())\n                    else:\n                        msg = (\n                            \"Initial admin data must be either a dict or Pydantic model\"\n                        )\n                        logger.error(msg)\n                        raise ValueError(msg)\n\n                    hashed_password = self.admin_user_service.get_password_hash(\n                        create_data.password\n                    )\n                    internal_data = AdminUserCreateInternal(\n                        username=create_data.username,\n                        hashed_password=hashed_password,\n                    )\n\n                    await self.db_config.crud_users.create(\n                        admin_session, object=cast(Any, internal_data)\n                    )\n                    await admin_session.commit()\n                    logger.info(\n                        \"Created initial admin user - username: %s\",\n                        create_data.username,\n                    )\n\n            except Exception as e:\n                logger.error(\n                    \"Error creating initial admin user: %s\", str(e), exc_info=True\n                )\n                raise\n\n    def use_redis_sessions(\n        self, redis_url: str = \"redis://localhost:6379\", **kwargs: Any\n    ) -&gt; \"CRUDAdmin\":\n        \"\"\"Configure Redis session backend.\n\n        Args:\n            redis_url: Redis connection URL\n            **kwargs: Additional Redis configuration options\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._session_backend = \"redis\"\n        self._session_backend_kwargs = {\"redis_url\": redis_url, **kwargs}\n        return self\n\n    def use_memcached_sessions(\n        self, servers: Optional[List[str]] = None, **kwargs: Any\n    ) -&gt; \"CRUDAdmin\":\n        \"\"\"Configure Memcached session backend.\n\n        Args:\n            servers: List of memcached server addresses\n            **kwargs: Additional Memcached configuration options\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        if servers is None:\n            servers = [\"localhost:11211\"]\n        self._session_backend = \"memcached\"\n        self._session_backend_kwargs = {\"servers\": servers, **kwargs}\n        return self\n\n    def use_memory_sessions(self, **kwargs: Any) -&gt; \"CRUDAdmin\":\n        \"\"\"Configure in-memory session backend.\n\n        Args:\n            **kwargs: Additional memory storage configuration options\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._session_backend = \"memory\"\n        self._session_backend_kwargs = kwargs\n        return self\n\n    def use_database_sessions(self, **kwargs: Any) -&gt; \"CRUDAdmin\":\n        \"\"\"Configure database session backend.\n\n        This enables session storage in the AdminSession table for full\n        admin dashboard visibility.\n\n        Args:\n            **kwargs: Additional database storage configuration options\n\n        Returns:\n            Self for method chaining\n        \"\"\"\n        self._session_backend = \"database\"\n        self._session_backend_kwargs = kwargs\n        self.track_sessions_in_db = True\n        return self\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.add_view","title":"<code>add_view(model, create_schema, update_schema, update_internal_schema, delete_schema, include_in_models=True, allowed_actions=None, password_transformer=None)</code>","text":"<p>Add CRUD view for a database model.</p> <p>Creates a web interface for managing model instances with forms generated from Pydantic schemas.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[DeclarativeBase]</code> <p>SQLAlchemy model class to manage</p> required <code>create_schema</code> <code>Type[BaseModel]</code> <p>Pydantic schema for create operations</p> required <code>update_schema</code> <code>Type[BaseModel]</code> <p>Pydantic schema for update operations</p> required <code>update_internal_schema</code> <code>Optional[Type[BaseModel]]</code> <p>Internal schema for special update cases</p> required <code>delete_schema</code> <code>Optional[Type[BaseModel]]</code> <p>Schema for delete operations</p> required <code>include_in_models</code> <code>bool</code> <p>Show in models list in admin UI</p> <code>True</code> <code>allowed_actions</code> <code>Optional[set[str]]</code> <p>Set of allowed operations: - \"view\": Allow viewing records - \"create\": Allow creating new records - \"update\": Allow updating existing records - \"delete\": Allow deleting records Defaults to all actions if None</p> <code>None</code> <code>password_transformer</code> <code>Optional[Any]</code> <p>PasswordTransformer instance for handling password field transformation</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schemas don't match model structure</p> <code>TypeError</code> <p>If model is not a SQLAlchemy model</p> Notes <ul> <li>Forms are auto-generated with field types determined from Pydantic schemas</li> <li>Actions controlled by allowed_actions parameter</li> <li>Use password_transformer for models with password fields that need hashing</li> </ul> <p>URL Routes: - List view: /admin// - Create: /admin//create - Update: /admin//update/ - Delete: /admin//delete/ Example <p>Basic user management: <pre><code>from pydantic import BaseModel, EmailStr, Field\nfrom typing import Optional\nfrom datetime import datetime\n\nclass UserCreate(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    role: str = Field(default=\"user\")\n    active: bool = Field(default=True)\n    join_date: datetime = Field(default_factory=datetime.utcnow)\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    role: Optional[str] = None\n    active: Optional[bool] = None\n\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    update_internal_schema=None,\n    delete_schema=None,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No deletion\n)\n</code></pre></p> <p>User with password handling: <pre><code>from crudadmin.admin_interface.model_view import PasswordTransformer\nimport bcrypt\n\ndef hash_password(password: str) -&gt; str:\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\nclass UserCreateWithPassword(BaseModel):\n    username: str\n    email: EmailStr\n    password: str  # This will be transformed to hashed_password\n\ntransformer = PasswordTransformer(\n    password_field=\"password\",\n    hashed_field=\"hashed_password\",\n    hash_function=hash_password,\n    required_fields=[\"username\", \"email\"]\n)\n\nadmin.add_view(\n    model=User,\n    create_schema=UserCreateWithPassword,\n    update_schema=UserUpdate,\n    update_internal_schema=None,\n    delete_schema=None,\n    password_transformer=transformer\n)\n</code></pre></p> <p>Product catalog with custom validation: <pre><code>from decimal import Decimal\nfrom pydantic import Field, validator\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=2, max_length=100)\n    price: Decimal = Field(..., ge=0)\n    description: Optional[str] = Field(None, max_length=500)\n    category: str\n    in_stock: bool = True\n\n    @validator(\"price\")\n    def validate_price(cls, v):\n        if v &gt; 1000000:\n            raise ValueError(\"Price cannot exceed 1,000,000\")\n        return v\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = Field(None, min_length=2, max_length=100)\n    price: Optional[Decimal] = Field(None, ge=0)\n    description: Optional[str] = None\n    in_stock: Optional[bool] = None\n\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    update_internal_schema=None,\n    delete_schema=None,\n    allowed_actions={\"view\", \"create\", \"update\"}\n)\n</code></pre></p> <p>Order management with enum and relationships: <pre><code>from enum import Enum\nfrom typing import List\n\nclass OrderStatus(str, Enum):\n    pending = \"pending\"\n    paid = \"paid\"\n    shipped = \"shipped\"\n    delivered = \"delivered\"\n    cancelled = \"cancelled\"\n\nclass OrderCreate(BaseModel):\n    user_id: int = Field(..., gt=0)\n    items: List[int] = Field(..., min_items=1)\n    shipping_address: str\n    status: OrderStatus = Field(default=OrderStatus.pending)\n    notes: Optional[str] = None\n\n    class Config:\n        json_schema_extra = {\n            \"example\": {\n                \"user_id\": 1,\n                \"items\": [1, 2, 3],\n                \"shipping_address\": \"123 Main St\",\n                \"status\": \"pending\"\n            }\n        }\n\nclass OrderUpdate(BaseModel):\n    status: Optional[OrderStatus] = None\n    notes: Optional[str] = None\n\n# Custom delete schema with soft delete\nclass OrderDelete(BaseModel):\n    archive: bool = Field(default=False, description=\"Archive instead of delete\")\n    reason: Optional[str] = Field(None, max_length=200)\n\nadmin.add_view(\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    update_internal_schema=None,\n    delete_schema=OrderDelete,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre></p> <p>Read-only audit log: <pre><code>class AuditLogSchema(BaseModel):\n    id: int\n    timestamp: datetime\n    user_id: int\n    action: str\n    details: dict\n\n    class Config:\n        orm_mode = True\n\nadmin.add_view(\n    model=AuditLog,\n    create_schema=AuditLogSchema,\n    update_schema=AuditLogSchema,\n    update_internal_schema=None,\n    delete_schema=None,\n    allowed_actions={\"view\"},  # Read-only\n    include_in_models=False  # Hide from nav\n)\n</code></pre></p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def add_view(\n    self,\n    model: Type[DeclarativeBase],\n    create_schema: Type[BaseModel],\n    update_schema: Type[BaseModel],\n    update_internal_schema: Optional[Type[BaseModel]],\n    delete_schema: Optional[Type[BaseModel]],\n    include_in_models: bool = True,\n    allowed_actions: Optional[set[str]] = None,\n    password_transformer: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"\n    Add CRUD view for a database model.\n\n    Creates a web interface for managing model instances with forms generated\n    from Pydantic schemas.\n\n    Args:\n        model: SQLAlchemy model class to manage\n        create_schema: Pydantic schema for create operations\n        update_schema: Pydantic schema for update operations\n        update_internal_schema: Internal schema for special update cases\n        delete_schema: Schema for delete operations\n        include_in_models: Show in models list in admin UI\n        allowed_actions: **Set of allowed operations:**\n            - **\"view\"**: Allow viewing records\n            - **\"create\"**: Allow creating new records\n            - **\"update\"**: Allow updating existing records\n            - **\"delete\"**: Allow deleting records\n            Defaults to all actions if None\n        password_transformer: PasswordTransformer instance for handling password field transformation\n\n    Raises:\n        ValueError: If schemas don't match model structure\n        TypeError: If model is not a SQLAlchemy model\n\n    Notes:\n        - Forms are auto-generated with field types determined from Pydantic schemas\n        - Actions controlled by allowed_actions parameter\n        - Use password_transformer for models with password fields that need hashing\n\n        URL Routes:\n        - List view: /admin/&lt;model_name&gt;/\n        - Create: /admin/&lt;model_name&gt;/create\n        - Update: /admin/&lt;model_name&gt;/update/&lt;id&gt;\n        - Delete: /admin/&lt;model_name&gt;/delete/&lt;id&gt;\n\n    Example:\n        Basic user management:\n        ```python\n        from pydantic import BaseModel, EmailStr, Field\n        from typing import Optional\n        from datetime import datetime\n\n        class UserCreate(BaseModel):\n            username: str = Field(..., min_length=3, max_length=50)\n            email: EmailStr\n            role: str = Field(default=\"user\")\n            active: bool = Field(default=True)\n            join_date: datetime = Field(default_factory=datetime.utcnow)\n\n        class UserUpdate(BaseModel):\n            email: Optional[EmailStr] = None\n            role: Optional[str] = None\n            active: Optional[bool] = None\n\n        admin.add_view(\n            model=User,\n            create_schema=UserCreate,\n            update_schema=UserUpdate,\n            update_internal_schema=None,\n            delete_schema=None,\n            allowed_actions={\"view\", \"create\", \"update\"}  # No deletion\n        )\n        ```\n\n        User with password handling:\n        ```python\n        from crudadmin.admin_interface.model_view import PasswordTransformer\n        import bcrypt\n\n        def hash_password(password: str) -&gt; str:\n            return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\n        class UserCreateWithPassword(BaseModel):\n            username: str\n            email: EmailStr\n            password: str  # This will be transformed to hashed_password\n\n        transformer = PasswordTransformer(\n            password_field=\"password\",\n            hashed_field=\"hashed_password\",\n            hash_function=hash_password,\n            required_fields=[\"username\", \"email\"]\n        )\n\n        admin.add_view(\n            model=User,\n            create_schema=UserCreateWithPassword,\n            update_schema=UserUpdate,\n            update_internal_schema=None,\n            delete_schema=None,\n            password_transformer=transformer\n        )\n        ```\n\n        Product catalog with custom validation:\n        ```python\n        from decimal import Decimal\n        from pydantic import Field, validator\n\n        class ProductCreate(BaseModel):\n            name: str = Field(..., min_length=2, max_length=100)\n            price: Decimal = Field(..., ge=0)\n            description: Optional[str] = Field(None, max_length=500)\n            category: str\n            in_stock: bool = True\n\n            @validator(\"price\")\n            def validate_price(cls, v):\n                if v &gt; 1000000:\n                    raise ValueError(\"Price cannot exceed 1,000,000\")\n                return v\n\n        class ProductUpdate(BaseModel):\n            name: Optional[str] = Field(None, min_length=2, max_length=100)\n            price: Optional[Decimal] = Field(None, ge=0)\n            description: Optional[str] = None\n            in_stock: Optional[bool] = None\n\n        admin.add_view(\n            model=Product,\n            create_schema=ProductCreate,\n            update_schema=ProductUpdate,\n            update_internal_schema=None,\n            delete_schema=None,\n            allowed_actions={\"view\", \"create\", \"update\"}\n        )\n        ```\n\n        Order management with enum and relationships:\n        ```python\n        from enum import Enum\n        from typing import List\n\n        class OrderStatus(str, Enum):\n            pending = \"pending\"\n            paid = \"paid\"\n            shipped = \"shipped\"\n            delivered = \"delivered\"\n            cancelled = \"cancelled\"\n\n        class OrderCreate(BaseModel):\n            user_id: int = Field(..., gt=0)\n            items: List[int] = Field(..., min_items=1)\n            shipping_address: str\n            status: OrderStatus = Field(default=OrderStatus.pending)\n            notes: Optional[str] = None\n\n            class Config:\n                json_schema_extra = {\n                    \"example\": {\n                        \"user_id\": 1,\n                        \"items\": [1, 2, 3],\n                        \"shipping_address\": \"123 Main St\",\n                        \"status\": \"pending\"\n                    }\n                }\n\n        class OrderUpdate(BaseModel):\n            status: Optional[OrderStatus] = None\n            notes: Optional[str] = None\n\n        # Custom delete schema with soft delete\n        class OrderDelete(BaseModel):\n            archive: bool = Field(default=False, description=\"Archive instead of delete\")\n            reason: Optional[str] = Field(None, max_length=200)\n\n        admin.add_view(\n            model=Order,\n            create_schema=OrderCreate,\n            update_schema=OrderUpdate,\n            update_internal_schema=None,\n            delete_schema=OrderDelete,\n            allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n        )\n        ```\n\n        Read-only audit log:\n        ```python\n        class AuditLogSchema(BaseModel):\n            id: int\n            timestamp: datetime\n            user_id: int\n            action: str\n            details: dict\n\n            class Config:\n                orm_mode = True\n\n        admin.add_view(\n            model=AuditLog,\n            create_schema=AuditLogSchema,\n            update_schema=AuditLogSchema,\n            update_internal_schema=None,\n            delete_schema=None,\n            allowed_actions={\"view\"},  # Read-only\n            include_in_models=False  # Hide from nav\n        )\n        ```\n    \"\"\"\n    model_key = model.__name__\n    if include_in_models:\n        self.models[model_key] = {\n            \"model\": model,\n            \"create_schema\": create_schema,\n            \"update_schema\": update_schema,\n            \"update_internal_schema\": update_internal_schema,\n            \"delete_schema\": delete_schema,\n            \"crud\": FastCRUD(model),\n        }\n\n    allowed_actions = allowed_actions or {\"view\", \"create\", \"update\", \"delete\"}\n\n    admin_view = ModelView(\n        database_config=self.db_config,\n        templates=self.templates,\n        model=model,\n        create_schema=create_schema,\n        update_schema=update_schema,\n        update_internal_schema=update_internal_schema,\n        delete_schema=delete_schema,\n        admin_site=self.admin_site,\n        allowed_actions=allowed_actions,\n        event_integration=self.event_integration,\n        password_transformer=password_transformer,\n    )\n\n    if self.track_events and self.event_integration:\n        admin_view.event_integration = self.event_integration\n\n    current_user_dep = cast(\n        Callable[..., Any], self.admin_site.admin_authentication.get_current_user\n    )\n    self.app.include_router(\n        admin_view.router,\n        prefix=f\"/{model_key}\",\n        dependencies=[Depends(current_user_dep)],\n        include_in_schema=False,\n    )\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.event_log_content","title":"<code>event_log_content()</code>","text":"<p>Create endpoint for event log data with filtering and pagination.</p> <p>Returns:</p> Type Description <code>EndpointFunction</code> <p>FastAPI route handler that provides filtered event data</p> <code>EndpointFunction</code> <p>with user and audit details</p> Notes <ul> <li>Supports filtering by:</li> <li>Event type</li> <li>Status</li> <li>Username</li> <li>Date range</li> <li>Returns enriched events with:</li> <li>Username</li> <li>Resource details</li> <li>Audit trail data</li> <li>Includes pagination metadata</li> </ul> <p>Examples:</p> <p>Filter events: GET /management/events/content?event_type=create&amp;status=success</p> <p>Filter by date: GET /management/events/content?start_date=2024-01-01&amp;end_date=2024-01-31</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def event_log_content(self) -&gt; EndpointFunction:\n    \"\"\"\n    Create endpoint for event log data with filtering and pagination.\n\n    Returns:\n        FastAPI route handler that provides filtered event data\n        with user and audit details\n\n    Notes:\n        - Supports filtering by:\n        - Event type\n        - Status\n        - Username\n        - Date range\n        - Returns enriched events with:\n        - Username\n        - Resource details\n        - Audit trail data\n        - Includes pagination metadata\n\n    Examples:\n        Filter events:\n        GET /management/events/content?event_type=create&amp;status=success\n\n        Filter by date:\n        GET /management/events/content?start_date=2024-01-01&amp;end_date=2024-01-31\n    \"\"\"\n\n    admin_db_db_dependency = cast(\n        Callable[..., AsyncSession], self.db_config.get_admin_db\n    )\n\n    async def event_log_content_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(admin_db_db_dependency),\n        page: int = 1,\n        limit: int = 10,\n    ) -&gt; RouteResponse:\n        try:\n            if not self.db_config.AdminEventLog:\n                raise ValueError(\"AdminEventLog is not configured\")\n\n            crud_events: FastCRUD = FastCRUD(self.db_config.AdminEventLog)\n\n            event_type = cast(Optional[str], request.query_params.get(\"event_type\"))\n            status = cast(Optional[str], request.query_params.get(\"status\"))\n            username = cast(Optional[str], request.query_params.get(\"username\"))\n            start_date = cast(Optional[str], request.query_params.get(\"start_date\"))\n            end_date = cast(Optional[str], request.query_params.get(\"end_date\"))\n\n            filter_criteria: Dict[str, Any] = {}\n            if event_type:\n                filter_criteria[\"event_type\"] = event_type\n            if status:\n                filter_criteria[\"status\"] = status\n\n            if username:\n                user = await self.db_config.crud_users.get(\n                    db=admin_db, username=username\n                )\n                if user and isinstance(user, dict):\n                    filter_criteria[\"user_id\"] = user.get(\"id\")\n\n            if start_date:\n                start = datetime.strptime(start_date, \"%Y-%m-%d\").replace(\n                    tzinfo=UTC\n                )\n                filter_criteria[\"timestamp__gte\"] = start\n\n            if end_date:\n                end = (\n                    datetime.strptime(end_date, \"%Y-%m-%d\") + timedelta(days=1)\n                ).replace(tzinfo=UTC)\n                filter_criteria[\"timestamp__lt\"] = end\n\n            events = await crud_events.get_multi(\n                db=admin_db,\n                offset=(page - 1) * limit,\n                limit=limit,\n                sort_columns=[\"timestamp\"],\n                sort_orders=[\"desc\"],\n                **filter_criteria,\n            )\n\n            enriched_events = []\n            if isinstance(events[\"data\"], list):\n                for event in events[\"data\"]:\n                    if isinstance(event, dict):\n                        event_data = dict(event)\n                        user = await self.db_config.crud_users.get(\n                            db=admin_db, id=event.get(\"user_id\")\n                        )\n                        if isinstance(user, dict):\n                            event_data[\"username\"] = user.get(\"username\", \"Unknown\")\n\n                        if event.get(\"resource_type\") and event.get(\"resource_id\"):\n                            if not self.db_config.AdminAuditLog:\n                                raise ValueError(\"AdminAuditLog is not configured\")\n\n                            crud_audits: FastCRUD = FastCRUD(\n                                self.db_config.AdminAuditLog\n                            )\n                            audit = await crud_audits.get(\n                                db=admin_db, event_id=event.get(\"id\")\n                            )\n                            if audit and isinstance(audit, dict):\n                                event_data[\"details\"] = {\n                                    \"resource_details\": {\n                                        \"model\": event.get(\"resource_type\"),\n                                        \"id\": event.get(\"resource_id\"),\n                                        \"changes\": audit.get(\"new_state\"),\n                                    }\n                                }\n\n                        enriched_events.append(event_data)\n\n            total_items = events.get(\"total_count\", 0)\n            assert isinstance(total_items, int), (\n                f\"'total_count' should be int, got {type(total_items)}\"\n            )\n\n            total_pages = max(1, (total_items + limit - 1) // limit)\n\n            return self.templates.TemplateResponse(\n                \"admin/management/events_content.html\",\n                {\n                    \"request\": request,\n                    \"events\": enriched_events,\n                    \"page\": page,\n                    \"total_pages\": total_pages,\n                    \"mount_path\": self.mount_path,\n                    \"start_date\": start_date,\n                    \"end_date\": end_date,\n                    \"selected_type\": event_type,\n                    \"selected_status\": status,\n                    \"selected_user\": username,\n                },\n            )\n\n        except Exception as e:\n            logger.error(f\"Error retrieving events: {str(e)}\")\n            return self.templates.TemplateResponse(\n                \"admin/management/events_content.html\",\n                {\n                    \"request\": request,\n                    \"events\": [],\n                    \"page\": 1,\n                    \"total_pages\": 1,\n                    \"mount_path\": self.mount_path,\n                },\n            )\n\n    return event_log_content_inner\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.event_log_page","title":"<code>event_log_page()</code>","text":"<p>Create endpoint for event log main page.</p> <p>Returns:</p> Type Description <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <p>FastAPI route handler that renders event log template</p> <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <p>with filtering options</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def event_log_page(\n    self,\n) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n    \"\"\"\n    Create endpoint for event log main page.\n\n    Returns:\n        FastAPI route handler that renders event log template\n        with filtering options\n    \"\"\"\n\n    admin_db_db_dependency = cast(\n        Callable[..., AsyncSession], self.db_config.get_admin_db\n    )\n    app_db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n    async def event_log_page_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(admin_db_db_dependency),\n        app_db: AsyncSession = Depends(app_db_dependency),\n    ) -&gt; RouteResponse:\n        from ..event import EventStatus, EventType\n\n        users = await self.db_config.crud_users.get_multi(db=admin_db)\n\n        context = await self.admin_site.get_base_context(\n            admin_db=admin_db, app_db=app_db\n        )\n        context.update(\n            {\n                \"request\": request,\n                \"include_sidebar_and_header\": True,\n                \"event_types\": [e.value for e in EventType],\n                \"statuses\": [s.value for s in EventStatus],\n                \"users\": users[\"data\"],\n                \"mount_path\": self.mount_path,\n            }\n        )\n\n        return self.templates.TemplateResponse(\n            \"admin/management/events.html\", context\n        )\n\n    return event_log_page_inner\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.health_check_content","title":"<code>health_check_content()</code>","text":"<p>Create endpoint for health check data.</p> <p>Returns:</p> Type Description <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <p>FastAPI route handler that checks:</p> <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <ul> <li>Database connectivity</li> </ul> <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <ul> <li>Session management</li> </ul> <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <ul> <li>Token service</li> </ul> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def health_check_content(\n    self,\n) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n    \"\"\"\n    Create endpoint for health check data.\n\n    Returns:\n        FastAPI route handler that checks:\n        - Database connectivity\n        - Session management\n        - Token service\n    \"\"\"\n\n    db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n    async def health_check_content_inner(\n        request: Request, db: AsyncSession = Depends(db_dependency)\n    ) -&gt; RouteResponse:\n        health_checks = {}\n\n        start_time = time.time()\n        try:\n            await db.execute(text(\"SELECT 1\"))\n            latency = (time.time() - start_time) * 1000\n            health_checks[\"database\"] = {\n                \"status\": \"healthy\",\n                \"message\": \"Connected successfully\",\n                \"latency\": latency,\n            }\n        except Exception as e:\n            health_checks[\"database\"] = {\"status\": \"unhealthy\", \"message\": str(e)}\n\n        try:\n            await self.session_manager.cleanup_expired_sessions()\n            health_checks[\"session_management\"] = {\n                \"status\": \"healthy\",\n                \"message\": \"Session cleanup working\",\n            }\n        except Exception as e:\n            health_checks[\"session_management\"] = {\n                \"status\": \"unhealthy\",\n                \"message\": str(e),\n            }\n\n        context = {\n            \"request\": request,\n            \"health_checks\": health_checks,\n            \"last_checked\": datetime.now(UTC),\n        }\n\n        return self.templates.TemplateResponse(\n            \"admin/management/health_content.html\", context\n        )\n\n    return health_check_content_inner\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.health_check_page","title":"<code>health_check_page()</code>","text":"<p>Create endpoint for system health check page.</p> <p>Returns:</p> Type Description <code>Callable[[Request, AsyncSession], Awaitable[RouteResponse]]</code> <p>FastAPI route handler that renders health check template</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def health_check_page(\n    self,\n) -&gt; Callable[[Request, AsyncSession], Awaitable[RouteResponse]]:\n    \"\"\"\n    Create endpoint for system health check page.\n\n    Returns:\n        FastAPI route handler that renders health check template\n    \"\"\"\n\n    admin_db_db_dependency = cast(\n        Callable[..., AsyncSession], self.db_config.get_admin_db\n    )\n    app_db_dependency = cast(Callable[..., AsyncSession], self.db_config.session)\n\n    async def health_check_page_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(admin_db_db_dependency),\n        app_db: AsyncSession = Depends(app_db_dependency),\n    ) -&gt; RouteResponse:\n        context = await self.admin_site.get_base_context(\n            admin_db=admin_db, app_db=app_db\n        )\n        context.update({\"request\": request, \"include_sidebar_and_header\": True})\n\n        return self.templates.TemplateResponse(\n            \"admin/management/health.html\", context\n        )\n\n    return health_check_page_inner\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.initialize","title":"<code>initialize()</code>  <code>async</code>","text":"<p>Initialize admin database tables and create initial admin user.</p> <p>Creates required tables: - AdminUser for user management - AdminSession for session tracking - AdminEventLog and AdminAuditLog if event tracking enabled</p> <p>Also creates initial admin user if credentials were provided.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If event log models are misconfigured</p> <code>ValueError</code> <p>If database initialization fails</p> Notes <ul> <li>This is called automatically if setup_on_initialization=True</li> <li>Tables are created with 'checkfirst' to avoid conflicts</li> <li>Initial admin is only created if no admin exists</li> </ul> Example <p>Manual initialization: <pre><code>admin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=\"key\",\n    setup_on_initialization=False\n)\nawait admin.initialize()\n</code></pre></p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>async def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize admin database tables and create initial admin user.\n\n    Creates required tables:\n    - AdminUser for user management\n    - AdminSession for session tracking\n    - AdminEventLog and AdminAuditLog if event tracking enabled\n\n    Also creates initial admin user if credentials were provided.\n\n    Raises:\n        AssertionError: If event log models are misconfigured\n        ValueError: If database initialization fails\n\n    Notes:\n        - This is called automatically if setup_on_initialization=True\n        - Tables are created with 'checkfirst' to avoid conflicts\n        - Initial admin is only created if no admin exists\n\n    Example:\n        Manual initialization:\n        ```python\n        admin = CRUDAdmin(\n            session=async_session,\n            SECRET_KEY=\"key\",\n            setup_on_initialization=False\n        )\n        await admin.initialize()\n        ```\n    \"\"\"\n    await self.db_config.initialize_admin_db()\n\n    if self.initial_admin:\n        await self._create_initial_admin(self.initial_admin)\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.setup","title":"<code>setup()</code>","text":"<p>Set up admin interface routes and views.</p> <p>Configures: - Authentication routes and middleware - Model CRUD views - Management views (health check, events) - Static files</p> Notes <ul> <li>Called automatically if setup_on_initialization=True</li> <li>Can be called manually after initialization</li> <li>Respects allowed_actions configuration</li> </ul> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def setup(\n    self,\n) -&gt; None:\n    \"\"\"\n    Set up admin interface routes and views.\n\n    Configures:\n    - Authentication routes and middleware\n    - Model CRUD views\n    - Management views (health check, events)\n    - Static files\n\n    Notes:\n        - Called automatically if setup_on_initialization=True\n        - Can be called manually after initialization\n        - Respects allowed_actions configuration\n    \"\"\"\n    self.admin_site = AdminSite(\n        database_config=self.db_config,\n        templates_directory=self.templates_directory,\n        models=self.models,\n        admin_authentication=self.admin_authentication,\n        mount_path=self.mount_path,\n        theme=self.theme,\n        secure_cookies=self.secure_cookies,\n        event_integration=self.event_integration if self.track_events else None,\n        session_manager=self.session_manager,\n    )\n\n    self.admin_site.setup_routes()\n\n    for model_name, data in self.admin_authentication.auth_models.items():\n        allowed_actions = {\n            \"AdminUser\": {\"view\", \"create\", \"update\"},\n            \"AdminSession\": {\"view\", \"delete\"},\n        }.get(model_name, {\"view\"})\n\n        model = cast(Type[DeclarativeBase], data[\"model\"])\n        create_schema = cast(Type[BaseModel], data[\"create_schema\"])\n        update_schema = cast(Type[BaseModel], data[\"update_schema\"])\n        update_internal_schema = cast(\n            Optional[Type[BaseModel]], data[\"update_internal_schema\"]\n        )\n        delete_schema = cast(Optional[Type[BaseModel]], data[\"delete_schema\"])\n\n        self.add_view(\n            model=model,\n            create_schema=create_schema,\n            update_schema=update_schema,\n            update_internal_schema=update_internal_schema,\n            delete_schema=delete_schema,\n            include_in_models=False,\n            allowed_actions=allowed_actions,\n        )\n\n    get_user_dependency = cast(\n        Callable[..., AsyncSession], self.admin_authentication.get_current_user\n    )\n\n    self.router.add_api_route(\n        \"/management/health\",\n        self.health_check_page(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        dependencies=[Depends(get_user_dependency)],\n        response_model=None,\n    )\n\n    self.router.add_api_route(\n        \"/management/health/content\",\n        self.health_check_content(),\n        methods=[\"GET\"],\n        include_in_schema=False,\n        dependencies=[Depends(get_user_dependency)],\n        response_model=None,\n    )\n\n    if self.track_events:\n        self.router.add_api_route(\n            \"/management/events\",\n            self.event_log_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(get_user_dependency)],\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/management/events/content\",\n            self.event_log_content(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(get_user_dependency)],\n            response_model=None,\n        )\n\n    self.router.include_router(router=self.admin_site.router)\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.setup_event_routes","title":"<code>setup_event_routes()</code>","text":"<p>Set up routes for event log management.</p> <p>Creates endpoints: - GET /management/events - Event log page - GET /management/events/content - Event log data</p> Notes <ul> <li>Only created if track_events=True</li> <li>Routes require authentication</li> </ul> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def setup_event_routes(self) -&gt; None:\n    \"\"\"\n    Set up routes for event log management.\n\n    Creates endpoints:\n    - GET /management/events - Event log page\n    - GET /management/events/content - Event log data\n\n    Notes:\n        - Only created if track_events=True\n        - Routes require authentication\n    \"\"\"\n    if self.track_events:\n        self.router.add_api_route(\n            \"/management/events\",\n            self.event_log_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(self.admin_authentication.get_current_user())],\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/management/events/content\",\n            self.event_log_content(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            dependencies=[Depends(self.admin_authentication.get_current_user())],\n            response_model=None,\n        )\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.use_database_sessions","title":"<code>use_database_sessions(**kwargs)</code>","text":"<p>Configure database session backend.</p> <p>This enables session storage in the AdminSession table for full admin dashboard visibility.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional database storage configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>CRUDAdmin</code> <p>Self for method chaining</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def use_database_sessions(self, **kwargs: Any) -&gt; \"CRUDAdmin\":\n    \"\"\"Configure database session backend.\n\n    This enables session storage in the AdminSession table for full\n    admin dashboard visibility.\n\n    Args:\n        **kwargs: Additional database storage configuration options\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._session_backend = \"database\"\n    self._session_backend_kwargs = kwargs\n    self.track_sessions_in_db = True\n    return self\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.use_memcached_sessions","title":"<code>use_memcached_sessions(servers=None, **kwargs)</code>","text":"<p>Configure Memcached session backend.</p> <p>Parameters:</p> Name Type Description Default <code>servers</code> <code>Optional[List[str]]</code> <p>List of memcached server addresses</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional Memcached configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>CRUDAdmin</code> <p>Self for method chaining</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def use_memcached_sessions(\n    self, servers: Optional[List[str]] = None, **kwargs: Any\n) -&gt; \"CRUDAdmin\":\n    \"\"\"Configure Memcached session backend.\n\n    Args:\n        servers: List of memcached server addresses\n        **kwargs: Additional Memcached configuration options\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    if servers is None:\n        servers = [\"localhost:11211\"]\n    self._session_backend = \"memcached\"\n    self._session_backend_kwargs = {\"servers\": servers, **kwargs}\n    return self\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.use_memory_sessions","title":"<code>use_memory_sessions(**kwargs)</code>","text":"<p>Configure in-memory session backend.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional memory storage configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>CRUDAdmin</code> <p>Self for method chaining</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def use_memory_sessions(self, **kwargs: Any) -&gt; \"CRUDAdmin\":\n    \"\"\"Configure in-memory session backend.\n\n    Args:\n        **kwargs: Additional memory storage configuration options\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._session_backend = \"memory\"\n    self._session_backend_kwargs = kwargs\n    return self\n</code></pre>"},{"location":"api/crud_admin/#crudadmin.admin_interface.crud_admin.CRUDAdmin.use_redis_sessions","title":"<code>use_redis_sessions(redis_url='redis://localhost:6379', **kwargs)</code>","text":"<p>Configure Redis session backend.</p> <p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Redis connection URL</p> <code>'redis://localhost:6379'</code> <code>**kwargs</code> <code>Any</code> <p>Additional Redis configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>CRUDAdmin</code> <p>Self for method chaining</p> Source code in <code>crudadmin/admin_interface/crud_admin.py</code> <pre><code>def use_redis_sessions(\n    self, redis_url: str = \"redis://localhost:6379\", **kwargs: Any\n) -&gt; \"CRUDAdmin\":\n    \"\"\"Configure Redis session backend.\n\n    Args:\n        redis_url: Redis connection URL\n        **kwargs: Additional Redis configuration options\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self._session_backend = \"redis\"\n    self._session_backend_kwargs = {\"redis_url\": redis_url, **kwargs}\n    return self\n</code></pre>"},{"location":"api/events/","title":"Event System API Reference","text":"<p>The CRUDAdmin event system provides comprehensive audit logging and event tracking for admin operations. This system automatically logs admin actions, authentication events, and security-related activities with full audit trails.</p>"},{"location":"api/events/#core-components","title":"Core Components","text":""},{"location":"api/events/#event-types-and-status","title":"Event Types and Status","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class EventType(str, enum.Enum):\n    CREATE = \"create\"\n    UPDATE = \"update\"\n    DELETE = \"delete\"\n    LOGIN = \"login\"\n    LOGOUT = \"logout\"\n    FAILED_LOGIN = \"failed_login\"\n</code></pre> <p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class EventStatus(str, enum.Enum):\n    SUCCESS = \"success\"\n    FAILURE = \"failure\"\n    WARNING = \"warning\"\n</code></pre>"},{"location":"api/events/#model-creation-functions","title":"Model Creation Functions","text":"Source code in <code>crudadmin/event/models.py</code> <pre><code>def create_admin_event_log(base: type[DeclarativeBase]) -&gt; type[DeclarativeBase]:\n    tablename = \"admin_event_log\"\n\n    if hasattr(base, \"registry\") and hasattr(base.registry, \"_class_registry\"):\n        existing_class = base.registry._class_registry.get(\"AdminEventLog\")\n        if existing_class is not None and isinstance(existing_class, type):\n            if issubclass(existing_class, base):\n                return cast(type[DeclarativeBase], existing_class)\n\n    class AdminEventLog(base):  # type: ignore\n        __tablename__ = tablename\n        __table_args__ = {\"extend_existing\": True}\n\n        id: Mapped[int] = mapped_column(\n            \"id\",\n            autoincrement=True,\n            nullable=False,\n            unique=True,\n            primary_key=True,\n        )\n        timestamp: Mapped[datetime] = mapped_column(\n            DateTime(timezone=True),\n            default=lambda: datetime.now(UTC),\n            nullable=False,\n        )\n        event_type: Mapped[EventType] = mapped_column(\n            SQLEnum(EventType), nullable=False\n        )\n        status: Mapped[EventStatus] = mapped_column(\n            SQLEnum(EventStatus), nullable=False\n        )\n        user_id: Mapped[int] = mapped_column(index=True)\n        session_id: Mapped[str] = mapped_column(String(36), index=True)\n        ip_address: Mapped[str] = mapped_column(String(45))\n        user_agent: Mapped[str] = mapped_column(String(512))\n        resource_type: Mapped[Optional[str]] = mapped_column(String(128))\n        resource_id: Mapped[Optional[str]] = mapped_column(String(128))\n        details: Mapped[dict[str, Any]] = mapped_column(\n            JSON, default=dict, nullable=False\n        )\n\n        def __repr__(self):\n            return f\"&lt;AdminEventLog(id={self.id}, event_type={self.event_type}, user_id={self.user_id})&gt;\"\n\n    return AdminEventLog\n</code></pre> Source code in <code>crudadmin/event/models.py</code> <pre><code>def create_admin_audit_log(base: type[DeclarativeBase]) -&gt; type[DeclarativeBase]:\n    tablename = \"admin_audit_log\"\n\n    if hasattr(base, \"registry\") and hasattr(base.registry, \"_class_registry\"):\n        existing_class = base.registry._class_registry.get(\"AdminAuditLog\")\n        if existing_class is not None and isinstance(existing_class, type):\n            if issubclass(existing_class, base):\n                return cast(type[DeclarativeBase], existing_class)\n\n    class AdminAuditLog(base):  # type: ignore\n        __tablename__ = tablename\n        __table_args__ = {\"extend_existing\": True}\n\n        id: Mapped[int] = mapped_column(\n            \"id\",\n            autoincrement=True,\n            nullable=False,\n            unique=True,\n            primary_key=True,\n        )\n        event_id: Mapped[int] = mapped_column(index=True)\n        timestamp: Mapped[datetime] = mapped_column(\n            DateTime(timezone=True),\n            default=lambda: datetime.now(UTC),\n            nullable=False,\n        )\n        resource_type: Mapped[str] = mapped_column(String(128))\n        resource_id: Mapped[str] = mapped_column(String(128))\n        action: Mapped[str] = mapped_column(String(64))\n        previous_state: Mapped[Optional[dict[str, Any]]] = mapped_column(\n            JSON, nullable=True\n        )\n        new_state: Mapped[Optional[dict[str, Any]]] = mapped_column(JSON, nullable=True)\n        changes: Mapped[dict[str, Any]] = mapped_column(\n            JSON, default=dict, nullable=False\n        )\n        audit_metadata: Mapped[dict[str, Any]] = mapped_column(\n            JSON, default=dict, nullable=False\n        )\n\n        def __repr__(self):\n            return f\"&lt;AdminAuditLog(id={self.id}, resource_type={self.resource_type}, resource_id={self.resource_id})&gt;\"\n\n    return AdminAuditLog\n</code></pre>"},{"location":"api/events/#event-service","title":"Event Service","text":"<p>The main service class for managing event logging and retrieval.</p> Source code in <code>crudadmin/event/service.py</code> <pre><code>class EventService:\n    def __init__(self, db_config):\n        self.db_config = db_config\n        self.crud_events = FastCRUD(db_config.AdminEventLog)\n        self.crud_audits = FastCRUD(db_config.AdminAuditLog)\n        self.json_encoder = CustomJSONEncoder()\n\n    def _serialize_dict(self, data: Optional[dict]) -&gt; dict:\n        if not data:\n            return {}\n        return cast(dict, json.loads(self.json_encoder.encode(data)))\n\n    async def log_event(\n        self,\n        db: AsyncSession,\n        event_type: EventType,\n        status: EventStatus,\n        user_id: int,\n        session_id: str,\n        request: Request,\n        resource_type: Optional[str] = None,\n        resource_id: Optional[str] = None,\n        details: Optional[dict] = None,\n    ) -&gt; AdminEventLogRead:\n        try:\n            ip_address = request.client.host if request.client else \"unknown\"\n\n            event_data = AdminEventLogCreate(\n                event_type=event_type,\n                status=status,\n                user_id=user_id,\n                session_id=session_id,\n                ip_address=ip_address,\n                user_agent=request.headers.get(\"user-agent\", \"\"),\n                resource_type=resource_type,\n                resource_id=resource_id,\n                details=self._serialize_dict(details),\n            )\n\n            result = await self.crud_events.create(db=db, object=event_data)\n\n            if hasattr(result, \"__dict__\"):\n                result_dict = {\n                    k: v for k, v in result.__dict__.items() if not k.startswith(\"_\")\n                }\n            else:\n                result_dict = cast(dict, dict(result))\n\n            event_read = AdminEventLogRead(**result_dict)\n\n            await db.commit()\n            return event_read\n\n        except Exception as e:\n            logger.error(f\"Error logging event: {str(e)}\", exc_info=True)\n            raise\n\n    async def create_audit_log(\n        self,\n        db: AsyncSession,\n        event_id: int,\n        resource_type: str,\n        resource_id: str,\n        action: str,\n        previous_state: Optional[dict] = None,\n        new_state: Optional[dict] = None,\n        metadata: Optional[dict] = None,\n    ) -&gt; AdminAuditLogRead:\n        try:\n            audit_data = AdminAuditLogCreate(\n                event_id=event_id,\n                resource_type=resource_type,\n                resource_id=resource_id,\n                action=action,\n                previous_state=self._serialize_dict(previous_state),\n                new_state=self._serialize_dict(new_state),\n                changes=self._serialize_dict(\n                    self._compute_changes(previous_state, new_state)\n                ),\n                metadata=self._serialize_dict(metadata),\n            )\n\n            result = await self.crud_audits.create(db=db, object=audit_data)\n\n            if hasattr(result, \"__dict__\"):\n                result_dict = {\n                    k: v for k, v in result.__dict__.items() if not k.startswith(\"_\")\n                }\n            else:\n                result_dict = cast(dict, dict(result))\n\n            return AdminAuditLogRead(**result_dict)\n\n        except Exception as e:\n            logger.error(f\"Error creating audit log: {str(e)}\", exc_info=True)\n            raise\n\n    def _compute_changes(\n        self,\n        previous_state: Optional[dict],\n        new_state: Optional[dict],\n    ) -&gt; dict:\n        \"\"\"Compute changes between previous and new states.\"\"\"\n        changes: dict = {}\n\n        if not previous_state or not new_state:\n            return changes\n\n        all_keys = set(previous_state.keys()) | set(new_state.keys())\n\n        for key in all_keys:\n            old_value = previous_state.get(key)\n            new_value = new_state.get(key)\n\n            if old_value != new_value:\n                changes[key] = {\"old\": old_value, \"new\": new_value}\n\n        return changes\n\n    async def get_user_activity(\n        self,\n        db: AsyncSession,\n        user_id: int,\n        start_time: Optional[datetime] = None,\n        end_time: Optional[datetime] = None,\n        limit: int = 50,\n        offset: int = 0,\n    ) -&gt; dict:\n        \"\"\"Get user activity logs.\"\"\"\n        filters: dict = {\"user_id\": user_id}\n\n        if start_time:\n            filters[\"timestamp__gte\"] = start_time\n        if end_time:\n            filters[\"timestamp__lte\"] = end_time\n\n        result = await self.crud_events.get_multi(\n            db,\n            offset=offset,\n            limit=limit,\n            sort_columns=[\"timestamp\"],\n            sort_orders=[\"desc\"],\n            **filters,\n        )\n\n        return cast(dict, result)\n\n    async def get_resource_history(\n        self,\n        db: AsyncSession,\n        resource_type: str,\n        resource_id: str,\n        limit: int = 50,\n        offset: int = 0,\n    ) -&gt; dict:\n        \"\"\"Get audit history for a specific resource.\"\"\"\n        result = await self.crud_audits.get_multi(\n            db,\n            offset=offset,\n            limit=limit,\n            sort_columns=[\"timestamp\"],\n            sort_orders=[\"desc\"],\n            resource_type=resource_type,\n            resource_id=resource_id,\n        )\n\n        return cast(dict[str, Any], result)\n\n    async def get_security_alerts(\n        self, db: AsyncSession, lookback_hours: int = 24\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get security alerts based on event patterns.\"\"\"\n        alerts: list[dict[str, Any]] = []\n        lookback_time = datetime.now(UTC) - timedelta(hours=lookback_hours)\n\n        failed_logins = await self.crud_events.get_multi(\n            db,\n            event_type=EventType.FAILED_LOGIN,\n            status=EventStatus.FAILURE,\n            timestamp__gte=lookback_time,\n        )\n\n        failed_login_patterns: dict[tuple, int] = {}\n\n        for login in failed_logins.get(\"data\", []):\n            key = (\n                login.get(\"ip_address\", \"unknown\"),\n                login.get(\"details\", {}).get(\"username\", \"unknown\"),\n            )\n            failed_login_patterns[key] = failed_login_patterns.get(key, 0) + 1\n\n        for (ip, username), count in failed_login_patterns.items():\n            if count &gt;= 5:\n                alerts.append(\n                    {\n                        \"type\": \"multiple_failed_logins\",\n                        \"severity\": \"high\",\n                        \"details\": {\n                            \"ip_address\": ip,\n                            \"username\": username,\n                            \"attempts\": count,\n                        },\n                    }\n                )\n\n        return alerts\n\n    async def cleanup_old_logs(\n        self, db: AsyncSession, retention_days: int = 90\n    ) -&gt; None:\n        \"\"\"Clean up old logs based on retention policy.\"\"\"\n        try:\n            cutoff_date = datetime.now(UTC) - timedelta(days=retention_days)\n\n            await self.crud_events.delete(\n                db, allow_multiple=True, timestamp__lt=cutoff_date\n            )\n\n            await self.crud_audits.delete(\n                db, allow_multiple=True, timestamp__lt=cutoff_date\n            )\n\n        except Exception as e:\n            logger.error(f\"Error cleaning up old logs: {str(e)}\", exc_info=True)\n            raise\n</code></pre>"},{"location":"api/events/#crudadmin.event.service.EventService.cleanup_old_logs","title":"<code>cleanup_old_logs(db, retention_days=90)</code>  <code>async</code>","text":"<p>Clean up old logs based on retention policy.</p> Source code in <code>crudadmin/event/service.py</code> <pre><code>async def cleanup_old_logs(\n    self, db: AsyncSession, retention_days: int = 90\n) -&gt; None:\n    \"\"\"Clean up old logs based on retention policy.\"\"\"\n    try:\n        cutoff_date = datetime.now(UTC) - timedelta(days=retention_days)\n\n        await self.crud_events.delete(\n            db, allow_multiple=True, timestamp__lt=cutoff_date\n        )\n\n        await self.crud_audits.delete(\n            db, allow_multiple=True, timestamp__lt=cutoff_date\n        )\n\n    except Exception as e:\n        logger.error(f\"Error cleaning up old logs: {str(e)}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"api/events/#crudadmin.event.service.EventService.get_resource_history","title":"<code>get_resource_history(db, resource_type, resource_id, limit=50, offset=0)</code>  <code>async</code>","text":"<p>Get audit history for a specific resource.</p> Source code in <code>crudadmin/event/service.py</code> <pre><code>async def get_resource_history(\n    self,\n    db: AsyncSession,\n    resource_type: str,\n    resource_id: str,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; dict:\n    \"\"\"Get audit history for a specific resource.\"\"\"\n    result = await self.crud_audits.get_multi(\n        db,\n        offset=offset,\n        limit=limit,\n        sort_columns=[\"timestamp\"],\n        sort_orders=[\"desc\"],\n        resource_type=resource_type,\n        resource_id=resource_id,\n    )\n\n    return cast(dict[str, Any], result)\n</code></pre>"},{"location":"api/events/#crudadmin.event.service.EventService.get_security_alerts","title":"<code>get_security_alerts(db, lookback_hours=24)</code>  <code>async</code>","text":"<p>Get security alerts based on event patterns.</p> Source code in <code>crudadmin/event/service.py</code> <pre><code>async def get_security_alerts(\n    self, db: AsyncSession, lookback_hours: int = 24\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get security alerts based on event patterns.\"\"\"\n    alerts: list[dict[str, Any]] = []\n    lookback_time = datetime.now(UTC) - timedelta(hours=lookback_hours)\n\n    failed_logins = await self.crud_events.get_multi(\n        db,\n        event_type=EventType.FAILED_LOGIN,\n        status=EventStatus.FAILURE,\n        timestamp__gte=lookback_time,\n    )\n\n    failed_login_patterns: dict[tuple, int] = {}\n\n    for login in failed_logins.get(\"data\", []):\n        key = (\n            login.get(\"ip_address\", \"unknown\"),\n            login.get(\"details\", {}).get(\"username\", \"unknown\"),\n        )\n        failed_login_patterns[key] = failed_login_patterns.get(key, 0) + 1\n\n    for (ip, username), count in failed_login_patterns.items():\n        if count &gt;= 5:\n            alerts.append(\n                {\n                    \"type\": \"multiple_failed_logins\",\n                    \"severity\": \"high\",\n                    \"details\": {\n                        \"ip_address\": ip,\n                        \"username\": username,\n                        \"attempts\": count,\n                    },\n                }\n            )\n\n    return alerts\n</code></pre>"},{"location":"api/events/#crudadmin.event.service.EventService.get_user_activity","title":"<code>get_user_activity(db, user_id, start_time=None, end_time=None, limit=50, offset=0)</code>  <code>async</code>","text":"<p>Get user activity logs.</p> Source code in <code>crudadmin/event/service.py</code> <pre><code>async def get_user_activity(\n    self,\n    db: AsyncSession,\n    user_id: int,\n    start_time: Optional[datetime] = None,\n    end_time: Optional[datetime] = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; dict:\n    \"\"\"Get user activity logs.\"\"\"\n    filters: dict = {\"user_id\": user_id}\n\n    if start_time:\n        filters[\"timestamp__gte\"] = start_time\n    if end_time:\n        filters[\"timestamp__lte\"] = end_time\n\n    result = await self.crud_events.get_multi(\n        db,\n        offset=offset,\n        limit=limit,\n        sort_columns=[\"timestamp\"],\n        sort_orders=[\"desc\"],\n        **filters,\n    )\n\n    return cast(dict, result)\n</code></pre>"},{"location":"api/events/#event-system-integration","title":"Event System Integration","text":"<p>High-level integration class for simplified event logging.</p> Source code in <code>crudadmin/event/integration.py</code> <pre><code>class EventSystemIntegration:\n    def __init__(self, event_service: EventService):\n        self.event_service = event_service\n\n    async def log_model_event(\n        self,\n        db: AsyncSession,\n        event_type: EventType,\n        model: Type[DeclarativeBase],\n        user_id: int,\n        session_id: str,\n        request: Request,\n        resource_id: Optional[str] = None,\n        previous_state: Optional[Dict[str, Any]] = None,\n        new_state: Optional[Dict[str, Any]] = None,\n        details: Optional[Dict[str, Any]] = None,\n    ):\n        try:\n            event = await self.event_service.log_event(\n                db=db,\n                event_type=event_type,\n                status=EventStatus.SUCCESS,\n                user_id=user_id,\n                session_id=session_id,\n                request=request,\n                resource_type=model.__name__,\n                resource_id=str(resource_id) if resource_id else None,\n                details=details,\n            )\n\n            if (\n                event\n                and event_type in [EventType.CREATE, EventType.UPDATE, EventType.DELETE]\n                and resource_id\n            ):\n                await self.event_service.create_audit_log(\n                    db=db,\n                    event_id=event.id,\n                    resource_type=model.__name__,\n                    resource_id=str(resource_id),\n                    action=event_type.value,\n                    previous_state=previous_state,\n                    new_state=new_state,\n                    metadata=details,\n                )\n\n            await db.commit()\n            return event\n\n        except Exception as e:\n            logger.error(f\"Error in event logging: {str(e)}\")\n            await db.rollback()\n            raise\n\n    async def log_auth_event(\n        self,\n        db: AsyncSession,\n        event_type: EventType,\n        user_id: int,\n        session_id: str,\n        request: Request,\n        success: bool,\n        details: Optional[Dict[str, Any]] = None,\n    ):\n        \"\"\"Log authentication-related events.\"\"\"\n        try:\n            status = EventStatus.SUCCESS if success else EventStatus.FAILURE\n\n            await self.event_service.log_event(\n                db=db,\n                event_type=event_type,\n                status=status,\n                user_id=user_id,\n                session_id=session_id,\n                request=request,\n                details=details,\n            )\n\n        except Exception as e:\n            logger.error(f\"Error logging auth event: {str(e)}\", exc_info=True)\n\n    async def log_security_event(\n        self,\n        db: AsyncSession,\n        event_type: EventType,\n        user_id: int,\n        session_id: str,\n        request: Request,\n        details: Dict[str, Any],\n    ):\n        \"\"\"Log security-related events with high priority.\"\"\"\n        try:\n            event = await self.event_service.log_event(\n                db=db,\n                event_type=event_type,\n                status=EventStatus.WARNING,\n                user_id=user_id,\n                session_id=session_id,\n                request=request,\n                details={**details, \"priority\": \"high\", \"requires_attention\": True},\n            )\n\n            return event\n\n        except Exception as e:\n            logger.error(f\"Error logging security event: {str(e)}\", exc_info=True)\n            raise\n</code></pre>"},{"location":"api/events/#crudadmin.event.integration.EventSystemIntegration.log_auth_event","title":"<code>log_auth_event(db, event_type, user_id, session_id, request, success, details=None)</code>  <code>async</code>","text":"<p>Log authentication-related events.</p> Source code in <code>crudadmin/event/integration.py</code> <pre><code>async def log_auth_event(\n    self,\n    db: AsyncSession,\n    event_type: EventType,\n    user_id: int,\n    session_id: str,\n    request: Request,\n    success: bool,\n    details: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"Log authentication-related events.\"\"\"\n    try:\n        status = EventStatus.SUCCESS if success else EventStatus.FAILURE\n\n        await self.event_service.log_event(\n            db=db,\n            event_type=event_type,\n            status=status,\n            user_id=user_id,\n            session_id=session_id,\n            request=request,\n            details=details,\n        )\n\n    except Exception as e:\n        logger.error(f\"Error logging auth event: {str(e)}\", exc_info=True)\n</code></pre>"},{"location":"api/events/#crudadmin.event.integration.EventSystemIntegration.log_security_event","title":"<code>log_security_event(db, event_type, user_id, session_id, request, details)</code>  <code>async</code>","text":"<p>Log security-related events with high priority.</p> Source code in <code>crudadmin/event/integration.py</code> <pre><code>async def log_security_event(\n    self,\n    db: AsyncSession,\n    event_type: EventType,\n    user_id: int,\n    session_id: str,\n    request: Request,\n    details: Dict[str, Any],\n):\n    \"\"\"Log security-related events with high priority.\"\"\"\n    try:\n        event = await self.event_service.log_event(\n            db=db,\n            event_type=event_type,\n            status=EventStatus.WARNING,\n            user_id=user_id,\n            session_id=session_id,\n            request=request,\n            details={**details, \"priority\": \"high\", \"requires_attention\": True},\n        )\n\n        return event\n\n    except Exception as e:\n        logger.error(f\"Error logging security event: {str(e)}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"api/events/#decorators","title":"Decorators","text":"<p>Convenient decorators for automatic event logging.</p> Source code in <code>crudadmin/event/decorators.py</code> <pre><code>def log_admin_action(\n    event_type: EventType, model: Optional[Type[DeclarativeBase]] = None\n):\n    def decorator(func: Callable):\n        @functools.wraps(func)\n        async def wrapper(\n            *args,\n            request: Request,\n            db: AsyncSession,\n            admin_db: AsyncSession,\n            current_user: Any,\n            event_integration=None,\n            **kwargs,\n        ):\n            user_dict = convert_user_to_dict(current_user) if current_user else None\n\n            previous_state = None\n            crud: Optional[FastCRUD] = None\n\n            if event_type in [EventType.UPDATE, EventType.DELETE]:\n                try:\n                    if model is not None:\n                        crud = FastCRUD(model)\n                    else:\n                        logger.error(\"Model is None. Cannot initialize FastCRUD.\")\n                        raise ValueError(\"Model must not be None.\")\n\n                    if \"id\" in kwargs:\n                        assert crud is not None, \"CRUD instance should be initialized.\"\n                        item = await crud.get(db=db, id=kwargs[\"id\"])\n                        if item:\n                            previous_state = {\n                                k: v for k, v in item.items() if not k.startswith(\"_\")\n                            }\n                except Exception as e:\n                    logger.error(f\"Error fetching previous state: {str(e)}\")\n                    raise\n\n            result = await func(\n                *args,\n                request=request,\n                db=db,\n                admin_db=admin_db,\n                current_user=current_user,\n                **kwargs,\n            )\n\n            try:\n                if event_integration and user_dict:\n                    session_id = request.cookies.get(\"session_id\", \"unknown\")\n\n                    new_state = None\n                    resource_id = kwargs.get(\"id\")\n\n                    if event_type == EventType.UPDATE:\n                        try:\n                            if model is not None:\n                                crud = FastCRUD(model)\n                            assert crud is not None, (\n                                \"CRUD instance should be initialized.\"\n                            )\n                            updated_item = await crud.get(db=db, id=kwargs[\"id\"])\n                            if updated_item:\n                                new_state = {\n                                    k: v\n                                    for k, v in updated_item.items()\n                                    if not k.startswith(\"_\")\n                                }\n                                new_state = get_model_changes(new_state)\n                        except Exception as e:\n                            logger.error(f\"Error fetching updated state: {str(e)}\")\n\n                    elif hasattr(request.state, \"crud_result\"):\n                        crud_result = request.state.crud_result\n                        if hasattr(crud_result, \"__dict__\"):\n                            model_dict = {\n                                k: v\n                                for k, v in crud_result.__dict__.items()\n                                if not k.startswith(\"_\")\n                            }\n                        else:\n                            model_dict = dict(crud_result)\n\n                        resource_id = str(model_dict.get(\"id\", resource_id))\n                        new_state = get_model_changes(model_dict)\n\n                    if event_type == EventType.DELETE:\n                        try:\n                            body = await request.json()\n                            ids = body.get(\"ids\", [])\n                            logger.info(f\"Delete request received for ids: {ids}\")\n\n                            deleted_records = []\n                            if hasattr(request.state, \"deleted_records\"):\n                                deleted_records = [\n                                    {\n                                        k: v\n                                        for k, v in record.items()\n                                        if not k.startswith(\"_\")\n                                    }\n                                    for record in request.state.deleted_records\n                                ]\n\n                            new_state = {\n                                \"action\": \"delete\",\n                                \"deleted_at\": datetime.now(UTC).isoformat(),\n                                \"deleted_records\": deleted_records,\n                                \"deletion_details\": {\n                                    \"deleted_by\": user_dict.get(\"username\"),\n                                    \"trigger_path\": request.url.path,\n                                    \"deletion_type\": \"bulk\"\n                                    if \"bulk-delete\" in request.url.path\n                                    else \"single\",\n                                    \"records_count\": len(deleted_records),\n                                    \"requested_ids\": ids,\n                                },\n                            }\n                        except Exception as e:\n                            logger.error(f\"Error in bulk delete process: {str(e)}\")\n\n                    elif event_type == EventType.UPDATE:\n                        changes = compare_states(previous_state, new_state)\n                        new_state = {\n                            \"action\": \"update\",\n                            \"updated_at\": datetime.now(UTC).isoformat(),\n                            \"previous_state\": previous_state,\n                            \"new_state\": new_state,\n                            \"changes\": changes,\n                            \"update_details\": {\n                                \"updated_by\": user_dict.get(\"username\"),\n                                \"update_path\": request.url.path,\n                                \"modified_fields\": list(changes.keys()),\n                            },\n                        }\n\n                    details = {\n                        \"resource_details\": {\n                            \"model\": model.__name__ if model else None,\n                            \"id\": resource_id,\n                            \"changes\": new_state\n                            if event_type in [EventType.UPDATE, EventType.DELETE]\n                            else new_state,\n                        },\n                        \"request_details\": {\n                            \"method\": request.method,\n                            \"path\": str(request.url.path),\n                            \"user_agent\": request.headers.get(\"user-agent\"),\n                        },\n                    }\n\n                    await event_integration.log_model_event(\n                        db=admin_db,\n                        event_type=event_type,\n                        model=model,\n                        user_id=user_dict[\"id\"],\n                        session_id=session_id,\n                        request=request,\n                        resource_id=resource_id,\n                        previous_state=previous_state,\n                        new_state=new_state,\n                        details=details,\n                    )\n                    await admin_db.commit()\n\n            except Exception as e:\n                logger.error(f\"Error logging event: {str(e)}\")\n\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre> Source code in <code>crudadmin/event/decorators.py</code> <pre><code>def log_auth_action(event_type: EventType) -&gt; Callable:\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        async def wrapper(\n            *args, request: Request, db: AsyncSession, event_integration=None, **kwargs\n        ):\n            if event_integration:\n                try:\n                    form_data = kwargs.get(\"form_data\")\n                    result = await func(*args, request=request, db=db, **kwargs)\n\n                    user_id = None\n                    username = None\n                    session_id = None\n                    success = False\n\n                    if event_type == EventType.LOGIN:\n                        if (\n                            hasattr(request.state, \"user\")\n                            and request.state.user is not None\n                        ):\n                            user_id = request.state.user.get(\"id\")\n                            username = request.state.user.get(\"username\")\n                            success = True\n                            if hasattr(result, \"headers\"):\n                                for header in result.raw_headers:\n                                    if (\n                                        header[0].decode() == \"set-cookie\"\n                                        and b\"session_id=\" in header[1]\n                                    ):\n                                        session_id = (\n                                            header[1]\n                                            .decode()\n                                            .split(\"session_id=\")[1]\n                                            .split(\";\")[0]\n                                        )\n                                        break\n                    elif event_type == EventType.LOGOUT:\n                        session_id = request.cookies.get(\"session_id\", \"unknown\")\n                        if (\n                            hasattr(request.state, \"user\")\n                            and request.state.user is not None\n                        ):\n                            user_id = request.state.user.get(\"id\")\n                            username = request.state.user.get(\"username\")\n                            success = True\n\n                    if not session_id:\n                        session_id = \"unknown\"\n\n                    details = {\n                        \"auth_details\": {\n                            \"event_type\": event_type.value,\n                            \"username\": username\n                            or (form_data.username if form_data else \"unknown\"),\n                            \"success\": success,\n                            \"timestamp\": datetime.now(UTC).isoformat(),\n                        },\n                        \"request_details\": {\n                            \"method\": request.method,\n                            \"path\": str(request.url.path),\n                            \"ip_address\": request.client.host\n                            if request.client\n                            else \"unknown\",\n                            \"user_agent\": request.headers.get(\"user-agent\", \"Unknown\"),\n                        },\n                        \"session_details\": {\n                            \"session_id\": session_id,\n                            \"browser\": request.headers.get(\"user-agent\", \"Unknown\"),\n                        },\n                    }\n\n                    await event_integration.log_auth_event(\n                        db=db,\n                        event_type=event_type,\n                        user_id=user_id or 0,\n                        session_id=session_id,\n                        request=request,\n                        success=success,\n                        details=details,\n                    )\n\n                    await db.commit()\n\n                    return result\n\n                except Exception as e:\n                    logger.error(f\"Error logging auth event: {str(e)}\")\n                    raise\n\n            return await func(*args, request=request, db=db, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/events/#event-schemas","title":"Event Schemas","text":""},{"location":"api/events/#event-log-schemas","title":"Event Log Schemas","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminEventLogBase(BaseModel):\n    event_type: EventType\n    status: EventStatus\n    user_id: int\n    session_id: str\n    ip_address: str\n    user_agent: str\n    resource_type: Optional[str] = None\n    resource_id: Optional[str] = None\n    details: dict = {}\n</code></pre> <p>               Bases: <code>AdminEventLogBase</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminEventLogCreate(AdminEventLogBase):\n    pass\n</code></pre> <p>               Bases: <code>AdminEventLogBase</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminEventLogRead(AdminEventLogBase):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    timestamp: datetime\n</code></pre>"},{"location":"api/events/#audit-log-schemas","title":"Audit Log Schemas","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminAuditLogBase(BaseModel):\n    event_id: int\n    resource_type: str\n    resource_id: str\n    action: str\n    previous_state: Optional[dict] = None\n    new_state: Optional[dict] = None\n    changes: dict = {}\n    metadata: dict = {}\n</code></pre> <p>               Bases: <code>AdminAuditLogBase</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminAuditLogCreate(AdminAuditLogBase):\n    pass\n</code></pre> <p>               Bases: <code>AdminAuditLogBase</code></p> Source code in <code>crudadmin/event/schemas.py</code> <pre><code>class AdminAuditLogRead(AdminAuditLogBase):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    timestamp: datetime\n</code></pre>"},{"location":"api/events/#usage-examples","title":"Usage Examples","text":""},{"location":"api/events/#basic-event-logging","title":"Basic Event Logging","text":"<pre><code>from crudadmin.event import EventService, EventType, EventStatus\n\n# Initialize event service\nevent_service = EventService(db_config)\n\n# Log a successful login\nawait event_service.log_event(\n    db=db,\n    event_type=EventType.LOGIN,\n    status=EventStatus.SUCCESS,\n    user_id=user.id,\n    session_id=session_id,\n    request=request,\n    details={\"login_method\": \"password\"}\n)\n</code></pre>"},{"location":"api/events/#automatic-event-logging-with-decorators","title":"Automatic Event Logging with Decorators","text":"<pre><code>from crudadmin.event import log_admin_action, EventType\n\n@log_admin_action(EventType.CREATE, model=User)\nasync def create_user_endpoint(\n    request: Request,\n    db: AsyncSession,\n    admin_db: AsyncSession,\n    current_user: User,\n    event_integration=None,\n    user_data: UserCreate\n):\n    # Create user logic here\n    user = await create_user(db, user_data)\n    return user\n</code></pre>"},{"location":"api/events/#model-event-integration","title":"Model Event Integration","text":"<pre><code>from crudadmin.event import EventSystemIntegration\n\n# Initialize integration\nevent_integration = EventSystemIntegration(event_service)\n\n# Log model changes\nawait event_integration.log_model_event(\n    db=admin_db,\n    event_type=EventType.UPDATE,\n    model=Product,\n    user_id=current_user.id,\n    session_id=session_id,\n    request=request,\n    resource_id=str(product.id),\n    previous_state={\"name\": \"Old Name\", \"price\": 10.00},\n    new_state={\"name\": \"New Name\", \"price\": 15.00},\n    details={\"field_changed\": \"name, price\"}\n)\n</code></pre>"},{"location":"api/events/#querying-event-history","title":"Querying Event History","text":"<pre><code># Get user activity\nactivity = await event_service.get_user_activity(\n    db=admin_db,\n    user_id=user.id,\n    start_time=datetime.now() - timedelta(days=7),\n    limit=100\n)\n\n# Get resource audit history\nhistory = await event_service.get_resource_history(\n    db=admin_db,\n    resource_type=\"Product\",\n    resource_id=\"123\",\n    limit=50\n)\n</code></pre>"},{"location":"api/events/#event-configuration","title":"Event Configuration","text":""},{"location":"api/events/#enabling-event-tracking","title":"Enabling Event Tracking","text":"<pre><code>from crudadmin import CRUDAdmin\n\n# Enable event tracking\ncrud_admin = CRUDAdmin(\n    track_events=True,\n    session_backend=\"database\",  # Required for event storage\n    secret_key=\"your-secret-key\"\n)\n</code></pre>"},{"location":"api/events/#custom-event-details","title":"Custom Event Details","text":"<p>Events can include custom details for additional context:</p> <pre><code>await event_service.log_event(\n    db=admin_db,\n    event_type=EventType.CREATE,\n    status=EventStatus.SUCCESS,\n    user_id=user.id,\n    session_id=session_id,\n    request=request,\n    resource_type=\"Product\",\n    resource_id=\"123\",\n    details={\n        \"category\": \"electronics\",\n        \"bulk_operation\": True,\n        \"import_batch_id\": \"batch_001\",\n        \"validation_warnings\": [\"price_below_cost\"]\n    }\n)\n</code></pre>"},{"location":"api/events/#event-model-fields","title":"Event Model Fields","text":""},{"location":"api/events/#admineventlog-fields","title":"AdminEventLog Fields","text":"Field Type Description <code>id</code> int Primary key <code>timestamp</code> datetime When the event occurred <code>event_type</code> EventType Type of event (CREATE, UPDATE, DELETE, LOGIN, etc.) <code>status</code> EventStatus Event status (SUCCESS, FAILURE, WARNING) <code>user_id</code> int ID of the user who performed the action <code>session_id</code> str Session ID for the request <code>ip_address</code> str IP address of the client <code>user_agent</code> str User agent string from the request <code>resource_type</code> str Type of resource affected (model name) <code>resource_id</code> str ID of the specific resource <code>details</code> dict Additional event-specific details"},{"location":"api/events/#adminauditlog-fields","title":"AdminAuditLog Fields","text":"Field Type Description <code>id</code> int Primary key <code>event_id</code> int Reference to AdminEventLog <code>timestamp</code> datetime When the audit record was created <code>resource_type</code> str Type of resource (model name) <code>resource_id</code> str ID of the specific resource <code>action</code> str Action performed (create, update, delete) <code>previous_state</code> dict State before the change <code>new_state</code> dict State after the change <code>changes</code> dict Computed differences between states <code>audit_metadata</code> dict Additional audit metadata"},{"location":"api/events/#security-considerations","title":"Security Considerations","text":""},{"location":"api/events/#event-integrity","title":"Event Integrity","text":"<ul> <li>Events are stored in append-only fashion</li> <li>Original event records are never modified</li> <li>All changes maintain full audit trails</li> <li>Events include request context for security analysis</li> </ul>"},{"location":"api/events/#data-privacy","title":"Data Privacy","text":"<ul> <li>Sensitive fields can be excluded from audit logs</li> <li>Password fields are automatically excluded</li> <li>PII can be masked or hashed in event details</li> <li>Event retention policies can be implemented</li> </ul>"},{"location":"api/events/#performance-impact","title":"Performance Impact","text":"<ul> <li>Event logging is asynchronous where possible</li> <li>Failed event logging doesn't interrupt main operations</li> <li>Database indexes optimize event querying</li> <li>Cleanup routines prevent unbounded growth</li> </ul>"},{"location":"api/events/#error-handling","title":"Error Handling","text":"<p>The event system includes robust error handling:</p> <pre><code>try:\n    await event_service.log_event(...)\nexcept Exception as e:\n    # Event logging failure doesn't interrupt main operation\n    logger.error(f\"Event logging failed: {e}\")\n    # Continue with main business logic\n</code></pre>"},{"location":"api/events/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"api/events/#high-priority-events","title":"High-Priority Events","text":"<pre><code>await event_integration.log_security_event(\n    db=admin_db,\n    event_type=EventType.FAILED_LOGIN,\n    user_id=user.id,\n    session_id=session_id,\n    request=request,\n    details={\n        \"priority\": \"high\",\n        \"requires_attention\": True,\n        \"failed_attempts\": 5,\n        \"suspicious_activity\": True\n    }\n)\n</code></pre>"},{"location":"api/events/#event-metrics","title":"Event Metrics","text":"<p>Use event data for monitoring:</p> <ul> <li>Failed login attempt patterns</li> <li>Admin activity volume</li> <li>Resource modification frequency</li> <li>User behavior analysis</li> </ul> <p>The event system provides a complete audit trail for compliance, security monitoring, and operational insights into your CRUDAdmin instance. </p>"},{"location":"api/model_view/","title":"ModelView Class API Reference","text":""},{"location":"api/model_view/#class-definition","title":"Class Definition","text":"<p>View class for managing CRUD operations and UI for database models in FastAPI admin interface.</p> Features <ul> <li>Automatic form generation from Pydantic schemas</li> <li>List view with pagination, sorting, and filtering</li> <li>Create/update forms with validation</li> <li>Bulk delete operations</li> <li>Event logging integration</li> <li>HTMX-powered dynamic updates</li> </ul> <p>Parameters:</p> Name Type Description Default <code>database_config</code> <code>DatabaseConfig</code> <p>DatabaseConfig instance for DB connections</p> required <code>templates</code> <code>Jinja2Templates</code> <p>Jinja2Templates instance for rendering views</p> required <code>model</code> <code>Type[DeclarativeBase]</code> <p>SQLAlchemy model class to manage</p> required <code>allowed_actions</code> <code>Set[str]</code> <p>Set of allowed operations ('view', 'create', 'update', 'delete')</p> required <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for create operations</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for update operations</p> required <code>update_internal_schema</code> <code>Optional[Type[UpdateSchemaInternalType]]</code> <p>Optional internal schema for special update cases</p> <code>None</code> <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional schema for delete operations</p> <code>None</code> <code>select_schema</code> <code>Optional[Type[SelectSchemaType]]</code> <p>Optional schema for select operations</p> <code>None</code> <code>admin_model</code> <code>bool</code> <p>Whether this is an admin-specific model</p> <code>False</code> <code>admin_site</code> <code>Optional[Any]</code> <p>Reference to parent AdminSite instance</p> <code>None</code> <code>event_integration</code> <code>Optional[Any]</code> <p>Optional event logging integration</p> <code>None</code> <code>password_transformer</code> <code>Optional[PasswordTransformer]</code> <p>Optional password transformer for AdminUser model</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schemas don't match model structure</p> <code>TypeError</code> <p>If model is not a SQLAlchemy model</p> <code>RuntimeError</code> <p>If required dependencies are missing</p> Notes <ul> <li>Forms are auto-generated based on Pydantic schema definitions</li> <li>List views support server-side pagination and filtering</li> <li>Changes are tracked if event logging is enabled</li> <li>HTMX is used for dynamic content updates</li> <li>Templates can be customized by overriding defaults</li> </ul> URLs Generated <p>List View:     GET /{model_name}/ - Main list view with pagination     GET /{model_name}/get_model_list - HTMX-powered list content</p> <p>Create:     GET /{model_name}/create_page - Create form     POST /{model_name}/form_create - Handle create submission</p> <p>Update:     GET /{model_name}/update/{id} - Update form for specific record     POST /{model_name}/form_update/{id} - Handle update submission</p> <p>Delete:     DELETE /{model_name}/bulk-delete - Bulk delete selected records</p> <p>API Endpoints:     All CRUD operations also exposed as REST API endpoints under /crud/</p> Example <p>Basic model view setup: <pre><code>from pydantic import BaseModel, Field\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import DeclarativeBase\n\n# Define model\nclass User(DeclarativeBase):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    username = Column(String, unique=True)\n    email = Column(String)\n    role = Column(String)\n\n# Define schemas\nclass UserCreate(BaseModel):\n    username: str = Field(..., min_length=3)\n    email: str = Field(..., pattern=r\"[^@]+@[^@]+\\.[^@]+\")\n    role: str = Field(default=\"user\")\n\nclass UserUpdate(BaseModel):\n    email: Optional[str] = Field(None, pattern=r\"[^@]+@[^@]+\\.[^@]+\")\n    role: Optional[str] = None\n\n# Create view\nuser_view = ModelView(\n    database_config=db_config,\n    templates=templates,\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}\n)\n</code></pre></p> <p>Custom form validation: <pre><code>from datetime import datetime\nfrom decimal import Decimal\nfrom typing import Optional\nfrom pydantic import BaseModel, Field, validator\n\nclass OrderCreate(BaseModel):\n    customer_id: int\n    total: Decimal = Field(..., ge=0)\n    status: str = Field(default=\"pending\")\n    notes: Optional[str] = None\n\n    @validator(\"total\")\n    def validate_total(cls, v):\n        if v &gt; 1000000:\n            raise ValueError(\"Order total cannot exceed 1,000,000\")\n        return v\n\n    @validator(\"status\")\n    def validate_status(cls, v):\n        allowed = {\"pending\", \"paid\", \"shipped\", \"cancelled\"}\n        if v not in allowed:\n            raise ValueError(f\"Status must be one of: {allowed}\")\n        return v\n\nclass OrderUpdate(BaseModel):\n    status: Optional[str] = None\n    notes: Optional[str] = None\n\n    @validator(\"status\")\n    def validate_status(cls, v):\n        if v is not None:\n            allowed = {\"pending\", \"paid\", \"shipped\", \"cancelled\"}\n            if v not in allowed:\n                raise ValueError(f\"Status must be one of: {allowed}\")\n        return v\n\norder_view = ModelView(\n    database_config=db_config,\n    templates=templates,\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}\n)\n</code></pre></p> <p>Event logging integration: <pre><code>from typing import Optional\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\n\nclass ProductCreate(BaseModel):\n    name: str\n    price: float = Field(..., gt=0)\n    stock: int = Field(..., ge=0)\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = None\n    price: Optional[float] = Field(None, gt=0)\n    stock: Optional[int] = Field(None, ge=0)\n\n# With event logging\nproduct_view = ModelView(\n    database_config=db_config,\n    templates=templates,\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    event_integration=event_logger,  # Enable logging\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n\n# Events logged:\n# - Record creation with user info\n# - Updates with change details\n# - Deletions with record info\n# - View access for audit trails\n</code></pre></p> <p>Custom templates: <pre><code>templates = Jinja2Templates(directory=\"custom_templates\")\n\n# Override default templates\ncustom_templates = {\n    \"list\": \"custom/model/list.html\",\n    \"create\": \"custom/model/create.html\",\n    \"update\": \"custom/model/update.html\"\n}\n\nview = ModelView(\n    database_config=db_config,\n    templates=templates,  # Custom templates\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}\n)\n</code></pre></p> <p>Restricted actions: <pre><code># Read-only view\nreadonly_view = ModelView(\n    database_config=db_config,\n    templates=templates,\n    model=AuditLog,\n    create_schema=AuditLogSchema,\n    update_schema=AuditLogSchema,\n    allowed_actions={\"view\"}  # View only\n)\n\n# No delete view\nno_delete_view = ModelView(\n    database_config=db_config,\n    templates=templates,\n    model=Customer,\n    create_schema=CustomerCreate,\n    update_schema=CustomerUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No delete\n)\n</code></pre></p> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>class ModelView:\n    r\"\"\"\n    View class for managing CRUD operations and UI for database models in FastAPI admin interface.\n\n    Features:\n        - Automatic form generation from Pydantic schemas\n        - List view with pagination, sorting, and filtering\n        - Create/update forms with validation\n        - Bulk delete operations\n        - Event logging integration\n        - HTMX-powered dynamic updates\n\n    Args:\n        database_config: DatabaseConfig instance for DB connections\n        templates: Jinja2Templates instance for rendering views\n        model: SQLAlchemy model class to manage\n        allowed_actions: Set of allowed operations ('view', 'create', 'update', 'delete')\n        create_schema: Pydantic schema for create operations\n        update_schema: Pydantic schema for update operations\n        update_internal_schema: Optional internal schema for special update cases\n        delete_schema: Optional schema for delete operations\n        select_schema: Optional schema for select operations\n        admin_model: Whether this is an admin-specific model\n        admin_site: Reference to parent AdminSite instance\n        event_integration: Optional event logging integration\n        password_transformer: Optional password transformer for AdminUser model\n\n    Raises:\n        ValueError: If schemas don't match model structure\n        TypeError: If model is not a SQLAlchemy model\n        RuntimeError: If required dependencies are missing\n\n    Notes:\n        - Forms are auto-generated based on Pydantic schema definitions\n        - List views support server-side pagination and filtering\n        - Changes are tracked if event logging is enabled\n        - HTMX is used for dynamic content updates\n        - Templates can be customized by overriding defaults\n\n    URLs Generated:\n        **List View:**\n            GET /{model_name}/ - Main list view with pagination\n            GET /{model_name}/get_model_list - HTMX-powered list content\n\n        **Create:**\n            GET /{model_name}/create_page - Create form\n            POST /{model_name}/form_create - Handle create submission\n\n        **Update:**\n            GET /{model_name}/update/{id} - Update form for specific record\n            POST /{model_name}/form_update/{id} - Handle update submission\n\n        **Delete:**\n            DELETE /{model_name}/bulk-delete - Bulk delete selected records\n\n        **API Endpoints:**\n            All CRUD operations also exposed as REST API endpoints under /crud/\n\n    Example:\n        Basic model view setup:\n        ```python\n        from pydantic import BaseModel, Field\n        from sqlalchemy import Column, Integer, String\n        from sqlalchemy.ext.declarative import DeclarativeBase\n\n        # Define model\n        class User(DeclarativeBase):\n            __tablename__ = \"users\"\n            id = Column(Integer, primary_key=True)\n            username = Column(String, unique=True)\n            email = Column(String)\n            role = Column(String)\n\n        # Define schemas\n        class UserCreate(BaseModel):\n            username: str = Field(..., min_length=3)\n            email: str = Field(..., pattern=r\"[^@]+@[^@]+\\.[^@]+\")\n            role: str = Field(default=\"user\")\n\n        class UserUpdate(BaseModel):\n            email: Optional[str] = Field(None, pattern=r\"[^@]+@[^@]+\\.[^@]+\")\n            role: Optional[str] = None\n\n        # Create view\n        user_view = ModelView(\n            database_config=db_config,\n            templates=templates,\n            model=User,\n            create_schema=UserCreate,\n            update_schema=UserUpdate,\n            allowed_actions={\"view\", \"create\", \"update\"}\n        )\n        ```\n\n        Custom form validation:\n        ```python\n        from datetime import datetime\n        from decimal import Decimal\n        from typing import Optional\n        from pydantic import BaseModel, Field, validator\n\n        class OrderCreate(BaseModel):\n            customer_id: int\n            total: Decimal = Field(..., ge=0)\n            status: str = Field(default=\"pending\")\n            notes: Optional[str] = None\n\n            @validator(\"total\")\n            def validate_total(cls, v):\n                if v &gt; 1000000:\n                    raise ValueError(\"Order total cannot exceed 1,000,000\")\n                return v\n\n            @validator(\"status\")\n            def validate_status(cls, v):\n                allowed = {\"pending\", \"paid\", \"shipped\", \"cancelled\"}\n                if v not in allowed:\n                    raise ValueError(f\"Status must be one of: {allowed}\")\n                return v\n\n        class OrderUpdate(BaseModel):\n            status: Optional[str] = None\n            notes: Optional[str] = None\n\n            @validator(\"status\")\n            def validate_status(cls, v):\n                if v is not None:\n                    allowed = {\"pending\", \"paid\", \"shipped\", \"cancelled\"}\n                    if v not in allowed:\n                        raise ValueError(f\"Status must be one of: {allowed}\")\n                return v\n\n        order_view = ModelView(\n            database_config=db_config,\n            templates=templates,\n            model=Order,\n            create_schema=OrderCreate,\n            update_schema=OrderUpdate,\n            allowed_actions={\"view\", \"create\", \"update\"}\n        )\n        ```\n\n        Event logging integration:\n        ```python\n        from typing import Optional\n        from datetime import datetime\n        from pydantic import BaseModel, Field\n\n        class ProductCreate(BaseModel):\n            name: str\n            price: float = Field(..., gt=0)\n            stock: int = Field(..., ge=0)\n\n        class ProductUpdate(BaseModel):\n            name: Optional[str] = None\n            price: Optional[float] = Field(None, gt=0)\n            stock: Optional[int] = Field(None, ge=0)\n\n        # With event logging\n        product_view = ModelView(\n            database_config=db_config,\n            templates=templates,\n            model=Product,\n            create_schema=ProductCreate,\n            update_schema=ProductUpdate,\n            event_integration=event_logger,  # Enable logging\n            allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n        )\n\n        # Events logged:\n        # - Record creation with user info\n        # - Updates with change details\n        # - Deletions with record info\n        # - View access for audit trails\n        ```\n\n        Custom templates:\n        ```python\n        templates = Jinja2Templates(directory=\"custom_templates\")\n\n        # Override default templates\n        custom_templates = {\n            \"list\": \"custom/model/list.html\",\n            \"create\": \"custom/model/create.html\",\n            \"update\": \"custom/model/update.html\"\n        }\n\n        view = ModelView(\n            database_config=db_config,\n            templates=templates,  # Custom templates\n            model=User,\n            create_schema=UserCreate,\n            update_schema=UserUpdate,\n            allowed_actions={\"view\", \"create\", \"update\"}\n        )\n        ```\n\n        Restricted actions:\n        ```python\n        # Read-only view\n        readonly_view = ModelView(\n            database_config=db_config,\n            templates=templates,\n            model=AuditLog,\n            create_schema=AuditLogSchema,\n            update_schema=AuditLogSchema,\n            allowed_actions={\"view\"}  # View only\n        )\n\n        # No delete view\n        no_delete_view = ModelView(\n            database_config=db_config,\n            templates=templates,\n            model=Customer,\n            create_schema=CustomerCreate,\n            update_schema=CustomerUpdate,\n            allowed_actions={\"view\", \"create\", \"update\"}  # No delete\n        )\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        database_config: DatabaseConfig,\n        templates: Jinja2Templates,\n        model: Type[DeclarativeBase],\n        allowed_actions: Set[str],\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        update_internal_schema: Optional[Type[UpdateSchemaInternalType]] = None,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        select_schema: Optional[Type[SelectSchemaType]] = None,\n        admin_model: bool = False,\n        admin_site: Optional[Any] = None,\n        event_integration: Optional[Any] = None,\n        password_transformer: Optional[PasswordTransformer] = None,\n    ) -&gt; None:\n        self.db_config = database_config\n        self.templates = templates\n        self.model = model\n        self.model_key = model.__name__\n        self.router = APIRouter()\n\n        get_session: Callable[[], AsyncGenerator[AsyncSession, None]]\n        if self._model_is_admin_model(model):\n            get_session = self.db_config.get_admin_db\n        else:\n            get_session = cast(\n                Callable[[], AsyncGenerator[AsyncSession, None]], self.db_config.session\n            )\n        self.session = get_session\n\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.update_internal_schema = update_internal_schema\n        self.delete_schema = delete_schema\n        self.select_schema = select_schema\n\n        self.admin_model = admin_model\n        self.admin_site = admin_site\n        self.allowed_actions = allowed_actions\n        self.event_integration = event_integration\n        self.password_transformer = password_transformer\n\n        self.user_service = (\n            self.admin_site.admin_user_service if self.admin_site else None\n        )\n\n        if self.model.__name__ == \"AdminUser\" and password_transformer is None:\n            from ..core.auth import get_password_hash\n\n            self.password_transformer = PasswordTransformer(\n                password_field=\"password\",\n                hashed_field=\"hashed_password\",\n                hash_function=get_password_hash,\n                required_fields=[\"username\"],\n            )\n\n        self.crud: FastCRUD[Any, Any, Any, Any, Any, Any] = FastCRUD(self.model)\n\n        self.endpoints_template = EndpointCreator(\n            session=self.session,\n            model=self.model,\n            crud=self.crud,\n            create_schema=self.create_schema,\n            update_schema=self.update_schema,\n            delete_schema=self.delete_schema,\n        )\n        self.endpoints_template.add_routes_to_router()\n        self.router.include_router(self.endpoints_template.router, prefix=\"/crud\")\n\n        self.setup_routes()\n\n    def _model_is_admin_model(self, model: Type[DeclarativeBase]) -&gt; bool:\n        \"\"\"Check if the given model is one of the admin-specific models.\"\"\"\n        admin_model_names = [\n            self.db_config.AdminUser.__name__,\n            self.db_config.AdminSession.__name__,\n        ]\n        if self.db_config.AdminEventLog:\n            admin_model_names.append(self.db_config.AdminEventLog.__name__)\n        if self.db_config.AdminAuditLog:\n            admin_model_names.append(self.db_config.AdminAuditLog.__name__)\n\n        return model.__name__ in admin_model_names\n\n    def setup_routes(self) -&gt; None:\n        \"\"\"\n        Configure FastAPI routes based on allowed actions.\n\n        Sets up the following routes if allowed:\n        - Create: /form_create (POST), /create_page (GET)\n        - View: / (GET), /get_model_list (GET)\n        - Delete: /bulk-delete (DELETE)\n        - Update: /update/{id} (GET), /form_update/{id} (POST)\n\n        Routes are configured based on the allowed_actions set provided during initialization.\n        All routes use appropriate templates and include required dependencies.\n\n        Example:\n            ```python\n            # Configure with specific actions\n            view = ModelView(\n                allowed_actions={\"view\", \"create\", \"update\"},\n                ...\n            )\n            view.setup_routes()  # Only creates view/create/update routes\n            ```\n        \"\"\"\n        if \"create\" in self.allowed_actions:\n            self.router.add_api_route(\n                \"/form_create\",\n                self.form_create_endpoint(template=\"admin/model/create.html\"),\n                methods=[\"POST\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n            self.router.add_api_route(\n                \"/create_page\",\n                self.get_model_create_page(template=\"admin/model/create.html\"),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n\n        if \"view\" in self.allowed_actions:\n            self.router.add_api_route(\n                \"/\",\n                self.get_model_admin_page(),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n            self.router.add_api_route(\n                \"/get_model_list\",\n                self.get_model_admin_page(\n                    template=\"admin/model/components/list_content.html\"\n                ),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n\n        if \"delete\" in self.allowed_actions:\n            self.router.add_api_route(\n                \"/bulk-delete\",\n                self.bulk_delete_endpoint(),\n                methods=[\"DELETE\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n\n        if \"update\" in self.allowed_actions:\n            self.router.add_api_route(\n                \"/update/{id}\",\n                self.get_model_update_page(template=\"admin/model/update.html\"),\n                methods=[\"GET\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n            self.router.add_api_route(\n                \"/form_update/{id}\",\n                self.form_update_endpoint(),\n                methods=[\"POST\"],\n                include_in_schema=False,\n                response_model=None,\n            )\n\n    def form_create_endpoint(self, template: str) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for handling form submissions to create new model records.\n\n        Args:\n            template: Path to Jinja2 template for rendering form\n\n        Returns:\n            FastAPI route handler for create form submission\n\n        Features:\n            - Form data validation using create_schema\n            - Special handling for AdminUser model\n            - File upload support\n            - Field error collection\n            - Event logging integration\n            - HTMX support for dynamic updates\n\n        Notes:\n            - Uses @log_admin_action decorator for event tracking\n            - Handles both single and multi-value form fields\n            - Supports password hashing for AdminUser model\n\n        Example:\n            ```python\n            endpoint = view.form_create_endpoint(\"admin/model/create.html\")\n            router.add_api_route(\"/create\", endpoint, methods=[\"POST\"])\n            ```\n        \"\"\"\n\n        @log_admin_action(EventType.CREATE, model=self.model)\n        async def form_create_endpoint_inner(\n            request: Request,\n            db: AsyncSession = Depends(self.session),\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            current_user: dict = Depends(\n                cast(Any, self.admin_site).admin_authentication.get_current_user()\n            ),\n            event_integration=Depends(lambda: self.event_integration),\n        ) -&gt; Response:\n            \"\"\"Handle POST form submission to create a model record.\"\"\"\n            assert self.admin_site is not None\n\n            form_fields = _get_form_fields_from_schema(self.create_schema)\n            error_message: Optional[str] = None\n            field_errors: Dict[str, str] = {}\n            field_values: Dict[str, Any] = {}\n\n            try:\n                if request.method == \"POST\":\n                    form_data_raw = await request.form()\n                    form_data: Dict[str, Any] = {}\n\n                    for field in form_fields:\n                        key = field[\"name\"]\n                        raw_value = form_data_raw.getlist(key)\n                        if len(raw_value) == 1:\n                            value = raw_value[0]\n                            form_data[key] = value if value else field.get(\"default\")\n                            field_values[key] = value\n                        elif len(raw_value) &gt; 1:\n                            form_data[key] = raw_value\n                            field_values[key] = raw_value\n                        else:\n                            form_data[key] = field.get(\"default\")\n\n                    try:\n                        if self.password_transformer is not None:\n                            item_data = self.create_schema(**form_data)\n\n                            transformed_data = (\n                                self.password_transformer.transform_create_data(\n                                    form_data, item_data\n                                )\n                            )\n\n                            for (\n                                required_field\n                            ) in self.password_transformer.required_fields:\n                                if (\n                                    required_field not in transformed_data\n                                    or not transformed_data[required_field]\n                                ):\n                                    raise ValueError(\n                                        f\"{self.model.__name__} requires a {required_field}.\"\n                                    )\n\n                            if self.model.__name__ == \"AdminUser\":\n                                from ..admin_user.schemas import AdminUserCreateInternal\n\n                                admin_internal_data: AdminUserCreateInternal = (\n                                    AdminUserCreateInternal(**transformed_data)\n                                )\n                                result = await self.crud.create(\n                                    db=db, object=admin_internal_data\n                                )\n                            else:\n                                if self.update_internal_schema:\n                                    generic_internal_data = self.update_internal_schema(\n                                        **transformed_data\n                                    )\n                                    result = await self.crud.create(\n                                        db=db, object=generic_internal_data\n                                    )\n                                else:\n                                    dynamic_internal_data = type(\n                                        \"InternalSchema\", (BaseModel,), {}\n                                    )(**transformed_data)\n                                    result = await self.crud.create(\n                                        db=db, object=dynamic_internal_data\n                                    )\n\n                            await db.commit()\n                        else:\n                            item_data = self.create_schema(**form_data)\n                            result = await self.crud.create(db=db, object=item_data)\n                            await db.commit()\n\n                        if result:\n                            request.state.crud_result = result\n                            if \"HX-Request\" in request.headers:\n                                return RedirectResponse(\n                                    url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                                    headers={\n                                        \"HX-Redirect\": f\"/{self.admin_site.mount_path}/{self.model.__name__}/\"\n                                    },\n                                )\n                            return RedirectResponse(\n                                url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                                status_code=303,\n                            )\n\n                    except ValidationError as e:\n                        field_errors = {\n                            str(err[\"loc\"][0]): err[\"msg\"] for err in e.errors()\n                        }\n                        error_message = \"Please correct the errors below.\"\n                    except Exception as e:\n                        error_message = str(e)\n\n            except Exception as e:\n                error_message = str(e)\n\n            context = {\n                \"request\": request,\n                \"model_name\": self.model_key,\n                \"form_fields\": form_fields,\n                \"error\": error_message,\n                \"field_errors\": field_errors,\n                \"field_values\": field_values,\n                \"mount_path\": self.admin_site.mount_path,\n            }\n\n            return self.templates.TemplateResponse(\n                template, context, status_code=422 if error_message else 200\n            )\n\n        return cast(EndpointCallable, form_create_endpoint_inner)\n\n    def bulk_delete_endpoint(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for bulk deletion of model records.\n\n        Returns:\n            FastAPI route handler for bulk delete operations\n\n        Features:\n            - Handles multiple record deletion in one request\n            - Supports different primary key types (int, str, float)\n            - Validates IDs before deletion\n            - Handles pagination after deletion\n            - Event logging integration\n            - Transaction management\n\n        Notes:\n            - Expects JSON payload with \"ids\" list\n            - Performs type conversion based on primary key type\n            - Maintains pagination state after deletion\n            - Rolls back transaction on error\n\n        Example:\n            ```python\n            # Delete multiple records\n            await client.delete(\"/bulk-delete\", json={\"ids\": [1, 2, 3]})\n            ```\n\n        Response Formats:\n            **Success:**\n                - Returns updated list content template\n                - Status: 200 OK\n\n            **Errors:**\n                - 400: No IDs provided\n                - 422: Invalid ID format\n                - 400: Database error during deletion\n        \"\"\"\n\n        @log_admin_action(EventType.DELETE, model=self.model)\n        async def bulk_delete_endpoint_inner(\n            request: Request,\n            db: AsyncSession = Depends(self.session),\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            current_user: dict = Depends(\n                cast(Any, self.admin_site).admin_authentication.get_current_user()\n            ),\n            event_integration=Depends(lambda: self.event_integration),\n        ) -&gt; Response:\n            \"\"\"Handle bulk deletion of model instances using JSON list of IDs.\"\"\"\n            assert self.admin_site is not None\n            try:\n                body = await request.json()\n\n                page_str = request.query_params.get(\"page\", \"1\")\n                rows_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n                page = int(page_str)\n                rows_per_page = int(rows_str)\n\n                ids = body.get(\"ids\", [])\n                if not ids:\n                    return JSONResponse(\n                        status_code=400,\n                        content={\n                            \"detail\": [{\"message\": \"No IDs provided for deletion\"}]\n                        },\n                    )\n\n                inspector = inspect(self.model)\n                primary_key = inspector.primary_key[0]\n                pk_name = primary_key.name\n                pk_type = primary_key.type.python_type\n\n                valid_ids: List[Union[int, str, float]] = []\n                for id_value in ids:\n                    try:\n                        if pk_type is int:\n                            valid_ids.append(int(id_value))\n                        elif pk_type is str:\n                            valid_ids.append(str(id_value))\n                        elif pk_type is float:\n                            valid_ids.append(float(id_value))\n                        else:\n                            valid_ids.append(id_value)\n                    except (ValueError, TypeError):\n                        return JSONResponse(\n                            status_code=422,\n                            content={\n                                \"detail\": [{\"message\": f\"Invalid ID value: {id_value}\"}]\n                            },\n                        )\n\n                filter_criteria: Dict[str, List[Union[int, str, float]]] = {\n                    f\"{pk_name}__in\": valid_ids\n                }\n                records_to_delete = await self.crud.get_multi(\n                    db=db, limit=len(valid_ids), **cast(Any, filter_criteria)\n                )\n\n                request.state.deleted_records = records_to_delete.get(\"data\", [])\n\n                try:\n                    for id_value in valid_ids:\n                        await self.crud.delete(\n                            db=db,\n                            db_row=None,\n                            commit=False,\n                            allow_multiple=False,\n                            **{pk_name: id_value},\n                        )\n                    await db.commit()\n                except Exception as e:\n                    await db.rollback()\n                    return JSONResponse(\n                        status_code=400,\n                        content={\n                            \"detail\": [{\"message\": f\"Error during deletion: {str(e)}\"}]\n                        },\n                    )\n\n                total_count = await self.crud.count(db=db)\n                max_page = (total_count + rows_per_page - 1) // rows_per_page\n                adjusted_page = min(page, max(1, max_page))\n\n                items_result = await self.crud.get_multi(\n                    db=db,\n                    offset=(adjusted_page - 1) * rows_per_page,\n                    limit=rows_per_page,\n                )\n\n                items: Dict[str, Any] = {\n                    \"data\": items_result.get(\"data\", []),\n                    \"total_count\": items_result.get(\"total_count\", 0),\n                }\n\n                table_columns = [column.key for column in self.model.__table__.columns]\n                primary_key_info = self.db_config.get_primary_key_info(self.model)\n\n                context: Dict[str, Any] = {\n                    \"request\": request,\n                    \"model_items\": items[\"data\"],\n                    \"model_name\": self.model_key,\n                    \"table_columns\": table_columns,\n                    \"total_items\": items[\"total_count\"],\n                    \"current_page\": adjusted_page,\n                    \"rows_per_page\": rows_per_page,\n                    \"primary_key_info\": primary_key_info,\n                    \"mount_path\": self.admin_site.mount_path,\n                }\n\n                return self.templates.TemplateResponse(\n                    \"admin/model/components/list_content.html\", context\n                )\n\n            except ValueError as e:\n                return JSONResponse(\n                    status_code=422, content={\"detail\": [{\"message\": str(e)}]}\n                )\n            except Exception as e:\n                return JSONResponse(\n                    status_code=422,\n                    content={\n                        \"detail\": [{\"message\": f\"Error processing request: {str(e)}\"}]\n                    },\n                )\n\n        return cast(EndpointCallable, bulk_delete_endpoint_inner)\n\n    def get_model_admin_page(\n        self, template: str = \"admin/model/list.html\"\n    ) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for model list view with filtering and pagination.\n\n        Args:\n            template: Path to Jinja2 template for rendering list view\n\n        Returns:\n            FastAPI route handler for model list page\n\n        Example:\n            ```python\n            # Basic list view\n            response = await client.get(\"/?page=1&amp;rows-per-page-select=25\")\n\n            # Sorted and filtered\n            response = await client.get(\n                \"/?sort_by=username&amp;sort_order=desc&amp;column-to-search=email&amp;search-input=example.com\"\n            )\n            ```\n        \"\"\"\n\n        async def get_model_admin_page_inner(\n            request: Request,\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            app_db: AsyncSession = Depends(\n                cast(\n                    Callable[..., AsyncGenerator[AsyncSession, None]],\n                    self.db_config.get_app_session(),\n                )\n            ),\n        ) -&gt; Response:\n            \"\"\"Display the model list page, allowing pagination, sorting, and searching.\"\"\"\n            if self._model_is_admin_model(self.model):\n                db = admin_db\n            else:\n                db = app_db\n\n            if template == \"admin/model/list.html\" and not request.url.path.endswith(\n                \"/\"\n            ):\n                redirect_url = request.url.path + \"/\"\n                if request.url.query:\n                    redirect_url += \"?\" + request.url.query\n                return RedirectResponse(redirect_url, status_code=307)\n\n            try:\n                page = max(1, int(request.query_params.get(\"page\", \"1\")))\n                rows_per_page = int(\n                    request.query_params.get(\"rows-per-page-select\", \"10\")\n                )\n            except ValueError:\n                page = 1\n                rows_per_page = 10\n\n            sort_column = request.query_params.get(\"sort_by\")\n            sort_order = request.query_params.get(\"sort_order\", \"asc\")\n\n            sort_columns = (\n                [sort_column] if sort_column and sort_column != \"None\" else None\n            )\n            sort_orders = [sort_order] if sort_order and sort_order != \"None\" else None\n\n            search_column = request.query_params.get(\"column-to-search\")\n            search_value = request.query_params.get(\"search-input\", \"\").strip()\n\n            filter_criteria: Dict[str, Any] = {}\n            if search_column and search_value:\n                column = self.model.__table__.columns.get(search_column)\n                if column is not None:\n                    python_type = column.type.python_type\n                    try:\n                        if python_type is int:\n                            filter_criteria[search_column] = int(search_value)\n                        elif python_type is float:\n                            filter_criteria[search_column] = float(search_value)\n                        elif python_type is bool:\n                            lower_search = search_value.lower()\n                            if lower_search in (\"true\", \"yes\", \"1\", \"t\", \"y\"):\n                                filter_criteria[search_column] = True\n                            elif lower_search in (\"false\", \"no\", \"0\", \"f\", \"n\"):\n                                filter_criteria[search_column] = False\n                        elif python_type is str:\n                            filter_criteria[f\"{search_column}__ilike\"] = (\n                                f\"%{search_value}%\"\n                            )\n                    except (ValueError, TypeError):\n                        pass\n\n            try:\n                total_items = await self.crud.count(db=db, **cast(Any, filter_criteria))\n                max_page = max(1, (total_items + rows_per_page - 1) // rows_per_page)\n                page = min(page, max_page)\n                offset = (page - 1) * rows_per_page\n\n                items_result = await self.crud.get_multi(\n                    db=db,\n                    offset=offset,\n                    limit=rows_per_page,\n                    sort_columns=sort_columns,\n                    sort_orders=sort_orders,\n                    **cast(Any, filter_criteria),\n                )\n\n                items: Dict[str, Any] = {\n                    \"data\": items_result.get(\"data\", []),\n                    \"total_count\": items_result.get(\"total_count\", 0),\n                }\n\n            except Exception:\n                items = {\"data\": [], \"total_count\": 0}\n                total_items = 0\n                page = 1\n\n            table_columns = [column.key for column in self.model.__table__.columns]\n            primary_key_info = self.db_config.get_primary_key_info(self.model)\n\n            context: Dict[str, Any] = {\n                \"request\": request,\n                \"model_items\": items[\"data\"],\n                \"model_name\": self.model_key,\n                \"table_columns\": table_columns,\n                \"total_items\": items[\"total_count\"],\n                \"current_page\": page,\n                \"rows_per_page\": rows_per_page,\n                \"selected_column\": search_column,\n                \"primary_key_info\": primary_key_info,\n                \"mount_path\": self.admin_site.mount_path if self.admin_site else \"\",\n                \"sort_column\": sort_column,\n                \"sort_order\": sort_order,\n                \"allowed_actions\": self.allowed_actions,\n            }\n\n            if \"HX-Request\" in request.headers:\n                return self.templates.TemplateResponse(\n                    \"admin/model/components/list_content.html\", context\n                )\n\n            if self.admin_site is not None:\n                base_context = await self.admin_site.get_base_context(\n                    admin_db=admin_db, app_db=app_db\n                )\n                context.update(base_context)\n                context[\"include_sidebar_and_header\"] = True\n\n            return self.templates.TemplateResponse(template, context)\n\n        return cast(EndpointCallable, get_model_admin_page_inner)\n\n    def get_model_create_page(\n        self, template: str = \"admin/model/create.html\"\n    ) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for displaying new record creation form.\n\n        Args:\n            template: Path to Jinja2 template for rendering create form\n\n        Returns:\n            FastAPI route handler for create form page\n\n        Example:\n            ```python\n            endpoint = view.get_model_create_page(\"admin/model/create.html\")\n            router.add_api_route(\"/create\", endpoint, methods=[\"GET\"])\n            ```\n        \"\"\"\n\n        async def model_create_page(request: Request) -&gt; Response:\n            \"\"\"Show a blank form for creating a new record.\"\"\"\n            form_fields = _get_form_fields_from_schema(self.create_schema)\n            mount_path = self.admin_site.mount_path if self.admin_site else \"\"\n            return self.templates.TemplateResponse(\n                template,\n                {\n                    \"request\": request,\n                    \"model_name\": self.model_key,\n                    \"form_fields\": form_fields,\n                    \"mount_path\": mount_path,\n                },\n            )\n\n        return cast(EndpointCallable, model_create_page)\n\n    def get_model_update_page(self, template: str) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for displaying record update form.\n\n        Args:\n            template: Path to Jinja2 template for rendering update form\n\n        Returns:\n            FastAPI route handler for update form page\n\n        Example:\n            ```python\n            endpoint = view.get_model_update_page(\"admin/model/update.html\")\n            router.add_api_route(\"/update/{id}\", endpoint, methods=[\"GET\"])\n            ```\n        \"\"\"\n\n        async def get_model_update_page_inner(\n            request: Request,\n            id: int,\n            db: AsyncSession = Depends(self.session),\n        ) -&gt; Response:\n            \"\"\"Show a form to update an existing record by `id`.\"\"\"\n            item = await self.crud.get(db=db, id=id)\n            if not item:\n                return JSONResponse(\n                    status_code=404, content={\"message\": f\"Item with id {id} not found\"}\n                )\n\n            form_fields = _get_form_fields_from_schema(self.update_schema)\n            for field in form_fields:\n                field_name = field[\"name\"]\n                if field_name in item:\n                    field[\"value\"] = item[field_name]\n\n            mount_path = self.admin_site.mount_path if self.admin_site else \"\"\n            return self.templates.TemplateResponse(\n                template,\n                {\n                    \"request\": request,\n                    \"model_name\": self.model_key,\n                    \"form_fields\": form_fields,\n                    \"mount_path\": mount_path,\n                    \"id\": id,\n                },\n            )\n\n        return cast(EndpointCallable, get_model_update_page_inner)\n\n    def form_update_endpoint(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for handling form submissions to update existing records.\n\n        Returns:\n            FastAPI route handler for update form submission\n\n        Notes:\n            - Uses @log_admin_action decorator for event tracking\n            - Only updates provided fields\n            - Handles password hashing for AdminUser model\n            - Supports automatic updated_at timestamp\n        \"\"\"\n\n        @log_admin_action(EventType.UPDATE, model=self.model)\n        async def form_update_endpoint_inner(\n            request: Request,\n            db: AsyncSession = Depends(self.session),\n            admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n            current_user: dict = Depends(\n                cast(Any, self.admin_site).admin_authentication.get_current_user()\n            ),\n            event_integration=Depends(lambda: self.event_integration),\n            id: Optional[int] = None,\n        ) -&gt; Response:\n            \"\"\"Handle POST form submission to update an existing record.\"\"\"\n            assert self.admin_site is not None\n\n            if id is None:\n                return JSONResponse(\n                    status_code=422, content={\"message\": \"No id parameter provided\"}\n                )\n\n            item = await self.crud.get(db=db, id=id)\n            if not item:\n                return JSONResponse(\n                    status_code=404, content={\"message\": f\"Item with id {id} not found\"}\n                )\n\n            form_fields = _get_form_fields_from_schema(self.update_schema)\n            error_message: Optional[str] = None\n            field_errors: Dict[str, str] = {}\n            field_values: Dict[str, Any] = {}\n\n            try:\n                form_data = await request.form()\n                update_data: Dict[str, Any] = {}\n                has_updates = False\n\n                for key, raw_val in form_data.items():\n                    if isinstance(raw_val, UploadFile):\n                        field_values[key] = raw_val\n                        update_data[key] = raw_val\n                        has_updates = True\n                    elif isinstance(raw_val, str):\n                        val_str = raw_val.strip()\n                        if val_str:\n                            update_data[key] = val_str\n                            field_values[key] = val_str\n                            has_updates = True\n\n                if not has_updates:\n                    error_message = \"No changes were provided for update\"\n                else:\n                    if self.update_internal_schema is not None and hasattr(\n                        self.update_internal_schema, \"__fields__\"\n                    ):\n                        fields_dict = cast(\n                            Dict[str, Any], self.update_internal_schema.__fields__\n                        )\n                        if \"updated_at\" in fields_dict:\n                            update_data[\"updated_at\"] = dt.now(datetime.UTC)\n\n                    try:\n                        if self.password_transformer is not None:\n                            update_schema_instance = self.update_schema(**update_data)\n\n                            transformed_data = (\n                                self.password_transformer.transform_update_data(\n                                    update_data, update_schema_instance\n                                )\n                            )\n\n                            if self.model.__name__ == \"AdminUser\":\n                                from ..admin_user.schemas import AdminUserUpdateInternal\n\n                                admin_update_schema: AdminUserUpdateInternal = (\n                                    AdminUserUpdateInternal(**transformed_data)\n                                )\n                                await self.crud.update(\n                                    db=db, id=id, object=admin_update_schema\n                                )\n                            else:\n                                if self.update_internal_schema:\n                                    generic_update_schema = self.update_internal_schema(\n                                        **transformed_data\n                                    )\n                                    await self.crud.update(\n                                        db=db, id=id, object=generic_update_schema\n                                    )\n                                else:\n                                    dynamic_update_schema = type(\n                                        \"InternalSchema\", (BaseModel,), {}\n                                    )(**transformed_data)\n                                    await self.crud.update(\n                                        db=db, id=id, object=dynamic_update_schema\n                                    )\n\n                            await db.commit()\n                        else:\n                            update_schema_instance = self.update_schema(**update_data)\n                            await self.crud.update(\n                                db=db, id=id, object=update_schema_instance\n                            )\n                            await db.commit()\n\n                        return RedirectResponse(\n                            url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                            status_code=303,\n                        )\n\n                    except ValidationError as e:\n                        field_errors = {\n                            str(err[\"loc\"][0]): err[\"msg\"] for err in e.errors()\n                        }\n                        error_message = \"Please correct the errors below.\"\n                    except Exception as e:\n                        error_message = str(e)\n\n            except Exception as e:\n                error_message = str(e)\n\n            for field in form_fields:\n                field_name = field[\"name\"]\n                if field_name not in field_values and field_name in item:\n                    field_values[field_name] = item[field_name]\n\n            context: Dict[str, Any] = {\n                \"request\": request,\n                \"model_name\": self.model_key,\n                \"form_fields\": form_fields,\n                \"error\": error_message,\n                \"field_errors\": field_errors,\n                \"field_values\": field_values,\n                \"mount_path\": self.admin_site.mount_path,\n                \"id\": id,\n                \"include_sidebar_and_header\": False,\n            }\n\n            return self.templates.TemplateResponse(\n                \"admin/model/update.html\",\n                context,\n                status_code=400 if error_message else 200,\n            )\n\n        return cast(EndpointCallable, form_update_endpoint_inner)\n\n    def table_body_content(self) -&gt; EndpointCallable:\n        \"\"\"\n        Create endpoint for HTMX-powered table content updates.\n\n        Returns:\n            FastAPI route handler for table content partial\n\n        Query Parameters:\n            - page: Page number (default: 1)\n            - rows-per-page-select: Records per page (default: 10)\n            - column-to-search: Column to search in\n            - search: Search term\n\n        Example:\n            ```python\n            # HTMX request for filtered content\n            response = await client.get(\n                \"/table-content?page=2&amp;column-to-search=name&amp;search=test\",\n                headers={\"HX-Request\": \"true\"}\n            )\n            ```\n        \"\"\"\n\n        async def table_body_content_inner(\n            request: Request,\n            db: AsyncSession = Depends(self.session),\n        ) -&gt; Response:\n            \"\"\"Return HTMX partial for table content with pagination/search.\"\"\"\n            page_str = request.query_params.get(\"page\", \"1\")\n            limit_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n\n            try:\n                page = int(page_str)\n                limit = int(limit_str)\n            except ValueError:\n                page = 1\n                limit = 10\n\n            offset = (page - 1) * limit\n            search_column = request.query_params.get(\"column-to-search\")\n            search_value = request.query_params.get(\"search\", \"\")\n\n            filter_criteria: Dict[str, Any] = {}\n            if search_column and search_value:\n                filter_criteria[f\"{search_column}__ilike\"] = f\"%{search_value}%\"\n\n            items_result = await self.crud.get_multi(\n                db=db, offset=offset, limit=limit, **cast(Any, filter_criteria)\n            )\n\n            items: Dict[str, Any] = {\n                \"data\": items_result.get(\"data\", []),\n                \"total_count\": items_result.get(\"total_count\", 0),\n            }\n\n            total_items = items[\"total_count\"]\n            total_pages = (total_items + limit - 1) // limit\n\n            return self.templates.TemplateResponse(\n                \"model/components/table_content.html\",\n                {\n                    \"request\": request,\n                    \"model_items\": items[\"data\"],\n                    \"current_page\": page,\n                    \"rows_per_page\": limit,\n                    \"total_items\": total_items,\n                    \"total_pages\": total_pages,\n                },\n            )\n\n        return cast(EndpointCallable, table_body_content_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.bulk_delete_endpoint","title":"<code>bulk_delete_endpoint()</code>","text":"<p>Create endpoint for bulk deletion of model records.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for bulk delete operations</p> Features <ul> <li>Handles multiple record deletion in one request</li> <li>Supports different primary key types (int, str, float)</li> <li>Validates IDs before deletion</li> <li>Handles pagination after deletion</li> <li>Event logging integration</li> <li>Transaction management</li> </ul> Notes <ul> <li>Expects JSON payload with \"ids\" list</li> <li>Performs type conversion based on primary key type</li> <li>Maintains pagination state after deletion</li> <li>Rolls back transaction on error</li> </ul> Example <pre><code># Delete multiple records\nawait client.delete(\"/bulk-delete\", json={\"ids\": [1, 2, 3]})\n</code></pre> Response Formats <p>Success:     - Returns updated list content template     - Status: 200 OK</p> <p>Errors:     - 400: No IDs provided     - 422: Invalid ID format     - 400: Database error during deletion</p> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def bulk_delete_endpoint(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for bulk deletion of model records.\n\n    Returns:\n        FastAPI route handler for bulk delete operations\n\n    Features:\n        - Handles multiple record deletion in one request\n        - Supports different primary key types (int, str, float)\n        - Validates IDs before deletion\n        - Handles pagination after deletion\n        - Event logging integration\n        - Transaction management\n\n    Notes:\n        - Expects JSON payload with \"ids\" list\n        - Performs type conversion based on primary key type\n        - Maintains pagination state after deletion\n        - Rolls back transaction on error\n\n    Example:\n        ```python\n        # Delete multiple records\n        await client.delete(\"/bulk-delete\", json={\"ids\": [1, 2, 3]})\n        ```\n\n    Response Formats:\n        **Success:**\n            - Returns updated list content template\n            - Status: 200 OK\n\n        **Errors:**\n            - 400: No IDs provided\n            - 422: Invalid ID format\n            - 400: Database error during deletion\n    \"\"\"\n\n    @log_admin_action(EventType.DELETE, model=self.model)\n    async def bulk_delete_endpoint_inner(\n        request: Request,\n        db: AsyncSession = Depends(self.session),\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        current_user: dict = Depends(\n            cast(Any, self.admin_site).admin_authentication.get_current_user()\n        ),\n        event_integration=Depends(lambda: self.event_integration),\n    ) -&gt; Response:\n        \"\"\"Handle bulk deletion of model instances using JSON list of IDs.\"\"\"\n        assert self.admin_site is not None\n        try:\n            body = await request.json()\n\n            page_str = request.query_params.get(\"page\", \"1\")\n            rows_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n            page = int(page_str)\n            rows_per_page = int(rows_str)\n\n            ids = body.get(\"ids\", [])\n            if not ids:\n                return JSONResponse(\n                    status_code=400,\n                    content={\n                        \"detail\": [{\"message\": \"No IDs provided for deletion\"}]\n                    },\n                )\n\n            inspector = inspect(self.model)\n            primary_key = inspector.primary_key[0]\n            pk_name = primary_key.name\n            pk_type = primary_key.type.python_type\n\n            valid_ids: List[Union[int, str, float]] = []\n            for id_value in ids:\n                try:\n                    if pk_type is int:\n                        valid_ids.append(int(id_value))\n                    elif pk_type is str:\n                        valid_ids.append(str(id_value))\n                    elif pk_type is float:\n                        valid_ids.append(float(id_value))\n                    else:\n                        valid_ids.append(id_value)\n                except (ValueError, TypeError):\n                    return JSONResponse(\n                        status_code=422,\n                        content={\n                            \"detail\": [{\"message\": f\"Invalid ID value: {id_value}\"}]\n                        },\n                    )\n\n            filter_criteria: Dict[str, List[Union[int, str, float]]] = {\n                f\"{pk_name}__in\": valid_ids\n            }\n            records_to_delete = await self.crud.get_multi(\n                db=db, limit=len(valid_ids), **cast(Any, filter_criteria)\n            )\n\n            request.state.deleted_records = records_to_delete.get(\"data\", [])\n\n            try:\n                for id_value in valid_ids:\n                    await self.crud.delete(\n                        db=db,\n                        db_row=None,\n                        commit=False,\n                        allow_multiple=False,\n                        **{pk_name: id_value},\n                    )\n                await db.commit()\n            except Exception as e:\n                await db.rollback()\n                return JSONResponse(\n                    status_code=400,\n                    content={\n                        \"detail\": [{\"message\": f\"Error during deletion: {str(e)}\"}]\n                    },\n                )\n\n            total_count = await self.crud.count(db=db)\n            max_page = (total_count + rows_per_page - 1) // rows_per_page\n            adjusted_page = min(page, max(1, max_page))\n\n            items_result = await self.crud.get_multi(\n                db=db,\n                offset=(adjusted_page - 1) * rows_per_page,\n                limit=rows_per_page,\n            )\n\n            items: Dict[str, Any] = {\n                \"data\": items_result.get(\"data\", []),\n                \"total_count\": items_result.get(\"total_count\", 0),\n            }\n\n            table_columns = [column.key for column in self.model.__table__.columns]\n            primary_key_info = self.db_config.get_primary_key_info(self.model)\n\n            context: Dict[str, Any] = {\n                \"request\": request,\n                \"model_items\": items[\"data\"],\n                \"model_name\": self.model_key,\n                \"table_columns\": table_columns,\n                \"total_items\": items[\"total_count\"],\n                \"current_page\": adjusted_page,\n                \"rows_per_page\": rows_per_page,\n                \"primary_key_info\": primary_key_info,\n                \"mount_path\": self.admin_site.mount_path,\n            }\n\n            return self.templates.TemplateResponse(\n                \"admin/model/components/list_content.html\", context\n            )\n\n        except ValueError as e:\n            return JSONResponse(\n                status_code=422, content={\"detail\": [{\"message\": str(e)}]}\n            )\n        except Exception as e:\n            return JSONResponse(\n                status_code=422,\n                content={\n                    \"detail\": [{\"message\": f\"Error processing request: {str(e)}\"}]\n                },\n            )\n\n    return cast(EndpointCallable, bulk_delete_endpoint_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.form_create_endpoint","title":"<code>form_create_endpoint(template)</code>","text":"<p>Create endpoint for handling form submissions to create new model records.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Path to Jinja2 template for rendering form</p> required <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for create form submission</p> Features <ul> <li>Form data validation using create_schema</li> <li>Special handling for AdminUser model</li> <li>File upload support</li> <li>Field error collection</li> <li>Event logging integration</li> <li>HTMX support for dynamic updates</li> </ul> Notes <ul> <li>Uses @log_admin_action decorator for event tracking</li> <li>Handles both single and multi-value form fields</li> <li>Supports password hashing for AdminUser model</li> </ul> Example <pre><code>endpoint = view.form_create_endpoint(\"admin/model/create.html\")\nrouter.add_api_route(\"/create\", endpoint, methods=[\"POST\"])\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def form_create_endpoint(self, template: str) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for handling form submissions to create new model records.\n\n    Args:\n        template: Path to Jinja2 template for rendering form\n\n    Returns:\n        FastAPI route handler for create form submission\n\n    Features:\n        - Form data validation using create_schema\n        - Special handling for AdminUser model\n        - File upload support\n        - Field error collection\n        - Event logging integration\n        - HTMX support for dynamic updates\n\n    Notes:\n        - Uses @log_admin_action decorator for event tracking\n        - Handles both single and multi-value form fields\n        - Supports password hashing for AdminUser model\n\n    Example:\n        ```python\n        endpoint = view.form_create_endpoint(\"admin/model/create.html\")\n        router.add_api_route(\"/create\", endpoint, methods=[\"POST\"])\n        ```\n    \"\"\"\n\n    @log_admin_action(EventType.CREATE, model=self.model)\n    async def form_create_endpoint_inner(\n        request: Request,\n        db: AsyncSession = Depends(self.session),\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        current_user: dict = Depends(\n            cast(Any, self.admin_site).admin_authentication.get_current_user()\n        ),\n        event_integration=Depends(lambda: self.event_integration),\n    ) -&gt; Response:\n        \"\"\"Handle POST form submission to create a model record.\"\"\"\n        assert self.admin_site is not None\n\n        form_fields = _get_form_fields_from_schema(self.create_schema)\n        error_message: Optional[str] = None\n        field_errors: Dict[str, str] = {}\n        field_values: Dict[str, Any] = {}\n\n        try:\n            if request.method == \"POST\":\n                form_data_raw = await request.form()\n                form_data: Dict[str, Any] = {}\n\n                for field in form_fields:\n                    key = field[\"name\"]\n                    raw_value = form_data_raw.getlist(key)\n                    if len(raw_value) == 1:\n                        value = raw_value[0]\n                        form_data[key] = value if value else field.get(\"default\")\n                        field_values[key] = value\n                    elif len(raw_value) &gt; 1:\n                        form_data[key] = raw_value\n                        field_values[key] = raw_value\n                    else:\n                        form_data[key] = field.get(\"default\")\n\n                try:\n                    if self.password_transformer is not None:\n                        item_data = self.create_schema(**form_data)\n\n                        transformed_data = (\n                            self.password_transformer.transform_create_data(\n                                form_data, item_data\n                            )\n                        )\n\n                        for (\n                            required_field\n                        ) in self.password_transformer.required_fields:\n                            if (\n                                required_field not in transformed_data\n                                or not transformed_data[required_field]\n                            ):\n                                raise ValueError(\n                                    f\"{self.model.__name__} requires a {required_field}.\"\n                                )\n\n                        if self.model.__name__ == \"AdminUser\":\n                            from ..admin_user.schemas import AdminUserCreateInternal\n\n                            admin_internal_data: AdminUserCreateInternal = (\n                                AdminUserCreateInternal(**transformed_data)\n                            )\n                            result = await self.crud.create(\n                                db=db, object=admin_internal_data\n                            )\n                        else:\n                            if self.update_internal_schema:\n                                generic_internal_data = self.update_internal_schema(\n                                    **transformed_data\n                                )\n                                result = await self.crud.create(\n                                    db=db, object=generic_internal_data\n                                )\n                            else:\n                                dynamic_internal_data = type(\n                                    \"InternalSchema\", (BaseModel,), {}\n                                )(**transformed_data)\n                                result = await self.crud.create(\n                                    db=db, object=dynamic_internal_data\n                                )\n\n                        await db.commit()\n                    else:\n                        item_data = self.create_schema(**form_data)\n                        result = await self.crud.create(db=db, object=item_data)\n                        await db.commit()\n\n                    if result:\n                        request.state.crud_result = result\n                        if \"HX-Request\" in request.headers:\n                            return RedirectResponse(\n                                url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                                headers={\n                                    \"HX-Redirect\": f\"/{self.admin_site.mount_path}/{self.model.__name__}/\"\n                                },\n                            )\n                        return RedirectResponse(\n                            url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                            status_code=303,\n                        )\n\n                except ValidationError as e:\n                    field_errors = {\n                        str(err[\"loc\"][0]): err[\"msg\"] for err in e.errors()\n                    }\n                    error_message = \"Please correct the errors below.\"\n                except Exception as e:\n                    error_message = str(e)\n\n        except Exception as e:\n            error_message = str(e)\n\n        context = {\n            \"request\": request,\n            \"model_name\": self.model_key,\n            \"form_fields\": form_fields,\n            \"error\": error_message,\n            \"field_errors\": field_errors,\n            \"field_values\": field_values,\n            \"mount_path\": self.admin_site.mount_path,\n        }\n\n        return self.templates.TemplateResponse(\n            template, context, status_code=422 if error_message else 200\n        )\n\n    return cast(EndpointCallable, form_create_endpoint_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.form_update_endpoint","title":"<code>form_update_endpoint()</code>","text":"<p>Create endpoint for handling form submissions to update existing records.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for update form submission</p> Notes <ul> <li>Uses @log_admin_action decorator for event tracking</li> <li>Only updates provided fields</li> <li>Handles password hashing for AdminUser model</li> <li>Supports automatic updated_at timestamp</li> </ul> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def form_update_endpoint(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for handling form submissions to update existing records.\n\n    Returns:\n        FastAPI route handler for update form submission\n\n    Notes:\n        - Uses @log_admin_action decorator for event tracking\n        - Only updates provided fields\n        - Handles password hashing for AdminUser model\n        - Supports automatic updated_at timestamp\n    \"\"\"\n\n    @log_admin_action(EventType.UPDATE, model=self.model)\n    async def form_update_endpoint_inner(\n        request: Request,\n        db: AsyncSession = Depends(self.session),\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        current_user: dict = Depends(\n            cast(Any, self.admin_site).admin_authentication.get_current_user()\n        ),\n        event_integration=Depends(lambda: self.event_integration),\n        id: Optional[int] = None,\n    ) -&gt; Response:\n        \"\"\"Handle POST form submission to update an existing record.\"\"\"\n        assert self.admin_site is not None\n\n        if id is None:\n            return JSONResponse(\n                status_code=422, content={\"message\": \"No id parameter provided\"}\n            )\n\n        item = await self.crud.get(db=db, id=id)\n        if not item:\n            return JSONResponse(\n                status_code=404, content={\"message\": f\"Item with id {id} not found\"}\n            )\n\n        form_fields = _get_form_fields_from_schema(self.update_schema)\n        error_message: Optional[str] = None\n        field_errors: Dict[str, str] = {}\n        field_values: Dict[str, Any] = {}\n\n        try:\n            form_data = await request.form()\n            update_data: Dict[str, Any] = {}\n            has_updates = False\n\n            for key, raw_val in form_data.items():\n                if isinstance(raw_val, UploadFile):\n                    field_values[key] = raw_val\n                    update_data[key] = raw_val\n                    has_updates = True\n                elif isinstance(raw_val, str):\n                    val_str = raw_val.strip()\n                    if val_str:\n                        update_data[key] = val_str\n                        field_values[key] = val_str\n                        has_updates = True\n\n            if not has_updates:\n                error_message = \"No changes were provided for update\"\n            else:\n                if self.update_internal_schema is not None and hasattr(\n                    self.update_internal_schema, \"__fields__\"\n                ):\n                    fields_dict = cast(\n                        Dict[str, Any], self.update_internal_schema.__fields__\n                    )\n                    if \"updated_at\" in fields_dict:\n                        update_data[\"updated_at\"] = dt.now(datetime.UTC)\n\n                try:\n                    if self.password_transformer is not None:\n                        update_schema_instance = self.update_schema(**update_data)\n\n                        transformed_data = (\n                            self.password_transformer.transform_update_data(\n                                update_data, update_schema_instance\n                            )\n                        )\n\n                        if self.model.__name__ == \"AdminUser\":\n                            from ..admin_user.schemas import AdminUserUpdateInternal\n\n                            admin_update_schema: AdminUserUpdateInternal = (\n                                AdminUserUpdateInternal(**transformed_data)\n                            )\n                            await self.crud.update(\n                                db=db, id=id, object=admin_update_schema\n                            )\n                        else:\n                            if self.update_internal_schema:\n                                generic_update_schema = self.update_internal_schema(\n                                    **transformed_data\n                                )\n                                await self.crud.update(\n                                    db=db, id=id, object=generic_update_schema\n                                )\n                            else:\n                                dynamic_update_schema = type(\n                                    \"InternalSchema\", (BaseModel,), {}\n                                )(**transformed_data)\n                                await self.crud.update(\n                                    db=db, id=id, object=dynamic_update_schema\n                                )\n\n                        await db.commit()\n                    else:\n                        update_schema_instance = self.update_schema(**update_data)\n                        await self.crud.update(\n                            db=db, id=id, object=update_schema_instance\n                        )\n                        await db.commit()\n\n                    return RedirectResponse(\n                        url=f\"/{self.admin_site.mount_path}/{self.model.__name__}/\",\n                        status_code=303,\n                    )\n\n                except ValidationError as e:\n                    field_errors = {\n                        str(err[\"loc\"][0]): err[\"msg\"] for err in e.errors()\n                    }\n                    error_message = \"Please correct the errors below.\"\n                except Exception as e:\n                    error_message = str(e)\n\n        except Exception as e:\n            error_message = str(e)\n\n        for field in form_fields:\n            field_name = field[\"name\"]\n            if field_name not in field_values and field_name in item:\n                field_values[field_name] = item[field_name]\n\n        context: Dict[str, Any] = {\n            \"request\": request,\n            \"model_name\": self.model_key,\n            \"form_fields\": form_fields,\n            \"error\": error_message,\n            \"field_errors\": field_errors,\n            \"field_values\": field_values,\n            \"mount_path\": self.admin_site.mount_path,\n            \"id\": id,\n            \"include_sidebar_and_header\": False,\n        }\n\n        return self.templates.TemplateResponse(\n            \"admin/model/update.html\",\n            context,\n            status_code=400 if error_message else 200,\n        )\n\n    return cast(EndpointCallable, form_update_endpoint_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.get_model_admin_page","title":"<code>get_model_admin_page(template='admin/model/list.html')</code>","text":"<p>Create endpoint for model list view with filtering and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Path to Jinja2 template for rendering list view</p> <code>'admin/model/list.html'</code> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for model list page</p> Example <pre><code># Basic list view\nresponse = await client.get(\"/?page=1&amp;rows-per-page-select=25\")\n\n# Sorted and filtered\nresponse = await client.get(\n    \"/?sort_by=username&amp;sort_order=desc&amp;column-to-search=email&amp;search-input=example.com\"\n)\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def get_model_admin_page(\n    self, template: str = \"admin/model/list.html\"\n) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for model list view with filtering and pagination.\n\n    Args:\n        template: Path to Jinja2 template for rendering list view\n\n    Returns:\n        FastAPI route handler for model list page\n\n    Example:\n        ```python\n        # Basic list view\n        response = await client.get(\"/?page=1&amp;rows-per-page-select=25\")\n\n        # Sorted and filtered\n        response = await client.get(\n            \"/?sort_by=username&amp;sort_order=desc&amp;column-to-search=email&amp;search-input=example.com\"\n        )\n        ```\n    \"\"\"\n\n    async def get_model_admin_page_inner(\n        request: Request,\n        admin_db: AsyncSession = Depends(self.db_config.get_admin_db),\n        app_db: AsyncSession = Depends(\n            cast(\n                Callable[..., AsyncGenerator[AsyncSession, None]],\n                self.db_config.get_app_session(),\n            )\n        ),\n    ) -&gt; Response:\n        \"\"\"Display the model list page, allowing pagination, sorting, and searching.\"\"\"\n        if self._model_is_admin_model(self.model):\n            db = admin_db\n        else:\n            db = app_db\n\n        if template == \"admin/model/list.html\" and not request.url.path.endswith(\n            \"/\"\n        ):\n            redirect_url = request.url.path + \"/\"\n            if request.url.query:\n                redirect_url += \"?\" + request.url.query\n            return RedirectResponse(redirect_url, status_code=307)\n\n        try:\n            page = max(1, int(request.query_params.get(\"page\", \"1\")))\n            rows_per_page = int(\n                request.query_params.get(\"rows-per-page-select\", \"10\")\n            )\n        except ValueError:\n            page = 1\n            rows_per_page = 10\n\n        sort_column = request.query_params.get(\"sort_by\")\n        sort_order = request.query_params.get(\"sort_order\", \"asc\")\n\n        sort_columns = (\n            [sort_column] if sort_column and sort_column != \"None\" else None\n        )\n        sort_orders = [sort_order] if sort_order and sort_order != \"None\" else None\n\n        search_column = request.query_params.get(\"column-to-search\")\n        search_value = request.query_params.get(\"search-input\", \"\").strip()\n\n        filter_criteria: Dict[str, Any] = {}\n        if search_column and search_value:\n            column = self.model.__table__.columns.get(search_column)\n            if column is not None:\n                python_type = column.type.python_type\n                try:\n                    if python_type is int:\n                        filter_criteria[search_column] = int(search_value)\n                    elif python_type is float:\n                        filter_criteria[search_column] = float(search_value)\n                    elif python_type is bool:\n                        lower_search = search_value.lower()\n                        if lower_search in (\"true\", \"yes\", \"1\", \"t\", \"y\"):\n                            filter_criteria[search_column] = True\n                        elif lower_search in (\"false\", \"no\", \"0\", \"f\", \"n\"):\n                            filter_criteria[search_column] = False\n                    elif python_type is str:\n                        filter_criteria[f\"{search_column}__ilike\"] = (\n                            f\"%{search_value}%\"\n                        )\n                except (ValueError, TypeError):\n                    pass\n\n        try:\n            total_items = await self.crud.count(db=db, **cast(Any, filter_criteria))\n            max_page = max(1, (total_items + rows_per_page - 1) // rows_per_page)\n            page = min(page, max_page)\n            offset = (page - 1) * rows_per_page\n\n            items_result = await self.crud.get_multi(\n                db=db,\n                offset=offset,\n                limit=rows_per_page,\n                sort_columns=sort_columns,\n                sort_orders=sort_orders,\n                **cast(Any, filter_criteria),\n            )\n\n            items: Dict[str, Any] = {\n                \"data\": items_result.get(\"data\", []),\n                \"total_count\": items_result.get(\"total_count\", 0),\n            }\n\n        except Exception:\n            items = {\"data\": [], \"total_count\": 0}\n            total_items = 0\n            page = 1\n\n        table_columns = [column.key for column in self.model.__table__.columns]\n        primary_key_info = self.db_config.get_primary_key_info(self.model)\n\n        context: Dict[str, Any] = {\n            \"request\": request,\n            \"model_items\": items[\"data\"],\n            \"model_name\": self.model_key,\n            \"table_columns\": table_columns,\n            \"total_items\": items[\"total_count\"],\n            \"current_page\": page,\n            \"rows_per_page\": rows_per_page,\n            \"selected_column\": search_column,\n            \"primary_key_info\": primary_key_info,\n            \"mount_path\": self.admin_site.mount_path if self.admin_site else \"\",\n            \"sort_column\": sort_column,\n            \"sort_order\": sort_order,\n            \"allowed_actions\": self.allowed_actions,\n        }\n\n        if \"HX-Request\" in request.headers:\n            return self.templates.TemplateResponse(\n                \"admin/model/components/list_content.html\", context\n            )\n\n        if self.admin_site is not None:\n            base_context = await self.admin_site.get_base_context(\n                admin_db=admin_db, app_db=app_db\n            )\n            context.update(base_context)\n            context[\"include_sidebar_and_header\"] = True\n\n        return self.templates.TemplateResponse(template, context)\n\n    return cast(EndpointCallable, get_model_admin_page_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.get_model_create_page","title":"<code>get_model_create_page(template='admin/model/create.html')</code>","text":"<p>Create endpoint for displaying new record creation form.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Path to Jinja2 template for rendering create form</p> <code>'admin/model/create.html'</code> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for create form page</p> Example <pre><code>endpoint = view.get_model_create_page(\"admin/model/create.html\")\nrouter.add_api_route(\"/create\", endpoint, methods=[\"GET\"])\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def get_model_create_page(\n    self, template: str = \"admin/model/create.html\"\n) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for displaying new record creation form.\n\n    Args:\n        template: Path to Jinja2 template for rendering create form\n\n    Returns:\n        FastAPI route handler for create form page\n\n    Example:\n        ```python\n        endpoint = view.get_model_create_page(\"admin/model/create.html\")\n        router.add_api_route(\"/create\", endpoint, methods=[\"GET\"])\n        ```\n    \"\"\"\n\n    async def model_create_page(request: Request) -&gt; Response:\n        \"\"\"Show a blank form for creating a new record.\"\"\"\n        form_fields = _get_form_fields_from_schema(self.create_schema)\n        mount_path = self.admin_site.mount_path if self.admin_site else \"\"\n        return self.templates.TemplateResponse(\n            template,\n            {\n                \"request\": request,\n                \"model_name\": self.model_key,\n                \"form_fields\": form_fields,\n                \"mount_path\": mount_path,\n            },\n        )\n\n    return cast(EndpointCallable, model_create_page)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.get_model_update_page","title":"<code>get_model_update_page(template)</code>","text":"<p>Create endpoint for displaying record update form.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>Path to Jinja2 template for rendering update form</p> required <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for update form page</p> Example <pre><code>endpoint = view.get_model_update_page(\"admin/model/update.html\")\nrouter.add_api_route(\"/update/{id}\", endpoint, methods=[\"GET\"])\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def get_model_update_page(self, template: str) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for displaying record update form.\n\n    Args:\n        template: Path to Jinja2 template for rendering update form\n\n    Returns:\n        FastAPI route handler for update form page\n\n    Example:\n        ```python\n        endpoint = view.get_model_update_page(\"admin/model/update.html\")\n        router.add_api_route(\"/update/{id}\", endpoint, methods=[\"GET\"])\n        ```\n    \"\"\"\n\n    async def get_model_update_page_inner(\n        request: Request,\n        id: int,\n        db: AsyncSession = Depends(self.session),\n    ) -&gt; Response:\n        \"\"\"Show a form to update an existing record by `id`.\"\"\"\n        item = await self.crud.get(db=db, id=id)\n        if not item:\n            return JSONResponse(\n                status_code=404, content={\"message\": f\"Item with id {id} not found\"}\n            )\n\n        form_fields = _get_form_fields_from_schema(self.update_schema)\n        for field in form_fields:\n            field_name = field[\"name\"]\n            if field_name in item:\n                field[\"value\"] = item[field_name]\n\n        mount_path = self.admin_site.mount_path if self.admin_site else \"\"\n        return self.templates.TemplateResponse(\n            template,\n            {\n                \"request\": request,\n                \"model_name\": self.model_key,\n                \"form_fields\": form_fields,\n                \"mount_path\": mount_path,\n                \"id\": id,\n            },\n        )\n\n    return cast(EndpointCallable, get_model_update_page_inner)\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.setup_routes","title":"<code>setup_routes()</code>","text":"<p>Configure FastAPI routes based on allowed actions.</p> <p>Sets up the following routes if allowed: - Create: /form_create (POST), /create_page (GET) - View: / (GET), /get_model_list (GET) - Delete: /bulk-delete (DELETE) - Update: /update/{id} (GET), /form_update/{id} (POST)</p> <p>Routes are configured based on the allowed_actions set provided during initialization. All routes use appropriate templates and include required dependencies.</p> Example <pre><code># Configure with specific actions\nview = ModelView(\n    allowed_actions={\"view\", \"create\", \"update\"},\n    ...\n)\nview.setup_routes()  # Only creates view/create/update routes\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def setup_routes(self) -&gt; None:\n    \"\"\"\n    Configure FastAPI routes based on allowed actions.\n\n    Sets up the following routes if allowed:\n    - Create: /form_create (POST), /create_page (GET)\n    - View: / (GET), /get_model_list (GET)\n    - Delete: /bulk-delete (DELETE)\n    - Update: /update/{id} (GET), /form_update/{id} (POST)\n\n    Routes are configured based on the allowed_actions set provided during initialization.\n    All routes use appropriate templates and include required dependencies.\n\n    Example:\n        ```python\n        # Configure with specific actions\n        view = ModelView(\n            allowed_actions={\"view\", \"create\", \"update\"},\n            ...\n        )\n        view.setup_routes()  # Only creates view/create/update routes\n        ```\n    \"\"\"\n    if \"create\" in self.allowed_actions:\n        self.router.add_api_route(\n            \"/form_create\",\n            self.form_create_endpoint(template=\"admin/model/create.html\"),\n            methods=[\"POST\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/create_page\",\n            self.get_model_create_page(template=\"admin/model/create.html\"),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n\n    if \"view\" in self.allowed_actions:\n        self.router.add_api_route(\n            \"/\",\n            self.get_model_admin_page(),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/get_model_list\",\n            self.get_model_admin_page(\n                template=\"admin/model/components/list_content.html\"\n            ),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n\n    if \"delete\" in self.allowed_actions:\n        self.router.add_api_route(\n            \"/bulk-delete\",\n            self.bulk_delete_endpoint(),\n            methods=[\"DELETE\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n\n    if \"update\" in self.allowed_actions:\n        self.router.add_api_route(\n            \"/update/{id}\",\n            self.get_model_update_page(template=\"admin/model/update.html\"),\n            methods=[\"GET\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n        self.router.add_api_route(\n            \"/form_update/{id}\",\n            self.form_update_endpoint(),\n            methods=[\"POST\"],\n            include_in_schema=False,\n            response_model=None,\n        )\n</code></pre>"},{"location":"api/model_view/#crudadmin.admin_interface.model_view.ModelView.table_body_content","title":"<code>table_body_content()</code>","text":"<p>Create endpoint for HTMX-powered table content updates.</p> <p>Returns:</p> Type Description <code>EndpointCallable</code> <p>FastAPI route handler for table content partial</p> Query Parameters <ul> <li>page: Page number (default: 1)</li> <li>rows-per-page-select: Records per page (default: 10)</li> <li>column-to-search: Column to search in</li> <li>search: Search term</li> </ul> Example <pre><code># HTMX request for filtered content\nresponse = await client.get(\n    \"/table-content?page=2&amp;column-to-search=name&amp;search=test\",\n    headers={\"HX-Request\": \"true\"}\n)\n</code></pre> Source code in <code>crudadmin/admin_interface/model_view.py</code> <pre><code>def table_body_content(self) -&gt; EndpointCallable:\n    \"\"\"\n    Create endpoint for HTMX-powered table content updates.\n\n    Returns:\n        FastAPI route handler for table content partial\n\n    Query Parameters:\n        - page: Page number (default: 1)\n        - rows-per-page-select: Records per page (default: 10)\n        - column-to-search: Column to search in\n        - search: Search term\n\n    Example:\n        ```python\n        # HTMX request for filtered content\n        response = await client.get(\n            \"/table-content?page=2&amp;column-to-search=name&amp;search=test\",\n            headers={\"HX-Request\": \"true\"}\n        )\n        ```\n    \"\"\"\n\n    async def table_body_content_inner(\n        request: Request,\n        db: AsyncSession = Depends(self.session),\n    ) -&gt; Response:\n        \"\"\"Return HTMX partial for table content with pagination/search.\"\"\"\n        page_str = request.query_params.get(\"page\", \"1\")\n        limit_str = request.query_params.get(\"rows-per-page-select\", \"10\")\n\n        try:\n            page = int(page_str)\n            limit = int(limit_str)\n        except ValueError:\n            page = 1\n            limit = 10\n\n        offset = (page - 1) * limit\n        search_column = request.query_params.get(\"column-to-search\")\n        search_value = request.query_params.get(\"search\", \"\")\n\n        filter_criteria: Dict[str, Any] = {}\n        if search_column and search_value:\n            filter_criteria[f\"{search_column}__ilike\"] = f\"%{search_value}%\"\n\n        items_result = await self.crud.get_multi(\n            db=db, offset=offset, limit=limit, **cast(Any, filter_criteria)\n        )\n\n        items: Dict[str, Any] = {\n            \"data\": items_result.get(\"data\", []),\n            \"total_count\": items_result.get(\"total_count\", 0),\n        }\n\n        total_items = items[\"total_count\"]\n        total_pages = (total_items + limit - 1) // limit\n\n        return self.templates.TemplateResponse(\n            \"model/components/table_content.html\",\n            {\n                \"request\": request,\n                \"model_items\": items[\"data\"],\n                \"current_page\": page,\n                \"rows_per_page\": limit,\n                \"total_items\": total_items,\n                \"total_pages\": total_pages,\n            },\n        )\n\n    return cast(EndpointCallable, table_body_content_inner)\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of CRUDAdmin documentation. This section provides detailed information about the various classes, functions, and modules that make up our modern admin interface for FastAPI applications. Whether you are looking to extend the admin interface, integrate with your existing systems, or explore advanced configuration options, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>CRUDAdmin's API is comprised of several key components, each serving a specific purpose in creating a comprehensive admin interface:</p> <ol> <li> <p>CRUDAdmin Class: The main entry point and core class for creating admin interfaces. It handles the creation of the admin application, model registration, authentication setup, and security configuration.</p> <ul> <li>CRUDAdmin Class Reference</li> </ul> </li> <li> <p>ModelView Class: Handles the representation and CRUD operations for individual SQLAlchemy models within the admin interface. It provides customizable views with filtering, pagination, and bulk operations.</p> <ul> <li>ModelView Class Reference</li> </ul> </li> <li> <p>AdminSite Class: The foundation class that manages the overall admin site structure, routing, and template rendering. It coordinates between different model views and handles the main admin interface.</p> <ul> <li>AdminSite Class Reference</li> </ul> </li> <li> <p>Session Management System: A comprehensive session management system with multiple backend options (Memory, Redis, Memcached, Database, Hybrid) providing secure authentication, CSRF protection, and session tracking.</p> <ul> <li>Session Management API Reference</li> </ul> </li> <li> <p>Event System: A robust event logging and audit trail system that tracks all admin actions, authentication events, and security-related activities with comprehensive audit capabilities.</p> <ul> <li>Event System API Reference</li> </ul> </li> </ol>"},{"location":"api/overview/#architecture-overview","title":"Architecture Overview","text":"<p>CRUDAdmin follows a modular architecture designed for flexibility and scalability:</p>"},{"location":"api/overview/#core-layer","title":"Core Layer","text":"<ul> <li>Authentication &amp; Authorization: Secure admin user management with role-based access</li> <li>Session Management: Multi-backend session storage with security features</li> <li>Rate Limiting: Protection against abuse and brute force attacks</li> <li>Database Integration: SQLAlchemy model integration with FastCRUD backend</li> </ul>"},{"location":"api/overview/#interface-layer","title":"Interface Layer","text":"<ul> <li>Admin Site: Main admin interface coordination and routing</li> <li>Model Views: Individual model CRUD interfaces with customization options</li> <li>Template System: HTMX-powered responsive UI with modern design</li> <li>Static Assets: CSS, JavaScript, and image resources</li> </ul>"},{"location":"api/overview/#event-layer","title":"Event Layer","text":"<ul> <li>Event Logging: Comprehensive audit trail for all admin actions</li> <li>Security Events: Authentication and authorization event tracking</li> <li>Audit Integration: Automated logging with decorator support</li> </ul>"},{"location":"api/overview/#usage-patterns","title":"Usage Patterns","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of CRUDAdmin, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development and documentation improvements.</p>"},{"location":"api/overview/#support-feedback","title":"Support &amp; Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation and the CRUDAdmin library. If you have any suggestions, corrections, or queries, please:</p> <ul> <li>Open an issue on our GitHub repository</li> <li>Join our community discussions</li> <li>Contribute to the documentation</li> </ul> <p>Navigate through each section for detailed documentation of our API components. Each page includes comprehensive examples, parameter descriptions, and usage patterns to help you make the most of CRUDAdmin's capabilities.</p>"},{"location":"api/session/","title":"Session Management API Reference","text":"<p>The CRUDAdmin session management system provides secure, scalable session handling with multiple backend options and comprehensive security features including CSRF protection, session expiration, and device tracking.</p>"},{"location":"api/session/#core-components","title":"Core Components","text":""},{"location":"api/session/#session-manager","title":"Session Manager","text":"<p>The main session management class that handles all session operations.</p> <p>Session manager for handling secure authentication sessions in crudadmin.</p> <p>This class implements a comprehensive session-based authentication system with the following features:</p> <ul> <li>Secure session creation and validation</li> <li>CSRF protection with token generation and validation</li> <li>Session expiration and automatic cleanup</li> <li>Device fingerprinting and user agent tracking</li> <li>Multi-device support with configurable session limits per user</li> <li>IP address tracking for security monitoring</li> <li>Session metadata for storing additional authentication context</li> <li>Rate limiting for login attempts with IP and username tracking</li> </ul> <p>Authentication Flow: 1. When a user logs in successfully, create_session() generates a new session and CSRF token 2. Session cookies are set via set_session_cookies() - a httpOnly session_id and a non-httpOnly csrf_token 3. On subsequent requests, validate_session() confirms the session is valid and not expired 4. For state-changing operations, validate_csrf_token() provides protection against CSRF attacks 5. Sessions automatically expire after inactivity, or can be manually terminated 6. Periodic cleanup_expired_sessions() removes stale sessions</p> <p>Security Features: - Sessions are stored server-side with only the ID transmitted to clients - CSRF protection through synchronized tokens - Session hijacking protection via IP and user agent tracking - Automatic session expiration after configurable timeout - Forced logout of oldest sessions when session limit is reached - Different SameSite cookie settings for development and production - Rate limiting for login attempts to prevent brute force attacks</p> <p>Usage: Sessions should be validated on each authenticated request, with CSRF tokens validated for any state-changing operations. The cleanup method should be called periodically to remove expired sessions.</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>class SessionManager:\n    \"\"\"Session manager for handling secure authentication sessions in crudadmin.\n\n    This class implements a comprehensive session-based authentication system with the following features:\n\n    - Secure session creation and validation\n    - CSRF protection with token generation and validation\n    - Session expiration and automatic cleanup\n    - Device fingerprinting and user agent tracking\n    - Multi-device support with configurable session limits per user\n    - IP address tracking for security monitoring\n    - Session metadata for storing additional authentication context\n    - Rate limiting for login attempts with IP and username tracking\n\n    Authentication Flow:\n    1. When a user logs in successfully, create_session() generates a new session and CSRF token\n    2. Session cookies are set via set_session_cookies() - a httpOnly session_id and a non-httpOnly csrf_token\n    3. On subsequent requests, validate_session() confirms the session is valid and not expired\n    4. For state-changing operations, validate_csrf_token() provides protection against CSRF attacks\n    5. Sessions automatically expire after inactivity, or can be manually terminated\n    6. Periodic cleanup_expired_sessions() removes stale sessions\n\n    Security Features:\n    - Sessions are stored server-side with only the ID transmitted to clients\n    - CSRF protection through synchronized tokens\n    - Session hijacking protection via IP and user agent tracking\n    - Automatic session expiration after configurable timeout\n    - Forced logout of oldest sessions when session limit is reached\n    - Different SameSite cookie settings for development and production\n    - Rate limiting for login attempts to prevent brute force attacks\n\n    Usage:\n    Sessions should be validated on each authenticated request, with CSRF tokens validated\n    for any state-changing operations. The cleanup method should be called periodically\n    to remove expired sessions.\n    \"\"\"\n\n    def __init__(\n        self,\n        session_storage: Optional[AbstractSessionStorage[SessionData]] = None,\n        max_sessions_per_user: int = 5,\n        session_timeout_minutes: int = 30,\n        cleanup_interval_minutes: int = 15,\n        csrf_token_bytes: int = 32,\n        rate_limiter: Optional[SimpleRateLimiter] = None,\n        login_max_attempts: int = 5,\n        login_window_minutes: int = 15,\n        session_backend: str = \"memory\",\n        **backend_kwargs: Any,\n    ):\n        \"\"\"Initialize the session manager.\n\n        Args:\n            session_storage: Storage backend for sessions (if None, will be created)\n            max_sessions_per_user: Maximum number of active sessions per user\n            session_timeout_minutes: Session timeout in minutes\n            cleanup_interval_minutes: Interval for cleaning up expired sessions\n            csrf_token_bytes: Number of bytes to use for CSRF tokens\n            rate_limiter: Optional rate limiter implementation for login attempts\n            login_max_attempts: Maximum failed login attempts before rate limiting\n            login_window_minutes: Time window for tracking failed login attempts\n            session_backend: Backend type if creating storage automatically\n            **backend_kwargs: Additional arguments for backend creation\n        \"\"\"\n        self.max_sessions = max_sessions_per_user\n        self.session_timeout = timedelta(minutes=session_timeout_minutes)\n        self.cleanup_interval = timedelta(minutes=cleanup_interval_minutes)\n        self.last_cleanup = datetime.now(UTC)\n        self.csrf_token_bytes = csrf_token_bytes\n        self.rate_limiter = rate_limiter\n        self.login_max_attempts = login_max_attempts\n        self.login_window = timedelta(minutes=login_window_minutes)\n\n        if session_storage is None:\n            storage_settings = {\n                \"prefix\": \"session:\",\n                \"expiration\": session_timeout_minutes * 60,\n                **backend_kwargs,\n            }\n            self.storage: AbstractSessionStorage[SessionData] = get_session_storage(\n                backend=session_backend, model_type=SessionData, **storage_settings\n            )\n        else:\n            self.storage = session_storage\n\n        csrf_storage_settings = {\n            \"prefix\": \"csrf:\",\n            \"expiration\": session_timeout_minutes * 60,\n        }\n        csrf_storage_settings.update(backend_kwargs)\n        self.csrf_storage: AbstractSessionStorage[CSRFToken] = get_session_storage(\n            backend=session_backend, model_type=CSRFToken, **csrf_storage_settings\n        )\n\n    def parse_user_agent(self, user_agent_string: str) -&gt; UserAgentInfo:\n        \"\"\"Parse User-Agent string into structured information.\n\n        Args:\n            user_agent_string: Raw User-Agent header\n\n        Returns:\n            Structured UserAgentInfo\n        \"\"\"\n        ua_parser = parse(user_agent_string)\n        return UserAgentInfo(\n            browser=ua_parser.browser.family,\n            browser_version=ua_parser.browser.version_string,\n            os=ua_parser.os.family,\n            device=ua_parser.device.family,\n            is_mobile=ua_parser.is_mobile,\n            is_tablet=ua_parser.is_tablet,\n            is_pc=ua_parser.is_pc,\n        )\n\n    async def create_session(\n        self, request: Request, user_id: int, metadata: Optional[dict[str, Any]] = None\n    ) -&gt; tuple[str, str]:\n        \"\"\"Create a new session for a user and generate a CSRF token.\n\n        Args:\n            request: The request object\n            user_id: The user ID\n            metadata: Optional session metadata\n\n        Returns:\n            Tuple of (session_id, csrf_token)\n\n        Raises:\n            ValueError: If the request client is invalid\n        \"\"\"\n        logger.info(f\"Creating new session for user_id: {user_id}\")\n\n        try:\n            user_agent = request.headers.get(\"user-agent\", \"\")\n            current_time = datetime.now(UTC)\n\n            client = request.client\n            if client is None:\n                logger.error(\"Request client is None. Cannot retrieve IP address.\")\n                raise ValueError(\"Invalid request client.\")\n\n            device_info = self.parse_user_agent(user_agent).model_dump()\n\n            ip_address = (\n                request.headers.get(\"x-forwarded-for\", client.host)\n                .split(\",\")[0]\n                .strip()\n            )\n\n            await self._enforce_session_limit(user_id)\n\n            session_data = SessionCreate(\n                user_id=user_id,\n                ip_address=ip_address,\n                user_agent=user_agent,\n                device_info=device_info,\n                last_activity=current_time,\n                is_active=True,\n                metadata=metadata or {},\n            )\n\n            session_id = await self.storage.create(session_data)\n            csrf_token = await self._generate_csrf_token(user_id, session_id)\n\n            logger.info(f\"Session {session_id} created successfully\")\n            return session_id, csrf_token\n\n        except Exception as e:\n            logger.error(f\"Error creating session: {str(e)}\", exc_info=True)\n            raise\n\n    async def validate_session(\n        self, session_id: str, update_activity: bool = True\n    ) -&gt; Optional[SessionData]:\n        \"\"\"Validate if a session is active and not timed out.\n\n        Args:\n            session_id: The session ID\n            update_activity: Whether to update the last activity timestamp\n\n        Returns:\n            The session data if valid, None otherwise\n        \"\"\"\n        if not session_id:\n            return None\n\n        try:\n            session_data = await self.storage.get(session_id, SessionData)\n            if session_data is None:\n                logger.warning(f\"Session not found: {session_id}\")\n                return None\n\n            if not session_data.is_active:\n                logger.warning(f\"Session is not active: {session_id}\")\n                return None\n\n            current_time = datetime.now(UTC)\n            session_age = current_time - session_data.last_activity\n\n            if session_age &gt; self.session_timeout:\n                logger.warning(f\"Session timed out: {session_id}\")\n                await self.terminate_session(session_id)\n                return None\n\n            if update_activity:\n                session_data.last_activity = current_time\n                await self.storage.update(session_id, session_data)\n\n            return session_data\n\n        except Exception as e:\n            logger.error(f\"Error validating session: {str(e)}\", exc_info=True)\n            return None\n\n    async def validate_csrf_token(\n        self,\n        session_id: str,\n        csrf_token: str,\n    ) -&gt; bool:\n        \"\"\"Validate a CSRF token for a session.\n\n        Args:\n            session_id: The session ID\n            csrf_token: The CSRF token to validate\n\n        Returns:\n            True if valid, False otherwise\n        \"\"\"\n        if not session_id or not csrf_token:\n            logger.warning(\n                f\"Missing session_id or csrf_token: session_id={session_id}, csrf_token={csrf_token}\"\n            )\n            return False\n\n        try:\n            token_data = await self.csrf_storage.get(csrf_token, CSRFToken)\n            if token_data is None:\n                logger.warning(f\"CSRF token not found in storage: {csrf_token}\")\n                return False\n\n            if token_data.session_id != session_id:\n                logger.warning(\n                    f\"CSRF token session mismatch: {csrf_token} should be for session {session_id}, \"\n                    f\"but is for session {token_data.session_id}\"\n                )\n                return False\n\n            current_time = datetime.now(UTC)\n            if token_data.expires_at &lt; current_time:\n                logger.warning(\n                    f\"CSRF token expired: {csrf_token}, expired at {token_data.expires_at}, current time is {current_time}\"\n                )\n                await self.csrf_storage.delete(csrf_token)\n                return False\n\n            return True\n\n        except Exception as e:\n            logger.error(f\"Error validating CSRF token: {str(e)}\", exc_info=True)\n            return False\n\n    async def regenerate_csrf_token(\n        self,\n        user_id: int,\n        session_id: str,\n    ) -&gt; str:\n        \"\"\"Regenerate a CSRF token for an existing session.\n\n        Args:\n            user_id: The user ID\n            session_id: The session ID\n\n        Returns:\n            The new CSRF token\n        \"\"\"\n        try:\n            if hasattr(self.csrf_storage, \"_scan_iter\"):\n                keys = await self.csrf_storage._scan_iter(\n                    match=f\"{self.csrf_storage.prefix}*\"\n                )\n                for key in keys:\n                    try:\n                        token_id = key[len(self.csrf_storage.prefix) :]\n                        csrf_data = await self.csrf_storage.get(token_id, CSRFToken)\n                        if csrf_data and csrf_data.session_id == session_id:\n                            await self.csrf_storage.delete(token_id)\n                    except Exception as e:\n                        logger.warning(f\"Error cleaning up old CSRF token: {e}\")\n        except Exception as e:\n            logger.warning(f\"Error scanning for old CSRF tokens: {e}\")\n\n        return await self._generate_csrf_token(user_id, session_id)\n\n    async def _generate_csrf_token(\n        self,\n        user_id: int,\n        session_id: str,\n    ) -&gt; str:\n        \"\"\"Generate a new CSRF token for a session.\n\n        Args:\n            user_id: The user ID\n            session_id: The session ID\n\n        Returns:\n            The CSRF token\n        \"\"\"\n        token = secrets.token_hex(self.csrf_token_bytes)\n        expires_at = datetime.now(UTC) + self.session_timeout\n\n        csrf_data = CSRFToken(\n            token=token,\n            user_id=user_id,\n            session_id=session_id,\n            expires_at=expires_at,\n        )\n\n        await self.csrf_storage.create(csrf_data, session_id=token)\n        return token\n\n    async def terminate_session(self, session_id: str) -&gt; bool:\n        \"\"\"Terminate a specific session.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was terminated, False otherwise\n        \"\"\"\n        try:\n            session_data = await self.storage.get(session_id, SessionData)\n            if session_data is None:\n                return False\n\n            session_data.is_active = False\n            session_data.metadata = {\n                **session_data.metadata,\n                \"terminated_at\": datetime.now(UTC).isoformat(),\n                \"termination_reason\": \"manual_termination\",\n            }\n\n            return await self.storage.update(session_id, session_data)\n\n        except Exception as e:\n            logger.error(f\"Error terminating session: {str(e)}\", exc_info=True)\n            return False\n\n    async def _enforce_session_limit(self, user_id: int) -&gt; None:\n        \"\"\"Enforce the maximum number of sessions per user.\n\n        Terminates the oldest sessions if the limit is exceeded.\n\n        Args:\n            user_id: The user ID\n        \"\"\"\n        try:\n            active_sessions = []\n\n            if hasattr(self.storage, \"get_user_sessions\"):\n                try:\n                    session_ids = await self.storage.get_user_sessions(user_id)\n                    for session_id in session_ids:\n                        try:\n                            session_data = await self.storage.get(\n                                session_id, SessionData\n                            )\n                            if session_data and session_data.is_active:\n                                active_sessions.append(session_data)\n                        except Exception as e:\n                            logger.warning(\n                                f\"Error processing session {session_id}: {e}\"\n                            )\n                            continue\n                except Exception as e:\n                    logger.warning(f\"Error getting user sessions: {e}\")\n                    active_sessions = await self._get_active_sessions_by_scan(user_id)\n            else:\n                active_sessions = await self._get_active_sessions_by_scan(user_id)\n\n            if len(active_sessions) &gt;= self.max_sessions:\n                active_sessions.sort(key=lambda s: s.last_activity)\n\n                excess_count = len(active_sessions) - self.max_sessions + 1\n                for i in range(excess_count):\n                    if i &lt; len(active_sessions):\n                        await self.terminate_session(active_sessions[i].session_id)\n\n        except Exception as e:\n            logger.error(f\"Error enforcing session limit: {e}\", exc_info=True)\n\n    async def _get_active_sessions_by_scan(self, user_id: int) -&gt; list[SessionData]:\n        \"\"\"Get active sessions for a user by scanning all keys.\n\n        This is a fallback method when indexed groups are not available.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            List of active sessions for the user\n        \"\"\"\n        active_sessions = []\n\n        if hasattr(self.storage, \"_scan_iter\"):\n            keys = await self.storage._scan_iter(match=f\"{self.storage.prefix}*\")\n            for key in keys:\n                try:\n                    session_data_bytes = await self.storage.get(\n                        session_id=key[len(self.storage.prefix) :],\n                        model_class=SessionData,\n                    )\n                    if (\n                        session_data_bytes\n                        and session_data_bytes.user_id == user_id\n                        and session_data_bytes.is_active\n                    ):\n                        active_sessions.append(session_data_bytes)\n                except Exception as e:\n                    logger.warning(f\"Error processing session during cleanup: {e}\")\n                    continue\n        elif hasattr(self.storage, \"client\") and hasattr(\n            self.storage.client, \"scan_iter\"\n        ):\n            async for key in self.storage.client.scan_iter(\n                match=f\"{self.storage.prefix}*\"\n            ):\n                try:\n                    if isinstance(key, bytes):\n                        key = key.decode(\"utf-8\")\n                    session_id = key[len(self.storage.prefix) :]\n\n                    session_data = await self.storage.get(session_id, SessionData)\n                    if (\n                        session_data\n                        and session_data.user_id == user_id\n                        and session_data.is_active\n                    ):\n                        active_sessions.append(session_data)\n                except Exception as e:\n                    logger.warning(f\"Error processing session during cleanup: {e}\")\n                    continue\n\n        return active_sessions\n\n    async def cleanup_expired_sessions(self) -&gt; None:\n        \"\"\"Cleanup expired and inactive sessions.\n\n        This should be called periodically.\n        \"\"\"\n        now = datetime.now(UTC)\n\n        if now - self.last_cleanup &lt; self.cleanup_interval:\n            return\n\n        timeout_threshold = now - self.session_timeout\n\n        try:\n            if hasattr(self.storage, \"_scan_iter\"):\n                keys = await self.storage._scan_iter(match=f\"{self.storage.prefix}*\")\n                for key in keys:\n                    try:\n                        session_id = key[len(self.storage.prefix) :]\n                        session_data = await self.storage.get(session_id, SessionData)\n                        if (\n                            session_data\n                            and session_data.is_active\n                            and session_data.last_activity &lt; timeout_threshold\n                        ):\n                            session_data.is_active = False\n                            session_data.metadata = {\n                                **session_data.metadata,\n                                \"terminated_at\": now.isoformat(),\n                                \"termination_reason\": \"session_timeout\",\n                            }\n                            await self.storage.update(session_id, session_data)\n                    except Exception as e:\n                        logger.warning(f\"Error processing session during cleanup: {e}\")\n                        continue\n            elif hasattr(self.storage, \"client\") and hasattr(\n                self.storage.client, \"scan_iter\"\n            ):\n                async for key in self.storage.client.scan_iter(\n                    match=f\"{self.storage.prefix}*\"\n                ):\n                    try:\n                        if isinstance(key, bytes):\n                            key = key.decode(\"utf-8\")\n                        session_id = key[len(self.storage.prefix) :]\n\n                        session_data = await self.storage.get(session_id, SessionData)\n                        if (\n                            session_data\n                            and session_data.is_active\n                            and session_data.last_activity &lt; timeout_threshold\n                        ):\n                            session_data.is_active = False\n                            session_data.metadata = {\n                                **session_data.metadata,\n                                \"terminated_at\": now.isoformat(),\n                                \"termination_reason\": \"session_timeout\",\n                            }\n                            await self.storage.update(\n                                session_data.session_id, session_data\n                            )\n                    except Exception as e:\n                        logger.warning(f\"Error processing session during cleanup: {e}\")\n                        continue\n\n            if self.rate_limiter:\n                try:\n                    await self.cleanup_rate_limits()\n                except Exception as e:\n                    logger.error(f\"Error cleaning up rate limits: {e}\")\n\n            self.last_cleanup = now\n\n        except Exception as e:\n            logger.error(f\"Error during session cleanup: {e}\", exc_info=True)\n\n    def set_session_cookies(\n        self,\n        response: Response,\n        session_id: str,\n        csrf_token: str,\n        max_age: Optional[int] = None,\n        path: str = \"/\",\n        secure: bool = True,\n    ) -&gt; None:\n        \"\"\"Set session cookies in the response.\n\n        Args:\n            response: The response object\n            session_id: The session ID\n            csrf_token: The CSRF token\n            max_age: Cookie max age in seconds\n            path: Cookie path\n            secure: Whether to set the Secure flag\n        \"\"\"\n        settings = get_settings()\n        samesite: SamesiteType = DEV_SAMESITE if settings.DEBUG else PROD_SAMESITE\n        cookie_max_age = (\n            max_age if max_age is not None else settings.SESSION_COOKIE_MAX_AGE\n        )\n\n        response.set_cookie(\n            key=\"session_id\",\n            value=session_id,\n            httponly=True,\n            secure=secure,\n            samesite=samesite,\n            path=path,\n            max_age=cookie_max_age,\n        )\n\n        response.set_cookie(\n            key=\"csrf_token\",\n            value=csrf_token,\n            httponly=False,\n            secure=secure,\n            samesite=samesite,\n            path=path,\n            max_age=cookie_max_age,\n        )\n\n    def clear_session_cookies(\n        self,\n        response: Response,\n        path: str = \"/\",\n    ) -&gt; None:\n        \"\"\"Clear session cookies from the response.\n\n        Args:\n            response: The response object\n            path: Cookie path\n        \"\"\"\n        response.delete_cookie(key=\"session_id\", path=path)\n        response.delete_cookie(key=\"csrf_token\", path=path)\n\n    async def track_login_attempt(\n        self, ip_address: str, username: str, success: bool = False\n    ) -&gt; tuple[bool, Optional[int]]:\n        \"\"\"Track login attempts and apply rate limiting.\n\n        Args:\n            ip_address: Client IP address\n            username: Username being used for login\n            success: Whether the login attempt was successful\n\n        Returns:\n            Tuple of (is_allowed, attempts_remaining)\n\n        If rate limiting is not configured, this will always return (True, None)\n        but log a warning about missing rate limiting.\n        \"\"\"\n        if not self.rate_limiter:\n            logger.warning(\n                \"No rate limiter configured for login attempts. \"\n                \"It is strongly recommended to configure rate limiting for security.\"\n            )\n            return True, None\n\n        try:\n            ip_key = f\"login:ip:{ip_address}\"\n            username_key = f\"login:user:{username}\"\n\n            if success:\n                try:\n                    await self.rate_limiter.delete(ip_key)\n                    await self.rate_limiter.delete(username_key)\n                    return True, None\n                except Exception as e:\n                    logger.warning(\n                        f\"Error clearing rate limit after successful login: {e}\"\n                    )\n                    return True, None\n\n            try:\n                expiry_seconds = int(self.login_window.total_seconds())\n                ip_count = await self.rate_limiter.increment(ip_key, 1, expiry_seconds)\n                username_count = await self.rate_limiter.increment(\n                    username_key, 1, expiry_seconds\n                )\n            except Exception as e:\n                logger.warning(f\"Error tracking login attempt rate limits: {e}\")\n                return True, None\n\n            attempt_count = max(ip_count, username_count)\n            remaining = max(0, self.login_max_attempts - attempt_count)\n\n            is_allowed = attempt_count &lt;= self.login_max_attempts\n\n            if not is_allowed:\n                logger.warning(\n                    f\"Rate limit exceeded for login: {ip_address}, username: {username}, attempts: {attempt_count}\"\n                )\n\n            return is_allowed, remaining\n\n        except Exception as e:\n            logger.error(f\"Unexpected error in login rate limiting: {e}\", exc_info=True)\n            return True, None\n\n    async def cleanup_rate_limits(self) -&gt; None:\n        \"\"\"Clean up expired rate limit records.\n\n        This should be called periodically along with session cleanup.\n        \"\"\"\n        if not self.rate_limiter:\n            return\n\n        try:\n            if hasattr(self.rate_limiter, \"delete_pattern\"):\n                await self.rate_limiter.delete_pattern(\"login:*\")\n            else:\n                logger.debug(\"Rate limiter does not support pattern-based cleanup\")\n        except Exception as e:\n            logger.error(f\"Error cleaning up rate limit records: {e}\", exc_info=True)\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.__init__","title":"<code>__init__(session_storage=None, max_sessions_per_user=5, session_timeout_minutes=30, cleanup_interval_minutes=15, csrf_token_bytes=32, rate_limiter=None, login_max_attempts=5, login_window_minutes=15, session_backend='memory', **backend_kwargs)</code>","text":"<p>Initialize the session manager.</p> <p>Parameters:</p> Name Type Description Default <code>session_storage</code> <code>Optional[AbstractSessionStorage[SessionData]]</code> <p>Storage backend for sessions (if None, will be created)</p> <code>None</code> <code>max_sessions_per_user</code> <code>int</code> <p>Maximum number of active sessions per user</p> <code>5</code> <code>session_timeout_minutes</code> <code>int</code> <p>Session timeout in minutes</p> <code>30</code> <code>cleanup_interval_minutes</code> <code>int</code> <p>Interval for cleaning up expired sessions</p> <code>15</code> <code>csrf_token_bytes</code> <code>int</code> <p>Number of bytes to use for CSRF tokens</p> <code>32</code> <code>rate_limiter</code> <code>Optional[SimpleRateLimiter]</code> <p>Optional rate limiter implementation for login attempts</p> <code>None</code> <code>login_max_attempts</code> <code>int</code> <p>Maximum failed login attempts before rate limiting</p> <code>5</code> <code>login_window_minutes</code> <code>int</code> <p>Time window for tracking failed login attempts</p> <code>15</code> <code>session_backend</code> <code>str</code> <p>Backend type if creating storage automatically</p> <code>'memory'</code> <code>**backend_kwargs</code> <code>Any</code> <p>Additional arguments for backend creation</p> <code>{}</code> Source code in <code>crudadmin/session/manager.py</code> <pre><code>def __init__(\n    self,\n    session_storage: Optional[AbstractSessionStorage[SessionData]] = None,\n    max_sessions_per_user: int = 5,\n    session_timeout_minutes: int = 30,\n    cleanup_interval_minutes: int = 15,\n    csrf_token_bytes: int = 32,\n    rate_limiter: Optional[SimpleRateLimiter] = None,\n    login_max_attempts: int = 5,\n    login_window_minutes: int = 15,\n    session_backend: str = \"memory\",\n    **backend_kwargs: Any,\n):\n    \"\"\"Initialize the session manager.\n\n    Args:\n        session_storage: Storage backend for sessions (if None, will be created)\n        max_sessions_per_user: Maximum number of active sessions per user\n        session_timeout_minutes: Session timeout in minutes\n        cleanup_interval_minutes: Interval for cleaning up expired sessions\n        csrf_token_bytes: Number of bytes to use for CSRF tokens\n        rate_limiter: Optional rate limiter implementation for login attempts\n        login_max_attempts: Maximum failed login attempts before rate limiting\n        login_window_minutes: Time window for tracking failed login attempts\n        session_backend: Backend type if creating storage automatically\n        **backend_kwargs: Additional arguments for backend creation\n    \"\"\"\n    self.max_sessions = max_sessions_per_user\n    self.session_timeout = timedelta(minutes=session_timeout_minutes)\n    self.cleanup_interval = timedelta(minutes=cleanup_interval_minutes)\n    self.last_cleanup = datetime.now(UTC)\n    self.csrf_token_bytes = csrf_token_bytes\n    self.rate_limiter = rate_limiter\n    self.login_max_attempts = login_max_attempts\n    self.login_window = timedelta(minutes=login_window_minutes)\n\n    if session_storage is None:\n        storage_settings = {\n            \"prefix\": \"session:\",\n            \"expiration\": session_timeout_minutes * 60,\n            **backend_kwargs,\n        }\n        self.storage: AbstractSessionStorage[SessionData] = get_session_storage(\n            backend=session_backend, model_type=SessionData, **storage_settings\n        )\n    else:\n        self.storage = session_storage\n\n    csrf_storage_settings = {\n        \"prefix\": \"csrf:\",\n        \"expiration\": session_timeout_minutes * 60,\n    }\n    csrf_storage_settings.update(backend_kwargs)\n    self.csrf_storage: AbstractSessionStorage[CSRFToken] = get_session_storage(\n        backend=session_backend, model_type=CSRFToken, **csrf_storage_settings\n    )\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.cleanup_expired_sessions","title":"<code>cleanup_expired_sessions()</code>  <code>async</code>","text":"<p>Cleanup expired and inactive sessions.</p> <p>This should be called periodically.</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def cleanup_expired_sessions(self) -&gt; None:\n    \"\"\"Cleanup expired and inactive sessions.\n\n    This should be called periodically.\n    \"\"\"\n    now = datetime.now(UTC)\n\n    if now - self.last_cleanup &lt; self.cleanup_interval:\n        return\n\n    timeout_threshold = now - self.session_timeout\n\n    try:\n        if hasattr(self.storage, \"_scan_iter\"):\n            keys = await self.storage._scan_iter(match=f\"{self.storage.prefix}*\")\n            for key in keys:\n                try:\n                    session_id = key[len(self.storage.prefix) :]\n                    session_data = await self.storage.get(session_id, SessionData)\n                    if (\n                        session_data\n                        and session_data.is_active\n                        and session_data.last_activity &lt; timeout_threshold\n                    ):\n                        session_data.is_active = False\n                        session_data.metadata = {\n                            **session_data.metadata,\n                            \"terminated_at\": now.isoformat(),\n                            \"termination_reason\": \"session_timeout\",\n                        }\n                        await self.storage.update(session_id, session_data)\n                except Exception as e:\n                    logger.warning(f\"Error processing session during cleanup: {e}\")\n                    continue\n        elif hasattr(self.storage, \"client\") and hasattr(\n            self.storage.client, \"scan_iter\"\n        ):\n            async for key in self.storage.client.scan_iter(\n                match=f\"{self.storage.prefix}*\"\n            ):\n                try:\n                    if isinstance(key, bytes):\n                        key = key.decode(\"utf-8\")\n                    session_id = key[len(self.storage.prefix) :]\n\n                    session_data = await self.storage.get(session_id, SessionData)\n                    if (\n                        session_data\n                        and session_data.is_active\n                        and session_data.last_activity &lt; timeout_threshold\n                    ):\n                        session_data.is_active = False\n                        session_data.metadata = {\n                            **session_data.metadata,\n                            \"terminated_at\": now.isoformat(),\n                            \"termination_reason\": \"session_timeout\",\n                        }\n                        await self.storage.update(\n                            session_data.session_id, session_data\n                        )\n                except Exception as e:\n                    logger.warning(f\"Error processing session during cleanup: {e}\")\n                    continue\n\n        if self.rate_limiter:\n            try:\n                await self.cleanup_rate_limits()\n            except Exception as e:\n                logger.error(f\"Error cleaning up rate limits: {e}\")\n\n        self.last_cleanup = now\n\n    except Exception as e:\n        logger.error(f\"Error during session cleanup: {e}\", exc_info=True)\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.cleanup_rate_limits","title":"<code>cleanup_rate_limits()</code>  <code>async</code>","text":"<p>Clean up expired rate limit records.</p> <p>This should be called periodically along with session cleanup.</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def cleanup_rate_limits(self) -&gt; None:\n    \"\"\"Clean up expired rate limit records.\n\n    This should be called periodically along with session cleanup.\n    \"\"\"\n    if not self.rate_limiter:\n        return\n\n    try:\n        if hasattr(self.rate_limiter, \"delete_pattern\"):\n            await self.rate_limiter.delete_pattern(\"login:*\")\n        else:\n            logger.debug(\"Rate limiter does not support pattern-based cleanup\")\n    except Exception as e:\n        logger.error(f\"Error cleaning up rate limit records: {e}\", exc_info=True)\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.clear_session_cookies","title":"<code>clear_session_cookies(response, path='/')</code>","text":"<p>Clear session cookies from the response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The response object</p> required <code>path</code> <code>str</code> <p>Cookie path</p> <code>'/'</code> Source code in <code>crudadmin/session/manager.py</code> <pre><code>def clear_session_cookies(\n    self,\n    response: Response,\n    path: str = \"/\",\n) -&gt; None:\n    \"\"\"Clear session cookies from the response.\n\n    Args:\n        response: The response object\n        path: Cookie path\n    \"\"\"\n    response.delete_cookie(key=\"session_id\", path=path)\n    response.delete_cookie(key=\"csrf_token\", path=path)\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.create_session","title":"<code>create_session(request, user_id, metadata=None)</code>  <code>async</code>","text":"<p>Create a new session for a user and generate a CSRF token.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The request object</p> required <code>user_id</code> <code>int</code> <p>The user ID</p> required <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional session metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>Tuple of (session_id, csrf_token)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the request client is invalid</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def create_session(\n    self, request: Request, user_id: int, metadata: Optional[dict[str, Any]] = None\n) -&gt; tuple[str, str]:\n    \"\"\"Create a new session for a user and generate a CSRF token.\n\n    Args:\n        request: The request object\n        user_id: The user ID\n        metadata: Optional session metadata\n\n    Returns:\n        Tuple of (session_id, csrf_token)\n\n    Raises:\n        ValueError: If the request client is invalid\n    \"\"\"\n    logger.info(f\"Creating new session for user_id: {user_id}\")\n\n    try:\n        user_agent = request.headers.get(\"user-agent\", \"\")\n        current_time = datetime.now(UTC)\n\n        client = request.client\n        if client is None:\n            logger.error(\"Request client is None. Cannot retrieve IP address.\")\n            raise ValueError(\"Invalid request client.\")\n\n        device_info = self.parse_user_agent(user_agent).model_dump()\n\n        ip_address = (\n            request.headers.get(\"x-forwarded-for\", client.host)\n            .split(\",\")[0]\n            .strip()\n        )\n\n        await self._enforce_session_limit(user_id)\n\n        session_data = SessionCreate(\n            user_id=user_id,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            device_info=device_info,\n            last_activity=current_time,\n            is_active=True,\n            metadata=metadata or {},\n        )\n\n        session_id = await self.storage.create(session_data)\n        csrf_token = await self._generate_csrf_token(user_id, session_id)\n\n        logger.info(f\"Session {session_id} created successfully\")\n        return session_id, csrf_token\n\n    except Exception as e:\n        logger.error(f\"Error creating session: {str(e)}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.parse_user_agent","title":"<code>parse_user_agent(user_agent_string)</code>","text":"<p>Parse User-Agent string into structured information.</p> <p>Parameters:</p> Name Type Description Default <code>user_agent_string</code> <code>str</code> <p>Raw User-Agent header</p> required <p>Returns:</p> Type Description <code>UserAgentInfo</code> <p>Structured UserAgentInfo</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>def parse_user_agent(self, user_agent_string: str) -&gt; UserAgentInfo:\n    \"\"\"Parse User-Agent string into structured information.\n\n    Args:\n        user_agent_string: Raw User-Agent header\n\n    Returns:\n        Structured UserAgentInfo\n    \"\"\"\n    ua_parser = parse(user_agent_string)\n    return UserAgentInfo(\n        browser=ua_parser.browser.family,\n        browser_version=ua_parser.browser.version_string,\n        os=ua_parser.os.family,\n        device=ua_parser.device.family,\n        is_mobile=ua_parser.is_mobile,\n        is_tablet=ua_parser.is_tablet,\n        is_pc=ua_parser.is_pc,\n    )\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.regenerate_csrf_token","title":"<code>regenerate_csrf_token(user_id, session_id)</code>  <code>async</code>","text":"<p>Regenerate a CSRF token for an existing session.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>The new CSRF token</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def regenerate_csrf_token(\n    self,\n    user_id: int,\n    session_id: str,\n) -&gt; str:\n    \"\"\"Regenerate a CSRF token for an existing session.\n\n    Args:\n        user_id: The user ID\n        session_id: The session ID\n\n    Returns:\n        The new CSRF token\n    \"\"\"\n    try:\n        if hasattr(self.csrf_storage, \"_scan_iter\"):\n            keys = await self.csrf_storage._scan_iter(\n                match=f\"{self.csrf_storage.prefix}*\"\n            )\n            for key in keys:\n                try:\n                    token_id = key[len(self.csrf_storage.prefix) :]\n                    csrf_data = await self.csrf_storage.get(token_id, CSRFToken)\n                    if csrf_data and csrf_data.session_id == session_id:\n                        await self.csrf_storage.delete(token_id)\n                except Exception as e:\n                    logger.warning(f\"Error cleaning up old CSRF token: {e}\")\n    except Exception as e:\n        logger.warning(f\"Error scanning for old CSRF tokens: {e}\")\n\n    return await self._generate_csrf_token(user_id, session_id)\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.set_session_cookies","title":"<code>set_session_cookies(response, session_id, csrf_token, max_age=None, path='/', secure=True)</code>","text":"<p>Set session cookies in the response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The response object</p> required <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>csrf_token</code> <code>str</code> <p>The CSRF token</p> required <code>max_age</code> <code>Optional[int]</code> <p>Cookie max age in seconds</p> <code>None</code> <code>path</code> <code>str</code> <p>Cookie path</p> <code>'/'</code> <code>secure</code> <code>bool</code> <p>Whether to set the Secure flag</p> <code>True</code> Source code in <code>crudadmin/session/manager.py</code> <pre><code>def set_session_cookies(\n    self,\n    response: Response,\n    session_id: str,\n    csrf_token: str,\n    max_age: Optional[int] = None,\n    path: str = \"/\",\n    secure: bool = True,\n) -&gt; None:\n    \"\"\"Set session cookies in the response.\n\n    Args:\n        response: The response object\n        session_id: The session ID\n        csrf_token: The CSRF token\n        max_age: Cookie max age in seconds\n        path: Cookie path\n        secure: Whether to set the Secure flag\n    \"\"\"\n    settings = get_settings()\n    samesite: SamesiteType = DEV_SAMESITE if settings.DEBUG else PROD_SAMESITE\n    cookie_max_age = (\n        max_age if max_age is not None else settings.SESSION_COOKIE_MAX_AGE\n    )\n\n    response.set_cookie(\n        key=\"session_id\",\n        value=session_id,\n        httponly=True,\n        secure=secure,\n        samesite=samesite,\n        path=path,\n        max_age=cookie_max_age,\n    )\n\n    response.set_cookie(\n        key=\"csrf_token\",\n        value=csrf_token,\n        httponly=False,\n        secure=secure,\n        samesite=samesite,\n        path=path,\n        max_age=cookie_max_age,\n    )\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.terminate_session","title":"<code>terminate_session(session_id)</code>  <code>async</code>","text":"<p>Terminate a specific session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was terminated, False otherwise</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def terminate_session(self, session_id: str) -&gt; bool:\n    \"\"\"Terminate a specific session.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was terminated, False otherwise\n    \"\"\"\n    try:\n        session_data = await self.storage.get(session_id, SessionData)\n        if session_data is None:\n            return False\n\n        session_data.is_active = False\n        session_data.metadata = {\n            **session_data.metadata,\n            \"terminated_at\": datetime.now(UTC).isoformat(),\n            \"termination_reason\": \"manual_termination\",\n        }\n\n        return await self.storage.update(session_id, session_data)\n\n    except Exception as e:\n        logger.error(f\"Error terminating session: {str(e)}\", exc_info=True)\n        return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.track_login_attempt","title":"<code>track_login_attempt(ip_address, username, success=False)</code>  <code>async</code>","text":"<p>Track login attempts and apply rate limiting.</p> <p>Parameters:</p> Name Type Description Default <code>ip_address</code> <code>str</code> <p>Client IP address</p> required <code>username</code> <code>str</code> <p>Username being used for login</p> required <code>success</code> <code>bool</code> <p>Whether the login attempt was successful</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[bool, Optional[int]]</code> <p>Tuple of (is_allowed, attempts_remaining)</p> <p>If rate limiting is not configured, this will always return (True, None) but log a warning about missing rate limiting.</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def track_login_attempt(\n    self, ip_address: str, username: str, success: bool = False\n) -&gt; tuple[bool, Optional[int]]:\n    \"\"\"Track login attempts and apply rate limiting.\n\n    Args:\n        ip_address: Client IP address\n        username: Username being used for login\n        success: Whether the login attempt was successful\n\n    Returns:\n        Tuple of (is_allowed, attempts_remaining)\n\n    If rate limiting is not configured, this will always return (True, None)\n    but log a warning about missing rate limiting.\n    \"\"\"\n    if not self.rate_limiter:\n        logger.warning(\n            \"No rate limiter configured for login attempts. \"\n            \"It is strongly recommended to configure rate limiting for security.\"\n        )\n        return True, None\n\n    try:\n        ip_key = f\"login:ip:{ip_address}\"\n        username_key = f\"login:user:{username}\"\n\n        if success:\n            try:\n                await self.rate_limiter.delete(ip_key)\n                await self.rate_limiter.delete(username_key)\n                return True, None\n            except Exception as e:\n                logger.warning(\n                    f\"Error clearing rate limit after successful login: {e}\"\n                )\n                return True, None\n\n        try:\n            expiry_seconds = int(self.login_window.total_seconds())\n            ip_count = await self.rate_limiter.increment(ip_key, 1, expiry_seconds)\n            username_count = await self.rate_limiter.increment(\n                username_key, 1, expiry_seconds\n            )\n        except Exception as e:\n            logger.warning(f\"Error tracking login attempt rate limits: {e}\")\n            return True, None\n\n        attempt_count = max(ip_count, username_count)\n        remaining = max(0, self.login_max_attempts - attempt_count)\n\n        is_allowed = attempt_count &lt;= self.login_max_attempts\n\n        if not is_allowed:\n            logger.warning(\n                f\"Rate limit exceeded for login: {ip_address}, username: {username}, attempts: {attempt_count}\"\n            )\n\n        return is_allowed, remaining\n\n    except Exception as e:\n        logger.error(f\"Unexpected error in login rate limiting: {e}\", exc_info=True)\n        return True, None\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.validate_csrf_token","title":"<code>validate_csrf_token(session_id, csrf_token)</code>  <code>async</code>","text":"<p>Validate a CSRF token for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>csrf_token</code> <code>str</code> <p>The CSRF token to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def validate_csrf_token(\n    self,\n    session_id: str,\n    csrf_token: str,\n) -&gt; bool:\n    \"\"\"Validate a CSRF token for a session.\n\n    Args:\n        session_id: The session ID\n        csrf_token: The CSRF token to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    if not session_id or not csrf_token:\n        logger.warning(\n            f\"Missing session_id or csrf_token: session_id={session_id}, csrf_token={csrf_token}\"\n        )\n        return False\n\n    try:\n        token_data = await self.csrf_storage.get(csrf_token, CSRFToken)\n        if token_data is None:\n            logger.warning(f\"CSRF token not found in storage: {csrf_token}\")\n            return False\n\n        if token_data.session_id != session_id:\n            logger.warning(\n                f\"CSRF token session mismatch: {csrf_token} should be for session {session_id}, \"\n                f\"but is for session {token_data.session_id}\"\n            )\n            return False\n\n        current_time = datetime.now(UTC)\n        if token_data.expires_at &lt; current_time:\n            logger.warning(\n                f\"CSRF token expired: {csrf_token}, expired at {token_data.expires_at}, current time is {current_time}\"\n            )\n            await self.csrf_storage.delete(csrf_token)\n            return False\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error validating CSRF token: {str(e)}\", exc_info=True)\n        return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.manager.SessionManager.validate_session","title":"<code>validate_session(session_id, update_activity=True)</code>  <code>async</code>","text":"<p>Validate if a session is active and not timed out.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>update_activity</code> <code>bool</code> <p>Whether to update the last activity timestamp</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[SessionData]</code> <p>The session data if valid, None otherwise</p> Source code in <code>crudadmin/session/manager.py</code> <pre><code>async def validate_session(\n    self, session_id: str, update_activity: bool = True\n) -&gt; Optional[SessionData]:\n    \"\"\"Validate if a session is active and not timed out.\n\n    Args:\n        session_id: The session ID\n        update_activity: Whether to update the last activity timestamp\n\n    Returns:\n        The session data if valid, None otherwise\n    \"\"\"\n    if not session_id:\n        return None\n\n    try:\n        session_data = await self.storage.get(session_id, SessionData)\n        if session_data is None:\n            logger.warning(f\"Session not found: {session_id}\")\n            return None\n\n        if not session_data.is_active:\n            logger.warning(f\"Session is not active: {session_id}\")\n            return None\n\n        current_time = datetime.now(UTC)\n        session_age = current_time - session_data.last_activity\n\n        if session_age &gt; self.session_timeout:\n            logger.warning(f\"Session timed out: {session_id}\")\n            await self.terminate_session(session_id)\n            return None\n\n        if update_activity:\n            session_data.last_activity = current_time\n            await self.storage.update(session_id, session_data)\n\n        return session_data\n\n    except Exception as e:\n        logger.error(f\"Error validating session: {str(e)}\", exc_info=True)\n        return None\n</code></pre>"},{"location":"api/session/#session-storage-backends","title":"Session Storage Backends","text":""},{"location":"api/session/#abstract-base-class","title":"Abstract Base Class","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Abstract base class for session storage implementations.</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>class AbstractSessionStorage(Generic[T], ABC):\n    \"\"\"Abstract base class for session storage implementations.\"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n    ):\n        \"\"\"Initialize the session storage.\n\n        Args:\n            prefix: Prefix for all session keys\n            expiration: Default session expiration in seconds\n        \"\"\"\n        self.prefix = prefix\n        self.expiration = expiration\n\n    def generate_session_id(self) -&gt; str:\n        \"\"\"Generate a unique session ID.\n\n        Returns:\n            A unique session ID string\n        \"\"\"\n        return str(uuid4())\n\n    def get_key(self, session_id: str) -&gt; str:\n        \"\"\"Generate the full key for a session ID.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            The full storage key\n        \"\"\"\n        return f\"{self.prefix}{session_id}\"\n\n    @abstractmethod\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session.\n\n        Args:\n            data: Session data (must be a Pydantic model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            The session ID\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get(self, session_id: str, model_class: Type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data.\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was updated, False if it didn't exist\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete a session.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted, False if it didn't exist\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was extended, False if it didn't exist\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n        \"\"\"Close the storage connection.\"\"\"\n        pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.__init__","title":"<code>__init__(prefix='session:', expiration=1800)</code>","text":"<p>Initialize the session storage.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for all session keys</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds</p> <code>1800</code> Source code in <code>crudadmin/session/storage.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n):\n    \"\"\"Initialize the session storage.\n\n    Args:\n        prefix: Prefix for all session keys\n        expiration: Default session expiration in seconds\n    \"\"\"\n    self.prefix = prefix\n    self.expiration = expiration\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.close","title":"<code>close()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Close the storage connection.</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the storage connection.\"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Create a new session.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a Pydantic model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session.\n\n    Args:\n        data: Session data (must be a Pydantic model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        The session ID\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.delete","title":"<code>delete(session_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Delete a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted, False if it didn't exist</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete a session.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted, False if it didn't exist\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.exists","title":"<code>exists(session_id)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Check if a session exists.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists, False otherwise</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Extend the expiration of a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended, False if it didn't exist</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was extended, False if it didn't exist\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.generate_session_id","title":"<code>generate_session_id()</code>","text":"<p>Generate a unique session ID.</p> <p>Returns:</p> Type Description <code>str</code> <p>A unique session ID string</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>def generate_session_id(self) -&gt; str:\n    \"\"\"Generate a unique session ID.\n\n    Returns:\n        A unique session ID string\n    \"\"\"\n    return str(uuid4())\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get session data.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>Type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def get(self, session_id: str, model_class: Type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data.\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.get_key","title":"<code>get_key(session_id)</code>","text":"<p>Generate the full key for a session ID.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full storage key</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>def get_key(self, session_id: str) -&gt; str:\n    \"\"\"Generate the full key for a session ID.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        The full storage key\n    \"\"\"\n    return f\"{self.prefix}{session_id}\"\n</code></pre>"},{"location":"api/session/#crudadmin.session.storage.AbstractSessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Update session data.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated, False if it didn't exist</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>@abstractmethod\nasync def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was updated, False if it didn't exist\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#storage-factory","title":"Storage Factory","text":"<p>Get the appropriate session storage backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend to use (\"redis\", \"memcached\", \"memory\", \"database\", \"hybrid\")</p> required <code>model_type</code> <code>Type[BaseModel]</code> <p>The pydantic model type for type checking</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the backend</p> <code>{}</code> <p>Returns:</p> Type Description <code>AbstractSessionStorage[T]</code> <p>An initialized storage backend</p> Source code in <code>crudadmin/session/storage.py</code> <pre><code>def get_session_storage(\n    backend: str, model_type: Type[BaseModel], **kwargs: Any\n) -&gt; AbstractSessionStorage[T]:\n    \"\"\"Get the appropriate session storage backend.\n\n    Args:\n        backend: The backend to use (\"redis\", \"memcached\", \"memory\", \"database\", \"hybrid\")\n        model_type: The pydantic model type for type checking\n        **kwargs: Additional arguments to pass to the backend\n\n    Returns:\n        An initialized storage backend\n    \"\"\"\n    if backend == \"redis\":\n        from .backends.redis import RedisSessionStorage\n\n        return RedisSessionStorage(**kwargs)\n    elif backend == \"memcached\":\n        from .backends.memcached import MemcachedSessionStorage\n\n        return MemcachedSessionStorage(**kwargs)\n    elif backend == \"memory\":\n        from .backends.memory import MemorySessionStorage\n\n        return MemorySessionStorage(**kwargs)\n    elif backend == \"database\":\n        from .backends.database import DatabaseSessionStorage\n\n        return DatabaseSessionStorage(**kwargs)\n    elif backend == \"hybrid\":\n        from .backends.hybrid import HybridSessionStorage\n\n        db_config = kwargs.pop(\"db_config\", None)\n        if not db_config:\n            raise ValueError(\"db_config is required for hybrid backend\")\n\n        redis_kwargs = {k: v for k, v in kwargs.items() if k not in [\"db_config\"]}\n        from .backends.redis import RedisSessionStorage\n\n        redis_storage: RedisSessionStorage[T] = RedisSessionStorage(**redis_kwargs)\n\n        from .backends.database import DatabaseSessionStorage\n\n        database_storage: DatabaseSessionStorage[T] = DatabaseSessionStorage(\n            db_config=db_config, **kwargs\n        )\n\n        return HybridSessionStorage(\n            redis_storage=redis_storage, database_storage=database_storage, **kwargs\n        )\n    else:\n        raise ValueError(f\"Unknown backend: {backend}\")\n</code></pre>"},{"location":"api/session/#session-storage-implementations","title":"Session Storage Implementations","text":""},{"location":"api/session/#memory-storage","title":"Memory Storage","text":"<p>               Bases: <code>AbstractSessionStorage[T]</code></p> <p>In-memory implementation of session storage for testing.</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>class MemorySessionStorage(AbstractSessionStorage[T]):\n    \"\"\"In-memory implementation of session storage for testing.\"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n    ):\n        \"\"\"Initialize the in-memory session storage.\n\n        Args:\n            prefix: Prefix for all session keys\n            expiration: Default session expiration in seconds\n        \"\"\"\n        super().__init__(prefix=prefix, expiration=expiration)\n        self.data: dict[str, bytes] = {}\n        self.expiry: dict[str, datetime] = {}\n\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session in memory.\n\n        Args:\n            data: Session data (must be a Pydantic model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            The session ID\n        \"\"\"\n        if session_id is None:\n            session_id = self.generate_session_id()\n\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        json_data = data.model_dump_json()\n\n        value_bytes = (\n            json_data.encode(\"utf-8\") if isinstance(json_data, str) else json_data\n        )\n\n        self.data[key] = value_bytes\n        self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n\n        logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n        return session_id\n\n    async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data from memory.\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        if self._check_expiry(key):\n            return None\n\n        data_bytes = self.data.get(key)\n        if data_bytes is None:\n            return None\n\n        try:\n            data_str = (\n                data_bytes.decode(\"utf-8\")\n                if isinstance(data_bytes, bytes)\n                else data_bytes\n            )\n            json_data = json.loads(data_str)\n            return model_class.model_validate(json_data)\n        except (json.JSONDecodeError, ValueError) as e:\n            logger.error(f\"Error parsing session data: {e}\")\n            return None\n\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data in memory.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was updated, False if it didn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        if key not in self.data or self._check_expiry(key):\n            return False\n\n        json_data = data.model_dump_json()\n        value_bytes = (\n            json_data.encode(\"utf-8\") if isinstance(json_data, str) else json_data\n        )\n\n        self.data[key] = value_bytes\n\n        if reset_expiration:\n            exp = expiration if expiration is not None else self.expiration\n            self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n\n        return True\n\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete a session from memory.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted, False if it didn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        if key in self.data:\n            del self.data[key]\n            if key in self.expiry:\n                del self.expiry[key]\n            return True\n        return False\n\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session in memory.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was extended, False if it didn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        if key in self.data and not self._check_expiry(key):\n            self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n            return True\n        return False\n\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists in memory.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists, False otherwise\n        \"\"\"\n        key = self.get_key(session_id)\n        return key in self.data and not self._check_expiry(key)\n\n    async def _scan_iter(self, match: Optional[str] = None) -&gt; list[str]:\n        \"\"\"Scan for keys matching a pattern.\n\n        Args:\n            match: Pattern to match\n\n        Returns:\n            List of matching keys\n        \"\"\"\n        if match:\n            pattern = match.replace(\"*\", \".*\").replace(\"?\", \".\")\n            pattern = f\"^{pattern}$\"\n            regex: Pattern = re.compile(pattern)\n\n            matching_keys = []\n            for key in list(self.data.keys()):\n                if self._check_expiry(key):\n                    continue\n\n                if regex.match(key):\n                    matching_keys.append(key)\n            return matching_keys\n        else:\n            return [\n                key for key in list(self.data.keys()) if not self._check_expiry(key)\n            ]\n\n    def _check_expiry(self, key: str) -&gt; bool:\n        \"\"\"Check if a key has expired and remove it if so.\n\n        Args:\n            key: The key to check\n\n        Returns:\n            True if expired (and removed), False otherwise\n        \"\"\"\n        if key in self.expiry and datetime.now(UTC) &gt; self.expiry[key]:\n            del self.data[key]\n            del self.expiry[key]\n            return True\n        return False\n\n    async def close(self) -&gt; None:\n        \"\"\"Clear all data.\"\"\"\n        self.data.clear()\n        self.expiry.clear()\n\n    async def delete_pattern(self, pattern: str) -&gt; int:\n        \"\"\"Delete all keys matching a pattern.\n\n        Args:\n            pattern: The pattern to match keys (e.g., \"login:*\")\n\n        Returns:\n            Number of keys deleted\n        \"\"\"\n        matching_keys = await self._scan_iter(match=pattern)\n\n        deleted_count = 0\n        for key in matching_keys:\n            if key in self.data:\n                del self.data[key]\n                if key in self.expiry:\n                    del self.expiry[key]\n                deleted_count += 1\n\n        logger.debug(f\"Deleted {deleted_count} keys matching pattern '{pattern}'\")\n        return deleted_count\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.__init__","title":"<code>__init__(prefix='session:', expiration=1800)</code>","text":"<p>Initialize the in-memory session storage.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for all session keys</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds</p> <code>1800</code> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n):\n    \"\"\"Initialize the in-memory session storage.\n\n    Args:\n        prefix: Prefix for all session keys\n        expiration: Default session expiration in seconds\n    \"\"\"\n    super().__init__(prefix=prefix, expiration=expiration)\n    self.data: dict[str, bytes] = {}\n    self.expiry: dict[str, datetime] = {}\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Clear all data.</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Clear all data.\"\"\"\n    self.data.clear()\n    self.expiry.clear()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>async</code>","text":"<p>Create a new session in memory.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a Pydantic model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session in memory.\n\n    Args:\n        data: Session data (must be a Pydantic model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        The session ID\n    \"\"\"\n    if session_id is None:\n        session_id = self.generate_session_id()\n\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    json_data = data.model_dump_json()\n\n    value_bytes = (\n        json_data.encode(\"utf-8\") if isinstance(json_data, str) else json_data\n    )\n\n    self.data[key] = value_bytes\n    self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n\n    logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n    return session_id\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.delete","title":"<code>delete(session_id)</code>  <code>async</code>","text":"<p>Delete a session from memory.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete a session from memory.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted, False if it didn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    if key in self.data:\n        del self.data[key]\n        if key in self.expiry:\n            del self.expiry[key]\n        return True\n    return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.delete_pattern","title":"<code>delete_pattern(pattern)</code>  <code>async</code>","text":"<p>Delete all keys matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>The pattern to match keys (e.g., \"login:*\")</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of keys deleted</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def delete_pattern(self, pattern: str) -&gt; int:\n    \"\"\"Delete all keys matching a pattern.\n\n    Args:\n        pattern: The pattern to match keys (e.g., \"login:*\")\n\n    Returns:\n        Number of keys deleted\n    \"\"\"\n    matching_keys = await self._scan_iter(match=pattern)\n\n    deleted_count = 0\n    for key in matching_keys:\n        if key in self.data:\n            del self.data[key]\n            if key in self.expiry:\n                del self.expiry[key]\n            deleted_count += 1\n\n    logger.debug(f\"Deleted {deleted_count} keys matching pattern '{pattern}'\")\n    return deleted_count\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.exists","title":"<code>exists(session_id)</code>  <code>async</code>","text":"<p>Check if a session exists in memory.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists, False otherwise</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists in memory.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists, False otherwise\n    \"\"\"\n    key = self.get_key(session_id)\n    return key in self.data and not self._check_expiry(key)\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>async</code>","text":"<p>Extend the expiration of a session in memory.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session in memory.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was extended, False if it didn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    if key in self.data and not self._check_expiry(key):\n        self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n        return True\n    return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>async</code>","text":"<p>Get session data from memory.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data from memory.\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    if self._check_expiry(key):\n        return None\n\n    data_bytes = self.data.get(key)\n    if data_bytes is None:\n        return None\n\n    try:\n        data_str = (\n            data_bytes.decode(\"utf-8\")\n            if isinstance(data_bytes, bytes)\n            else data_bytes\n        )\n        json_data = json.loads(data_str)\n        return model_class.model_validate(json_data)\n    except (json.JSONDecodeError, ValueError) as e:\n        logger.error(f\"Error parsing session data: {e}\")\n        return None\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memory.MemorySessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>async</code>","text":"<p>Update session data in memory.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/memory.py</code> <pre><code>async def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data in memory.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was updated, False if it didn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    if key not in self.data or self._check_expiry(key):\n        return False\n\n    json_data = data.model_dump_json()\n    value_bytes = (\n        json_data.encode(\"utf-8\") if isinstance(json_data, str) else json_data\n    )\n\n    self.data[key] = value_bytes\n\n    if reset_expiration:\n        exp = expiration if expiration is not None else self.expiration\n        self.expiry[key] = datetime.now(UTC) + timedelta(seconds=exp)\n\n    return True\n</code></pre>"},{"location":"api/session/#redis-storage","title":"Redis Storage","text":"<p>               Bases: <code>AbstractSessionStorage[T]</code></p> <p>Redis implementation of session storage.</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>class RedisSessionStorage(AbstractSessionStorage[T]):\n    \"\"\"Redis implementation of session storage.\"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n        host: str = \"localhost\",\n        port: int = 6379,\n        db: int = 0,\n        password: Optional[str] = None,\n        pool_size: int = 10,\n        connect_timeout: int = 10,\n    ):\n        \"\"\"Initialize the Redis session storage.\n\n        Args:\n            prefix: Prefix for all session keys\n            expiration: Default session expiration in seconds\n            host: Redis host\n            port: Redis port\n            db: Redis database number\n            password: Redis password\n            pool_size: Redis connection pool size\n            connect_timeout: Redis connection timeout\n        \"\"\"\n        super().__init__(prefix=prefix, expiration=expiration)\n\n        self.client = Redis(\n            host=host,\n            port=port,\n            db=db,\n            password=password,\n            socket_timeout=connect_timeout,\n            socket_connect_timeout=connect_timeout,\n            socket_keepalive=True,\n            decode_responses=False,\n            max_connections=pool_size,\n        )\n\n        self.user_sessions_prefix = f\"{prefix}user:\"\n\n    def get_user_sessions_key(self, user_id: int) -&gt; str:\n        \"\"\"Get the key for a user's sessions set.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            The Redis key for the user's sessions set\n        \"\"\"\n        return f\"{self.user_sessions_prefix}{user_id}\"\n\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session in Redis.\n\n        Args:\n            data: Session data (must be a Pydantic model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            The session ID\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        if session_id is None:\n            session_id = self.generate_session_id()\n\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        json_data = data.model_dump_json()\n\n        try:\n            pipeline = self.client.pipeline()\n            pipeline.set(key, json_data, ex=exp)\n\n            if hasattr(data, \"user_id\"):\n                user_id = data.user_id\n                user_sessions_key = self.get_user_sessions_key(user_id)\n\n                pipeline.sadd(user_sessions_key, session_id)\n\n                pipeline.expire(user_sessions_key, exp + 3600)\n\n            await pipeline.execute()\n            logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n            return session_id\n        except RedisError as e:\n            logger.error(f\"Error creating session: {e}\")\n            raise\n\n    async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data from Redis.\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist\n\n        Raises:\n            RedisError: If there is an error with Redis\n            ValueError: If the data cannot be parsed\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            data = await self.client.get(key)\n            if data is None:\n                return None\n\n            try:\n                json_data = json.loads(data)\n                return model_class.model_validate(json_data)\n            except (json.JSONDecodeError, ValueError) as e:\n                logger.error(f\"Error parsing session data: {e}\")\n                return None\n\n        except RedisError as e:\n            logger.error(f\"Error getting session: {e}\")\n            raise\n\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data in Redis.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was updated, False if it didn't exist\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            if not await self.client.exists(key):\n                return False\n\n            json_data = data.model_dump_json()\n            pipeline = self.client.pipeline()\n\n            if reset_expiration:\n                exp = expiration if expiration is not None else self.expiration\n                pipeline.set(key, json_data, ex=exp)\n\n                if hasattr(data, \"user_id\"):\n                    user_id = data.user_id\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n                    pipeline.expire(user_sessions_key, exp + 3600)\n            else:\n                ttl = await self.client.ttl(key)\n                if ttl &gt; 0:\n                    pipeline.set(key, json_data, ex=ttl)\n                else:\n                    exp = expiration if expiration is not None else self.expiration\n                    pipeline.set(key, json_data, ex=exp)\n\n                    if hasattr(data, \"user_id\"):\n                        user_id = data.user_id\n                        user_sessions_key = self.get_user_sessions_key(user_id)\n                        pipeline.expire(user_sessions_key, exp + 3600)\n\n            await pipeline.execute()\n            return True\n\n        except RedisError as e:\n            logger.error(f\"Error updating session: {e}\")\n            raise\n\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete a session from Redis.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted, False if it didn't exist\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            data = await self.client.get(key)\n            if data is None:\n                return False\n\n            pipeline = self.client.pipeline()\n\n            pipeline.delete(key)\n\n            try:\n                json_data = json.loads(data)\n                if \"user_id\" in json_data:\n                    user_id = json_data[\"user_id\"]\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n                    pipeline.srem(user_sessions_key, session_id)\n            except (json.JSONDecodeError, ValueError):\n                pass\n\n            result = await pipeline.execute()\n            return bool(result[0] &gt; 0)\n        except RedisError as e:\n            logger.error(f\"Error deleting session: {e}\")\n            raise\n\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session in Redis.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was extended, False if it didn't exist\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        try:\n            data = await self.client.get(key)\n            if data is None:\n                return False\n\n            pipeline = self.client.pipeline()\n\n            pipeline.expire(key, exp)\n\n            try:\n                json_data = json.loads(data)\n                if \"user_id\" in json_data:\n                    user_id = json_data[\"user_id\"]\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n                    pipeline.expire(user_sessions_key, exp + 3600)\n            except (json.JSONDecodeError, ValueError):\n                pass\n\n            results = await pipeline.execute()\n            return bool(results[0])\n\n        except RedisError as e:\n            logger.error(f\"Error extending session: {e}\")\n            raise\n\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists in Redis.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists, False otherwise\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            exists_result = await self.client.exists(key)\n            return bool(exists_result)\n        except RedisError as e:\n            logger.error(f\"Error checking session existence: {e}\")\n            raise\n\n    async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n        \"\"\"Get all session IDs for a user.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            List of session IDs for the user\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        user_sessions_key = self.get_user_sessions_key(user_id)\n\n        try:\n            members = await self.client.smembers(user_sessions_key)\n            return [m.decode(\"utf-8\") if isinstance(m, bytes) else m for m in members]\n        except RedisError as e:\n            logger.error(f\"Error getting user sessions: {e}\")\n            raise\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the Redis connection.\"\"\"\n        import warnings\n\n        if hasattr(self.client, \"aclose\"):\n            await self.client.aclose()\n        else:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\n                    \"ignore\",\n                    category=DeprecationWarning,\n                    message=\".*Call to deprecated close.*\",\n                )\n                await self.client.close()\n\n    async def delete_pattern(self, pattern: str) -&gt; int:\n        \"\"\"Delete all Redis keys matching a pattern.\n\n        This method is useful for bulk cleanup operations like clearing\n        expired rate limiting keys or other grouped data.\n\n        Args:\n            pattern: The pattern to match keys (e.g., \"login:*\")\n\n        Returns:\n            Number of keys deleted\n\n        Raises:\n            RedisError: If there is an error with Redis\n        \"\"\"\n        try:\n            matched_keys = []\n            async for key in self.client.scan_iter(match=pattern):\n                matched_keys.append(key)\n\n            if not matched_keys:\n                return 0\n\n            pipeline = self.client.pipeline()\n            for key in matched_keys:\n                pipeline.delete(key)\n\n            results = await pipeline.execute()\n            deleted_count = sum(1 for result in results if result &gt; 0)\n\n            logger.debug(f\"Deleted {deleted_count} keys matching pattern '{pattern}'\")\n            return deleted_count\n\n        except RedisError as e:\n            logger.error(f\"Error deleting keys with pattern '{pattern}': {e}\")\n            raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.__init__","title":"<code>__init__(prefix='session:', expiration=1800, host='localhost', port=6379, db=0, password=None, pool_size=10, connect_timeout=10)</code>","text":"<p>Initialize the Redis session storage.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for all session keys</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds</p> <code>1800</code> <code>host</code> <code>str</code> <p>Redis host</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Redis port</p> <code>6379</code> <code>db</code> <code>int</code> <p>Redis database number</p> <code>0</code> <code>password</code> <code>Optional[str]</code> <p>Redis password</p> <code>None</code> <code>pool_size</code> <code>int</code> <p>Redis connection pool size</p> <code>10</code> <code>connect_timeout</code> <code>int</code> <p>Redis connection timeout</p> <code>10</code> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n    host: str = \"localhost\",\n    port: int = 6379,\n    db: int = 0,\n    password: Optional[str] = None,\n    pool_size: int = 10,\n    connect_timeout: int = 10,\n):\n    \"\"\"Initialize the Redis session storage.\n\n    Args:\n        prefix: Prefix for all session keys\n        expiration: Default session expiration in seconds\n        host: Redis host\n        port: Redis port\n        db: Redis database number\n        password: Redis password\n        pool_size: Redis connection pool size\n        connect_timeout: Redis connection timeout\n    \"\"\"\n    super().__init__(prefix=prefix, expiration=expiration)\n\n    self.client = Redis(\n        host=host,\n        port=port,\n        db=db,\n        password=password,\n        socket_timeout=connect_timeout,\n        socket_connect_timeout=connect_timeout,\n        socket_keepalive=True,\n        decode_responses=False,\n        max_connections=pool_size,\n    )\n\n    self.user_sessions_prefix = f\"{prefix}user:\"\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the Redis connection.</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the Redis connection.\"\"\"\n    import warnings\n\n    if hasattr(self.client, \"aclose\"):\n        await self.client.aclose()\n    else:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                category=DeprecationWarning,\n                message=\".*Call to deprecated close.*\",\n            )\n            await self.client.close()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>async</code>","text":"<p>Create a new session in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a Pydantic model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session in Redis.\n\n    Args:\n        data: Session data (must be a Pydantic model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        The session ID\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    if session_id is None:\n        session_id = self.generate_session_id()\n\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    json_data = data.model_dump_json()\n\n    try:\n        pipeline = self.client.pipeline()\n        pipeline.set(key, json_data, ex=exp)\n\n        if hasattr(data, \"user_id\"):\n            user_id = data.user_id\n            user_sessions_key = self.get_user_sessions_key(user_id)\n\n            pipeline.sadd(user_sessions_key, session_id)\n\n            pipeline.expire(user_sessions_key, exp + 3600)\n\n        await pipeline.execute()\n        logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n        return session_id\n    except RedisError as e:\n        logger.error(f\"Error creating session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.delete","title":"<code>delete(session_id)</code>  <code>async</code>","text":"<p>Delete a session from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted, False if it didn't exist</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete a session from Redis.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted, False if it didn't exist\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        data = await self.client.get(key)\n        if data is None:\n            return False\n\n        pipeline = self.client.pipeline()\n\n        pipeline.delete(key)\n\n        try:\n            json_data = json.loads(data)\n            if \"user_id\" in json_data:\n                user_id = json_data[\"user_id\"]\n                user_sessions_key = self.get_user_sessions_key(user_id)\n                pipeline.srem(user_sessions_key, session_id)\n        except (json.JSONDecodeError, ValueError):\n            pass\n\n        result = await pipeline.execute()\n        return bool(result[0] &gt; 0)\n    except RedisError as e:\n        logger.error(f\"Error deleting session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.delete_pattern","title":"<code>delete_pattern(pattern)</code>  <code>async</code>","text":"<p>Delete all Redis keys matching a pattern.</p> <p>This method is useful for bulk cleanup operations like clearing expired rate limiting keys or other grouped data.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>The pattern to match keys (e.g., \"login:*\")</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of keys deleted</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def delete_pattern(self, pattern: str) -&gt; int:\n    \"\"\"Delete all Redis keys matching a pattern.\n\n    This method is useful for bulk cleanup operations like clearing\n    expired rate limiting keys or other grouped data.\n\n    Args:\n        pattern: The pattern to match keys (e.g., \"login:*\")\n\n    Returns:\n        Number of keys deleted\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    try:\n        matched_keys = []\n        async for key in self.client.scan_iter(match=pattern):\n            matched_keys.append(key)\n\n        if not matched_keys:\n            return 0\n\n        pipeline = self.client.pipeline()\n        for key in matched_keys:\n            pipeline.delete(key)\n\n        results = await pipeline.execute()\n        deleted_count = sum(1 for result in results if result &gt; 0)\n\n        logger.debug(f\"Deleted {deleted_count} keys matching pattern '{pattern}'\")\n        return deleted_count\n\n    except RedisError as e:\n        logger.error(f\"Error deleting keys with pattern '{pattern}': {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.exists","title":"<code>exists(session_id)</code>  <code>async</code>","text":"<p>Check if a session exists in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists, False otherwise</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists in Redis.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists, False otherwise\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        exists_result = await self.client.exists(key)\n        return bool(exists_result)\n    except RedisError as e:\n        logger.error(f\"Error checking session existence: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>async</code>","text":"<p>Extend the expiration of a session in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended, False if it didn't exist</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session in Redis.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was extended, False if it didn't exist\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    try:\n        data = await self.client.get(key)\n        if data is None:\n            return False\n\n        pipeline = self.client.pipeline()\n\n        pipeline.expire(key, exp)\n\n        try:\n            json_data = json.loads(data)\n            if \"user_id\" in json_data:\n                user_id = json_data[\"user_id\"]\n                user_sessions_key = self.get_user_sessions_key(user_id)\n                pipeline.expire(user_sessions_key, exp + 3600)\n        except (json.JSONDecodeError, ValueError):\n            pass\n\n        results = await pipeline.execute()\n        return bool(results[0])\n\n    except RedisError as e:\n        logger.error(f\"Error extending session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>async</code>","text":"<p>Get session data from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> <code>ValueError</code> <p>If the data cannot be parsed</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data from Redis.\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist\n\n    Raises:\n        RedisError: If there is an error with Redis\n        ValueError: If the data cannot be parsed\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        data = await self.client.get(key)\n        if data is None:\n            return None\n\n        try:\n            json_data = json.loads(data)\n            return model_class.model_validate(json_data)\n        except (json.JSONDecodeError, ValueError) as e:\n            logger.error(f\"Error parsing session data: {e}\")\n            return None\n\n    except RedisError as e:\n        logger.error(f\"Error getting session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.get_user_sessions","title":"<code>get_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Get all session IDs for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of session IDs for the user</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n    \"\"\"Get all session IDs for a user.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        List of session IDs for the user\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    user_sessions_key = self.get_user_sessions_key(user_id)\n\n    try:\n        members = await self.client.smembers(user_sessions_key)\n        return [m.decode(\"utf-8\") if isinstance(m, bytes) else m for m in members]\n    except RedisError as e:\n        logger.error(f\"Error getting user sessions: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.get_user_sessions_key","title":"<code>get_user_sessions_key(user_id)</code>","text":"<p>Get the key for a user's sessions set.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Redis key for the user's sessions set</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>def get_user_sessions_key(self, user_id: int) -&gt; str:\n    \"\"\"Get the key for a user's sessions set.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        The Redis key for the user's sessions set\n    \"\"\"\n    return f\"{self.user_sessions_prefix}{user_id}\"\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.redis.RedisSessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>async</code>","text":"<p>Update session data in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated, False if it didn't exist</p> <p>Raises:</p> Type Description <code>RedisError</code> <p>If there is an error with Redis</p> Source code in <code>crudadmin/session/backends/redis.py</code> <pre><code>async def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data in Redis.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was updated, False if it didn't exist\n\n    Raises:\n        RedisError: If there is an error with Redis\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        if not await self.client.exists(key):\n            return False\n\n        json_data = data.model_dump_json()\n        pipeline = self.client.pipeline()\n\n        if reset_expiration:\n            exp = expiration if expiration is not None else self.expiration\n            pipeline.set(key, json_data, ex=exp)\n\n            if hasattr(data, \"user_id\"):\n                user_id = data.user_id\n                user_sessions_key = self.get_user_sessions_key(user_id)\n                pipeline.expire(user_sessions_key, exp + 3600)\n        else:\n            ttl = await self.client.ttl(key)\n            if ttl &gt; 0:\n                pipeline.set(key, json_data, ex=ttl)\n            else:\n                exp = expiration if expiration is not None else self.expiration\n                pipeline.set(key, json_data, ex=exp)\n\n                if hasattr(data, \"user_id\"):\n                    user_id = data.user_id\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n                    pipeline.expire(user_sessions_key, exp + 3600)\n\n        await pipeline.execute()\n        return True\n\n    except RedisError as e:\n        logger.error(f\"Error updating session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#memcached-storage","title":"Memcached Storage","text":"<p>               Bases: <code>AbstractSessionStorage[T]</code></p> <p>Memcached implementation of session storage.</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>class MemcachedSessionStorage(AbstractSessionStorage[T]):\n    \"\"\"Memcached implementation of session storage.\"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n        host: str = \"localhost\",\n        port: int = 11211,\n        pool_size: int = 10,\n    ):\n        \"\"\"Initialize the Memcached session storage.\n\n        Args:\n            prefix: Prefix for all session keys\n            expiration: Default session expiration in seconds\n            host: Memcached host\n            port: Memcached port\n            pool_size: Memcached connection pool size\n        \"\"\"\n        super().__init__(prefix=prefix, expiration=expiration)\n\n        self.client = MemcachedClient(\n            host=host,\n            port=port,\n            pool_size=pool_size,\n        )\n\n        self.user_sessions_prefix = f\"{prefix}user:\"\n\n    def _encode_key(self, key: str) -&gt; bytes:\n        \"\"\"Encode a key for Memcached.\n\n        Memcached has a 250 byte key limit, so we hash long keys.\n\n        Args:\n            key: The key to encode\n\n        Returns:\n            The encoded key as bytes\n        \"\"\"\n        if len(key) &gt; 240:\n            key_hash = hashlib.md5(key.encode()).hexdigest()\n            key = f\"{key[:200]}:{key_hash}\"\n        return key.encode(\"utf-8\")\n\n    def get_user_sessions_key(self, user_id: int) -&gt; str:\n        \"\"\"Get the key for a user's sessions.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            The Memcached key for the user's sessions\n        \"\"\"\n        return f\"{self.user_sessions_prefix}{user_id}\"\n\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session in Memcached.\n\n        Args:\n            data: Session data (must be a Pydantic model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            The session ID\n        \"\"\"\n        if session_id is None:\n            session_id = self.generate_session_id()\n\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        json_data = data.model_dump_json().encode(\"utf-8\")\n\n        try:\n            await self.client.set(self._encode_key(key), json_data, exptime=exp)\n\n            if hasattr(data, \"user_id\"):\n                user_id = data.user_id\n                user_sessions_key = self.get_user_sessions_key(user_id)\n\n                user_sessions_data = await self.client.get(\n                    self._encode_key(user_sessions_key)\n                )\n\n                if user_sessions_data:\n                    try:\n                        user_sessions = json.loads(user_sessions_data.decode(\"utf-8\"))\n                        if session_id not in user_sessions:\n                            user_sessions.append(session_id)\n                    except (json.JSONDecodeError, UnicodeDecodeError):\n                        user_sessions = [session_id]\n                else:\n                    user_sessions = [session_id]\n\n                user_sessions_json = json.dumps(user_sessions).encode(\"utf-8\")\n                await self.client.set(\n                    self._encode_key(user_sessions_key),\n                    user_sessions_json,\n                    exptime=exp + 3600,\n                )\n\n            logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n            return session_id\n        except Exception as e:\n            logger.error(f\"Error creating session: {e}\")\n            raise\n\n    async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data from Memcached.\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            data = await self.client.get(self._encode_key(key))\n            if data is None:\n                return None\n\n            try:\n                json_data = json.loads(data.decode(\"utf-8\"))\n                return model_class.model_validate(json_data)\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                logger.error(f\"Error parsing session data: {e}\")\n                return None\n\n        except Exception as e:\n            logger.error(f\"Error getting session: {e}\")\n            raise\n\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data in Memcached.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was updated, False if it didn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            if not await self.client.get(self._encode_key(key)):\n                return False\n\n            json_data = data.model_dump_json().encode(\"utf-8\")\n            exp = expiration if expiration is not None else self.expiration\n\n            await self.client.set(self._encode_key(key), json_data, exptime=exp)\n\n            if reset_expiration and hasattr(data, \"user_id\"):\n                user_id = data.user_id\n                user_sessions_key = self.get_user_sessions_key(user_id)\n\n                user_sessions_data = await self.client.get(\n                    self._encode_key(user_sessions_key)\n                )\n\n                if user_sessions_data:\n                    try:\n                        user_sessions = json.loads(user_sessions_data.decode(\"utf-8\"))\n                        user_sessions_json = json.dumps(user_sessions).encode(\"utf-8\")\n                        await self.client.set(\n                            self._encode_key(user_sessions_key),\n                            user_sessions_json,\n                            exptime=exp + 3600,\n                        )\n                    except (json.JSONDecodeError, UnicodeDecodeError):\n                        pass\n\n            return True\n\n        except Exception as e:\n            logger.error(f\"Error updating session: {e}\")\n            raise\n\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete a session from Memcached.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted, False if it didn't exist\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            session_data = await self.client.get(self._encode_key(key))\n            if session_data is None:\n                return False\n\n            await self.client.delete(self._encode_key(key))\n\n            try:\n                json_data = json.loads(session_data.decode(\"utf-8\"))\n                if \"user_id\" in json_data:\n                    user_id = json_data[\"user_id\"]\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n\n                    user_sessions_data = await self.client.get(\n                        self._encode_key(user_sessions_key)\n                    )\n\n                    if user_sessions_data:\n                        try:\n                            user_sessions = json.loads(\n                                user_sessions_data.decode(\"utf-8\")\n                            )\n                            if session_id in user_sessions:\n                                user_sessions.remove(session_id)\n                                user_sessions_json = json.dumps(user_sessions).encode(\n                                    \"utf-8\"\n                                )\n                                await self.client.set(\n                                    self._encode_key(user_sessions_key),\n                                    user_sessions_json,\n                                    exptime=3600 * 24,\n                                )\n                        except (json.JSONDecodeError, UnicodeDecodeError):\n                            pass\n            except (json.JSONDecodeError, UnicodeDecodeError):\n                pass\n\n            return True\n        except Exception as e:\n            logger.error(f\"Error deleting session: {e}\")\n            raise\n\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session in Memcached.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was extended, False if it didn't exist\n\n        Note:\n            Memcached doesn't allow extending expiration without updating the value.\n            We need to get, then set the value again with a new expiration.\n        \"\"\"\n        key = self.get_key(session_id)\n        exp = expiration if expiration is not None else self.expiration\n\n        try:\n            session_data = await self.client.get(self._encode_key(key))\n            if session_data is None:\n                return False\n\n            await self.client.set(self._encode_key(key), session_data, exptime=exp)\n\n            try:\n                json_data = json.loads(session_data.decode(\"utf-8\"))\n                if \"user_id\" in json_data:\n                    user_id = json_data[\"user_id\"]\n                    user_sessions_key = self.get_user_sessions_key(user_id)\n\n                    user_sessions_data = await self.client.get(\n                        self._encode_key(user_sessions_key)\n                    )\n\n                    if user_sessions_data:\n                        await self.client.set(\n                            self._encode_key(user_sessions_key),\n                            user_sessions_data,\n                            exptime=exp + 3600,\n                        )\n            except (json.JSONDecodeError, UnicodeDecodeError):\n                pass\n\n            return True\n        except Exception as e:\n            logger.error(f\"Error extending session: {e}\")\n            raise\n\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists in Memcached.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists, False otherwise\n        \"\"\"\n        key = self.get_key(session_id)\n\n        try:\n            data = await self.client.get(self._encode_key(key))\n            return data is not None\n        except Exception as e:\n            logger.error(f\"Error checking session existence: {e}\")\n            raise\n\n    async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n        \"\"\"Get all session IDs for a user.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            List of session IDs for the user\n        \"\"\"\n        user_sessions_key = self.get_user_sessions_key(user_id)\n\n        try:\n            data = await self.client.get(self._encode_key(user_sessions_key))\n            if data is None:\n                return []\n\n            try:\n                user_sessions = json.loads(data.decode(\"utf-8\"))\n                if isinstance(user_sessions, list):\n                    return [str(session_id) for session_id in user_sessions]\n                else:\n                    logger.error(f\"User sessions data is not a list: {user_sessions}\")\n                    return []\n            except (json.JSONDecodeError, UnicodeDecodeError) as e:\n                logger.error(f\"Error parsing user sessions data: {e}\")\n                return []\n        except Exception as e:\n            logger.error(f\"Error getting user sessions: {e}\")\n            raise\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the Memcached connection.\"\"\"\n        await self.client.close()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.__init__","title":"<code>__init__(prefix='session:', expiration=1800, host='localhost', port=11211, pool_size=10)</code>","text":"<p>Initialize the Memcached session storage.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for all session keys</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds</p> <code>1800</code> <code>host</code> <code>str</code> <p>Memcached host</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Memcached port</p> <code>11211</code> <code>pool_size</code> <code>int</code> <p>Memcached connection pool size</p> <code>10</code> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n    host: str = \"localhost\",\n    port: int = 11211,\n    pool_size: int = 10,\n):\n    \"\"\"Initialize the Memcached session storage.\n\n    Args:\n        prefix: Prefix for all session keys\n        expiration: Default session expiration in seconds\n        host: Memcached host\n        port: Memcached port\n        pool_size: Memcached connection pool size\n    \"\"\"\n    super().__init__(prefix=prefix, expiration=expiration)\n\n    self.client = MemcachedClient(\n        host=host,\n        port=port,\n        pool_size=pool_size,\n    )\n\n    self.user_sessions_prefix = f\"{prefix}user:\"\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the Memcached connection.</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the Memcached connection.\"\"\"\n    await self.client.close()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>async</code>","text":"<p>Create a new session in Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a Pydantic model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session in Memcached.\n\n    Args:\n        data: Session data (must be a Pydantic model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        The session ID\n    \"\"\"\n    if session_id is None:\n        session_id = self.generate_session_id()\n\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    json_data = data.model_dump_json().encode(\"utf-8\")\n\n    try:\n        await self.client.set(self._encode_key(key), json_data, exptime=exp)\n\n        if hasattr(data, \"user_id\"):\n            user_id = data.user_id\n            user_sessions_key = self.get_user_sessions_key(user_id)\n\n            user_sessions_data = await self.client.get(\n                self._encode_key(user_sessions_key)\n            )\n\n            if user_sessions_data:\n                try:\n                    user_sessions = json.loads(user_sessions_data.decode(\"utf-8\"))\n                    if session_id not in user_sessions:\n                        user_sessions.append(session_id)\n                except (json.JSONDecodeError, UnicodeDecodeError):\n                    user_sessions = [session_id]\n            else:\n                user_sessions = [session_id]\n\n            user_sessions_json = json.dumps(user_sessions).encode(\"utf-8\")\n            await self.client.set(\n                self._encode_key(user_sessions_key),\n                user_sessions_json,\n                exptime=exp + 3600,\n            )\n\n        logger.debug(f\"Created session {session_id} with expiration {exp}s\")\n        return session_id\n    except Exception as e:\n        logger.error(f\"Error creating session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.delete","title":"<code>delete(session_id)</code>  <code>async</code>","text":"<p>Delete a session from Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete a session from Memcached.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted, False if it didn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        session_data = await self.client.get(self._encode_key(key))\n        if session_data is None:\n            return False\n\n        await self.client.delete(self._encode_key(key))\n\n        try:\n            json_data = json.loads(session_data.decode(\"utf-8\"))\n            if \"user_id\" in json_data:\n                user_id = json_data[\"user_id\"]\n                user_sessions_key = self.get_user_sessions_key(user_id)\n\n                user_sessions_data = await self.client.get(\n                    self._encode_key(user_sessions_key)\n                )\n\n                if user_sessions_data:\n                    try:\n                        user_sessions = json.loads(\n                            user_sessions_data.decode(\"utf-8\")\n                        )\n                        if session_id in user_sessions:\n                            user_sessions.remove(session_id)\n                            user_sessions_json = json.dumps(user_sessions).encode(\n                                \"utf-8\"\n                            )\n                            await self.client.set(\n                                self._encode_key(user_sessions_key),\n                                user_sessions_json,\n                                exptime=3600 * 24,\n                            )\n                    except (json.JSONDecodeError, UnicodeDecodeError):\n                        pass\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            pass\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error deleting session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.exists","title":"<code>exists(session_id)</code>  <code>async</code>","text":"<p>Check if a session exists in Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists, False otherwise</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists in Memcached.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists, False otherwise\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        data = await self.client.get(self._encode_key(key))\n        return data is not None\n    except Exception as e:\n        logger.error(f\"Error checking session existence: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>async</code>","text":"<p>Extend the expiration of a session in Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended, False if it didn't exist</p> Note <p>Memcached doesn't allow extending expiration without updating the value. We need to get, then set the value again with a new expiration.</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session in Memcached.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was extended, False if it didn't exist\n\n    Note:\n        Memcached doesn't allow extending expiration without updating the value.\n        We need to get, then set the value again with a new expiration.\n    \"\"\"\n    key = self.get_key(session_id)\n    exp = expiration if expiration is not None else self.expiration\n\n    try:\n        session_data = await self.client.get(self._encode_key(key))\n        if session_data is None:\n            return False\n\n        await self.client.set(self._encode_key(key), session_data, exptime=exp)\n\n        try:\n            json_data = json.loads(session_data.decode(\"utf-8\"))\n            if \"user_id\" in json_data:\n                user_id = json_data[\"user_id\"]\n                user_sessions_key = self.get_user_sessions_key(user_id)\n\n                user_sessions_data = await self.client.get(\n                    self._encode_key(user_sessions_key)\n                )\n\n                if user_sessions_data:\n                    await self.client.set(\n                        self._encode_key(user_sessions_key),\n                        user_sessions_data,\n                        exptime=exp + 3600,\n                    )\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            pass\n\n        return True\n    except Exception as e:\n        logger.error(f\"Error extending session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>async</code>","text":"<p>Get session data from Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data from Memcached.\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        data = await self.client.get(self._encode_key(key))\n        if data is None:\n            return None\n\n        try:\n            json_data = json.loads(data.decode(\"utf-8\"))\n            return model_class.model_validate(json_data)\n        except (json.JSONDecodeError, UnicodeDecodeError) as e:\n            logger.error(f\"Error parsing session data: {e}\")\n            return None\n\n    except Exception as e:\n        logger.error(f\"Error getting session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.get_user_sessions","title":"<code>get_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Get all session IDs for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of session IDs for the user</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n    \"\"\"Get all session IDs for a user.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        List of session IDs for the user\n    \"\"\"\n    user_sessions_key = self.get_user_sessions_key(user_id)\n\n    try:\n        data = await self.client.get(self._encode_key(user_sessions_key))\n        if data is None:\n            return []\n\n        try:\n            user_sessions = json.loads(data.decode(\"utf-8\"))\n            if isinstance(user_sessions, list):\n                return [str(session_id) for session_id in user_sessions]\n            else:\n                logger.error(f\"User sessions data is not a list: {user_sessions}\")\n                return []\n        except (json.JSONDecodeError, UnicodeDecodeError) as e:\n            logger.error(f\"Error parsing user sessions data: {e}\")\n            return []\n    except Exception as e:\n        logger.error(f\"Error getting user sessions: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.get_user_sessions_key","title":"<code>get_user_sessions_key(user_id)</code>","text":"<p>Get the key for a user's sessions.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Memcached key for the user's sessions</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>def get_user_sessions_key(self, user_id: int) -&gt; str:\n    \"\"\"Get the key for a user's sessions.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        The Memcached key for the user's sessions\n    \"\"\"\n    return f\"{self.user_sessions_prefix}{user_id}\"\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.memcached.MemcachedSessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>async</code>","text":"<p>Update session data in Memcached.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/memcached.py</code> <pre><code>async def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data in Memcached.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was updated, False if it didn't exist\n    \"\"\"\n    key = self.get_key(session_id)\n\n    try:\n        if not await self.client.get(self._encode_key(key)):\n            return False\n\n        json_data = data.model_dump_json().encode(\"utf-8\")\n        exp = expiration if expiration is not None else self.expiration\n\n        await self.client.set(self._encode_key(key), json_data, exptime=exp)\n\n        if reset_expiration and hasattr(data, \"user_id\"):\n            user_id = data.user_id\n            user_sessions_key = self.get_user_sessions_key(user_id)\n\n            user_sessions_data = await self.client.get(\n                self._encode_key(user_sessions_key)\n            )\n\n            if user_sessions_data:\n                try:\n                    user_sessions = json.loads(user_sessions_data.decode(\"utf-8\"))\n                    user_sessions_json = json.dumps(user_sessions).encode(\"utf-8\")\n                    await self.client.set(\n                        self._encode_key(user_sessions_key),\n                        user_sessions_json,\n                        exptime=exp + 3600,\n                    )\n                except (json.JSONDecodeError, UnicodeDecodeError):\n                    pass\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error updating session: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#database-storage","title":"Database Storage","text":"<p>               Bases: <code>AbstractSessionStorage[T]</code></p> <p>Database implementation of session storage using AdminSession table.</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>class DatabaseSessionStorage(AbstractSessionStorage[T]):\n    \"\"\"Database implementation of session storage using AdminSession table.\"\"\"\n\n    def __init__(\n        self,\n        db_config: DatabaseConfig,\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n    ):\n        \"\"\"Initialize the Database session storage.\n\n        Args:\n            db_config: Database configuration instance\n            prefix: Prefix for all session keys (kept for compatibility)\n            expiration: Default session expiration in seconds (used for cleanup)\n        \"\"\"\n        super().__init__(prefix=prefix, expiration=expiration)\n        self.db_config = db_config\n\n    async def _get_db(self) -&gt; AsyncSession:\n        \"\"\"Get database session.\"\"\"\n        return self.db_config.get_admin_session()\n\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session in the database.\n\n        Args:\n            data: Session data (must be a SessionData-compatible model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds (stored but not enforced)\n\n        Returns:\n            The session ID\n        \"\"\"\n        if session_id is None:\n            session_id = self.generate_session_id()\n\n        db = await self._get_db()\n\n        try:\n            if hasattr(data, \"model_dump\"):\n                data_dict = data.model_dump()\n            else:\n                data_dict = data.__dict__\n\n            session_create = AdminSessionCreate(\n                user_id=data_dict.get(\"user_id\") or 0,\n                session_id=session_id,\n                ip_address=data_dict.get(\"ip_address\", \"\"),\n                user_agent=data_dict.get(\"user_agent\", \"\"),\n                device_info=data_dict.get(\"device_info\", {}),\n                session_metadata=data_dict.get(\"metadata\", {}),\n                is_active=data_dict.get(\"is_active\", True),\n                created_at=data_dict.get(\"created_at\", datetime.now(UTC)),\n                last_activity=data_dict.get(\"last_activity\", datetime.now(UTC)),\n            )\n\n            await self.db_config.crud_sessions.create(db=db, object=session_create)\n            await db.commit()\n\n            logger.debug(f\"Created session {session_id} in database\")\n            return session_id\n\n        except Exception as e:\n            await db.rollback()\n            logger.error(f\"Error creating session in database: {e}\")\n            raise\n\n    async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data from the database.\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            session_record = await self.db_config.crud_sessions.get(\n                db=db, session_id=session_id\n            )\n\n            if not session_record:\n                return None\n\n            session_dict: dict[str, Any]\n            if hasattr(session_record, \"user_id\"):\n                assert not isinstance(session_record, dict), (\n                    \"Expected AdminSessionRead object\"\n                )\n                session_dict = {\n                    \"user_id\": session_record.user_id,\n                    \"session_id\": session_record.session_id,\n                    \"ip_address\": session_record.ip_address,\n                    \"user_agent\": session_record.user_agent,\n                    \"device_info\": session_record.device_info,\n                    \"created_at\": session_record.created_at.replace(tzinfo=UTC)\n                    if session_record.created_at.tzinfo is None\n                    else session_record.created_at,\n                    \"last_activity\": session_record.last_activity.replace(tzinfo=UTC)\n                    if session_record.last_activity.tzinfo is None\n                    else session_record.last_activity,\n                    \"is_active\": session_record.is_active,\n                    \"metadata\": session_record.session_metadata,\n                }\n            elif isinstance(session_record, dict):\n                created_at = session_record.get(\"created_at\")\n                last_activity = session_record.get(\"last_activity\")\n\n                if (\n                    created_at\n                    and hasattr(created_at, \"tzinfo\")\n                    and created_at.tzinfo is None\n                ):\n                    created_at = created_at.replace(tzinfo=UTC)\n                if (\n                    last_activity\n                    and hasattr(last_activity, \"tzinfo\")\n                    and last_activity.tzinfo is None\n                ):\n                    last_activity = last_activity.replace(tzinfo=UTC)\n\n                session_dict = {\n                    \"user_id\": session_record.get(\"user_id\"),\n                    \"session_id\": session_record.get(\"session_id\"),\n                    \"ip_address\": session_record.get(\"ip_address\", \"\"),\n                    \"user_agent\": session_record.get(\"user_agent\", \"\"),\n                    \"device_info\": session_record.get(\"device_info\", {}),\n                    \"created_at\": created_at,\n                    \"last_activity\": last_activity,\n                    \"is_active\": session_record.get(\"is_active\", True),\n                    \"metadata\": session_record.get(\"session_metadata\", {}),\n                }\n            else:\n                return None\n\n            return model_class.model_validate(session_dict)\n\n        except Exception as e:\n            logger.error(f\"Error getting session from database: {e}\")\n            return None\n\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data in the database.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration (updates last_activity)\n            expiration: Optional custom expiration in seconds (ignored for database)\n\n        Returns:\n            True if the session was updated, False if it didn't exist\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            existing = await self.db_config.crud_sessions.get(\n                db=db, session_id=session_id\n            )\n            if not existing:\n                return False\n\n            if hasattr(data, \"model_dump\"):\n                data_dict = data.model_dump()\n            else:\n                data_dict = data.__dict__\n\n            update_data = AdminSessionUpdate(\n                last_activity=data_dict.get(\"last_activity\", datetime.now(UTC))\n                if reset_expiration\n                else None,\n                is_active=data_dict.get(\"is_active\"),\n                session_metadata=data_dict.get(\"metadata\"),\n            )\n\n            update_dict = {\n                k: v for k, v in update_data.model_dump().items() if v is not None\n            }\n\n            if update_dict:\n                await self.db_config.crud_sessions.update(\n                    db=db, object=update_dict, session_id=session_id\n                )\n                await db.commit()\n\n            return True\n\n        except Exception as e:\n            await db.rollback()\n            logger.error(f\"Error updating session in database: {e}\")\n            return False\n\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete a session from the database.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted, False if it didn't exist\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            existing = await self.db_config.crud_sessions.get(\n                db=db, session_id=session_id\n            )\n            if not existing:\n                return False\n\n            update_data = AdminSessionUpdate(\n                is_active=False,\n                last_activity=datetime.now(UTC),\n            )\n\n            await self.db_config.crud_sessions.update(\n                db=db, object=update_data.model_dump(), session_id=session_id\n            )\n            await db.commit()\n\n            logger.debug(f\"Marked session {session_id} as inactive in database\")\n            return True\n\n        except Exception as e:\n            await db.rollback()\n            logger.error(f\"Error deleting session from database: {e}\")\n            return False\n\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds (ignored for database)\n\n        Returns:\n            True if the session was extended, False if it didn't exist\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            existing = await self.db_config.crud_sessions.get(\n                db=db, session_id=session_id\n            )\n            if not existing:\n                return False\n\n            update_data = AdminSessionUpdate(\n                last_activity=datetime.now(UTC),\n            )\n\n            await self.db_config.crud_sessions.update(\n                db=db, object=update_data.model_dump(), session_id=session_id\n            )\n            await db.commit()\n\n            return True\n\n        except Exception as e:\n            await db.rollback()\n            logger.error(f\"Error extending session in database: {e}\")\n            return False\n\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists in the database.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists, False otherwise\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            session_record = await self.db_config.crud_sessions.get(\n                db=db, session_id=session_id\n            )\n            return session_record is not None\n\n        except Exception as e:\n            logger.error(f\"Error checking session existence in database: {e}\")\n            return False\n\n    async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n        \"\"\"Get all active session IDs for a user.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            List of session IDs for the user\n        \"\"\"\n        db = await self._get_db()\n\n        try:\n            sessions = await self.db_config.crud_sessions.get_multi(\n                db=db, user_id=user_id, is_active=True\n            )\n\n            session_data: list[Any] = []\n            if isinstance(sessions, dict) and \"data\" in sessions:\n                session_data = sessions[\"data\"]  # type: ignore[assignment]\n            elif isinstance(sessions, list):\n                session_data = sessions  # type: ignore[assignment]\n            elif isinstance(sessions, int):\n                return []\n            elif hasattr(sessions, \"__iter__\") and not isinstance(\n                sessions, (str, bytes)\n            ):\n                try:\n                    session_data = list(sessions)\n                except (TypeError, ValueError):\n                    logger.warning(\n                        f\"Could not convert sessions to list: {type(sessions)}\"\n                    )\n                    return []\n            else:\n                logger.warning(f\"Unexpected sessions format: {type(sessions)}\")\n                return []\n\n            session_ids = []\n            for session in session_data:\n                if hasattr(session, \"session_id\"):\n                    session_ids.append(session.session_id)\n                elif isinstance(session, dict) and \"session_id\" in session:\n                    session_ids.append(session[\"session_id\"])\n\n            return session_ids\n\n        except Exception as e:\n            logger.error(f\"Error getting user sessions from database: {e}\")\n            return []\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the database connection (no-op for database storage).\"\"\"\n        pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.__init__","title":"<code>__init__(db_config, prefix='session:', expiration=1800)</code>","text":"<p>Initialize the Database session storage.</p> <p>Parameters:</p> Name Type Description Default <code>db_config</code> <code>DatabaseConfig</code> <p>Database configuration instance</p> required <code>prefix</code> <code>str</code> <p>Prefix for all session keys (kept for compatibility)</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds (used for cleanup)</p> <code>1800</code> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>def __init__(\n    self,\n    db_config: DatabaseConfig,\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n):\n    \"\"\"Initialize the Database session storage.\n\n    Args:\n        db_config: Database configuration instance\n        prefix: Prefix for all session keys (kept for compatibility)\n        expiration: Default session expiration in seconds (used for cleanup)\n    \"\"\"\n    super().__init__(prefix=prefix, expiration=expiration)\n    self.db_config = db_config\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the database connection (no-op for database storage).</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the database connection (no-op for database storage).\"\"\"\n    pass\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>async</code>","text":"<p>Create a new session in the database.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a SessionData-compatible model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds (stored but not enforced)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session in the database.\n\n    Args:\n        data: Session data (must be a SessionData-compatible model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds (stored but not enforced)\n\n    Returns:\n        The session ID\n    \"\"\"\n    if session_id is None:\n        session_id = self.generate_session_id()\n\n    db = await self._get_db()\n\n    try:\n        if hasattr(data, \"model_dump\"):\n            data_dict = data.model_dump()\n        else:\n            data_dict = data.__dict__\n\n        session_create = AdminSessionCreate(\n            user_id=data_dict.get(\"user_id\") or 0,\n            session_id=session_id,\n            ip_address=data_dict.get(\"ip_address\", \"\"),\n            user_agent=data_dict.get(\"user_agent\", \"\"),\n            device_info=data_dict.get(\"device_info\", {}),\n            session_metadata=data_dict.get(\"metadata\", {}),\n            is_active=data_dict.get(\"is_active\", True),\n            created_at=data_dict.get(\"created_at\", datetime.now(UTC)),\n            last_activity=data_dict.get(\"last_activity\", datetime.now(UTC)),\n        )\n\n        await self.db_config.crud_sessions.create(db=db, object=session_create)\n        await db.commit()\n\n        logger.debug(f\"Created session {session_id} in database\")\n        return session_id\n\n    except Exception as e:\n        await db.rollback()\n        logger.error(f\"Error creating session in database: {e}\")\n        raise\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.delete","title":"<code>delete(session_id)</code>  <code>async</code>","text":"<p>Delete a session from the database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete a session from the database.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted, False if it didn't exist\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        existing = await self.db_config.crud_sessions.get(\n            db=db, session_id=session_id\n        )\n        if not existing:\n            return False\n\n        update_data = AdminSessionUpdate(\n            is_active=False,\n            last_activity=datetime.now(UTC),\n        )\n\n        await self.db_config.crud_sessions.update(\n            db=db, object=update_data.model_dump(), session_id=session_id\n        )\n        await db.commit()\n\n        logger.debug(f\"Marked session {session_id} as inactive in database\")\n        return True\n\n    except Exception as e:\n        await db.rollback()\n        logger.error(f\"Error deleting session from database: {e}\")\n        return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.exists","title":"<code>exists(session_id)</code>  <code>async</code>","text":"<p>Check if a session exists in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists, False otherwise</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists in the database.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists, False otherwise\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        session_record = await self.db_config.crud_sessions.get(\n            db=db, session_id=session_id\n        )\n        return session_record is not None\n\n    except Exception as e:\n        logger.error(f\"Error checking session existence in database: {e}\")\n        return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>async</code>","text":"<p>Extend the expiration of a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds (ignored for database)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds (ignored for database)\n\n    Returns:\n        True if the session was extended, False if it didn't exist\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        existing = await self.db_config.crud_sessions.get(\n            db=db, session_id=session_id\n        )\n        if not existing:\n            return False\n\n        update_data = AdminSessionUpdate(\n            last_activity=datetime.now(UTC),\n        )\n\n        await self.db_config.crud_sessions.update(\n            db=db, object=update_data.model_dump(), session_id=session_id\n        )\n        await db.commit()\n\n        return True\n\n    except Exception as e:\n        await db.rollback()\n        logger.error(f\"Error extending session in database: {e}\")\n        return False\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>async</code>","text":"<p>Get session data from the database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data from the database.\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        session_record = await self.db_config.crud_sessions.get(\n            db=db, session_id=session_id\n        )\n\n        if not session_record:\n            return None\n\n        session_dict: dict[str, Any]\n        if hasattr(session_record, \"user_id\"):\n            assert not isinstance(session_record, dict), (\n                \"Expected AdminSessionRead object\"\n            )\n            session_dict = {\n                \"user_id\": session_record.user_id,\n                \"session_id\": session_record.session_id,\n                \"ip_address\": session_record.ip_address,\n                \"user_agent\": session_record.user_agent,\n                \"device_info\": session_record.device_info,\n                \"created_at\": session_record.created_at.replace(tzinfo=UTC)\n                if session_record.created_at.tzinfo is None\n                else session_record.created_at,\n                \"last_activity\": session_record.last_activity.replace(tzinfo=UTC)\n                if session_record.last_activity.tzinfo is None\n                else session_record.last_activity,\n                \"is_active\": session_record.is_active,\n                \"metadata\": session_record.session_metadata,\n            }\n        elif isinstance(session_record, dict):\n            created_at = session_record.get(\"created_at\")\n            last_activity = session_record.get(\"last_activity\")\n\n            if (\n                created_at\n                and hasattr(created_at, \"tzinfo\")\n                and created_at.tzinfo is None\n            ):\n                created_at = created_at.replace(tzinfo=UTC)\n            if (\n                last_activity\n                and hasattr(last_activity, \"tzinfo\")\n                and last_activity.tzinfo is None\n            ):\n                last_activity = last_activity.replace(tzinfo=UTC)\n\n            session_dict = {\n                \"user_id\": session_record.get(\"user_id\"),\n                \"session_id\": session_record.get(\"session_id\"),\n                \"ip_address\": session_record.get(\"ip_address\", \"\"),\n                \"user_agent\": session_record.get(\"user_agent\", \"\"),\n                \"device_info\": session_record.get(\"device_info\", {}),\n                \"created_at\": created_at,\n                \"last_activity\": last_activity,\n                \"is_active\": session_record.get(\"is_active\", True),\n                \"metadata\": session_record.get(\"session_metadata\", {}),\n            }\n        else:\n            return None\n\n        return model_class.model_validate(session_dict)\n\n    except Exception as e:\n        logger.error(f\"Error getting session from database: {e}\")\n        return None\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.get_user_sessions","title":"<code>get_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Get all active session IDs for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of session IDs for the user</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n    \"\"\"Get all active session IDs for a user.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        List of session IDs for the user\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        sessions = await self.db_config.crud_sessions.get_multi(\n            db=db, user_id=user_id, is_active=True\n        )\n\n        session_data: list[Any] = []\n        if isinstance(sessions, dict) and \"data\" in sessions:\n            session_data = sessions[\"data\"]  # type: ignore[assignment]\n        elif isinstance(sessions, list):\n            session_data = sessions  # type: ignore[assignment]\n        elif isinstance(sessions, int):\n            return []\n        elif hasattr(sessions, \"__iter__\") and not isinstance(\n            sessions, (str, bytes)\n        ):\n            try:\n                session_data = list(sessions)\n            except (TypeError, ValueError):\n                logger.warning(\n                    f\"Could not convert sessions to list: {type(sessions)}\"\n                )\n                return []\n        else:\n            logger.warning(f\"Unexpected sessions format: {type(sessions)}\")\n            return []\n\n        session_ids = []\n        for session in session_data:\n            if hasattr(session, \"session_id\"):\n                session_ids.append(session.session_id)\n            elif isinstance(session, dict) and \"session_id\" in session:\n                session_ids.append(session[\"session_id\"])\n\n        return session_ids\n\n    except Exception as e:\n        logger.error(f\"Error getting user sessions from database: {e}\")\n        return []\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.database.DatabaseSessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>async</code>","text":"<p>Update session data in the database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration (updates last_activity)</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds (ignored for database)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/database.py</code> <pre><code>async def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data in the database.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration (updates last_activity)\n        expiration: Optional custom expiration in seconds (ignored for database)\n\n    Returns:\n        True if the session was updated, False if it didn't exist\n    \"\"\"\n    db = await self._get_db()\n\n    try:\n        existing = await self.db_config.crud_sessions.get(\n            db=db, session_id=session_id\n        )\n        if not existing:\n            return False\n\n        if hasattr(data, \"model_dump\"):\n            data_dict = data.model_dump()\n        else:\n            data_dict = data.__dict__\n\n        update_data = AdminSessionUpdate(\n            last_activity=data_dict.get(\"last_activity\", datetime.now(UTC))\n            if reset_expiration\n            else None,\n            is_active=data_dict.get(\"is_active\"),\n            session_metadata=data_dict.get(\"metadata\"),\n        )\n\n        update_dict = {\n            k: v for k, v in update_data.model_dump().items() if v is not None\n        }\n\n        if update_dict:\n            await self.db_config.crud_sessions.update(\n                db=db, object=update_dict, session_id=session_id\n            )\n            await db.commit()\n\n        return True\n\n    except Exception as e:\n        await db.rollback()\n        logger.error(f\"Error updating session in database: {e}\")\n        return False\n</code></pre>"},{"location":"api/session/#hybrid-storage","title":"Hybrid Storage","text":"<p>               Bases: <code>AbstractSessionStorage[T]</code></p> <p>Hybrid storage: Redis for active sessions + Database for audit trail.</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>class HybridSessionStorage(AbstractSessionStorage[T]):\n    \"\"\"Hybrid storage: Redis for active sessions + Database for audit trail.\"\"\"\n\n    def __init__(\n        self,\n        redis_storage: AbstractSessionStorage[T],\n        database_storage: AbstractSessionStorage[T],\n        prefix: str = \"session:\",\n        expiration: int = 1800,\n    ):\n        \"\"\"Initialize the Hybrid session storage.\n\n        Args:\n            redis_storage: Redis storage instance for active sessions\n            database_storage: Database storage instance for audit trail\n            prefix: Prefix for all session keys (inherited from redis_storage)\n            expiration: Default session expiration in seconds\n        \"\"\"\n        super().__init__(prefix=prefix, expiration=expiration)\n        self.redis_storage = redis_storage\n        self.database_storage = database_storage\n\n    async def create(\n        self,\n        data: T,\n        session_id: Optional[str] = None,\n        expiration: Optional[int] = None,\n    ) -&gt; str:\n        \"\"\"Create a new session in both Redis and Database.\n\n        Args:\n            data: Session data (must be a Pydantic model)\n            session_id: Optional session ID. If not provided, one will be generated\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            The session ID\n        \"\"\"\n        session_id = await self.redis_storage.create(data, session_id, expiration)\n\n        try:\n            await self.database_storage.create(data, session_id, None)\n            logger.debug(f\"Session {session_id} stored in both Redis and Database\")\n        except Exception as e:\n            logger.warning(f\"Failed to store session audit trail in database: {e}\")\n\n        return session_id\n\n    async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n        \"\"\"Get session data from Redis (active sessions only).\n\n        Args:\n            session_id: The session ID\n            model_class: The Pydantic model class to decode the data into\n\n        Returns:\n            The session data or None if session doesn't exist or expired\n        \"\"\"\n        return await self.redis_storage.get(session_id, model_class)\n\n    async def update(\n        self,\n        session_id: str,\n        data: T,\n        reset_expiration: bool = True,\n        expiration: Optional[int] = None,\n    ) -&gt; bool:\n        \"\"\"Update session data in both Redis and Database.\n\n        Args:\n            session_id: The session ID\n            data: New session data\n            reset_expiration: Whether to reset the expiration\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was updated in Redis, False if it didn't exist\n        \"\"\"\n        result = await self.redis_storage.update(\n            session_id, data, reset_expiration, expiration\n        )\n\n        try:\n            await self.database_storage.update(session_id, data, reset_expiration, None)\n            logger.debug(f\"Session {session_id} updated in both Redis and Database\")\n        except Exception as e:\n            logger.warning(f\"Failed to update session audit trail in database: {e}\")\n\n        return result\n\n    async def delete(self, session_id: str) -&gt; bool:\n        \"\"\"Delete session from Redis and mark as inactive in Database.\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session was deleted from Redis, False if it didn't exist\n        \"\"\"\n        result = await self.redis_storage.delete(session_id)\n\n        try:\n            session_data = None\n\n            if hasattr(self.database_storage, \"get_raw\"):\n                session_data = await self.database_storage.get_raw(session_id)\n            else:\n                try:\n                    session_data = await self.database_storage.get(\n                        session_id, cast(\"type[T]\", BaseModel)\n                    )\n                except TypeError:\n                    await self.database_storage.delete(session_id)\n                    logger.debug(\n                        f\"Session {session_id} deleted from Redis and hard-deleted from Database\"\n                    )\n                    return result\n\n            if session_data:\n                if hasattr(session_data, \"is_active\"):\n                    session_data.is_active = False\n                elif isinstance(session_data, dict):\n                    session_data[\"is_active\"] = False\n\n                await self.database_storage.update(\n                    session_id, session_data, False, None\n                )\n                logger.debug(\n                    f\"Session {session_id} deleted from Redis and marked inactive in Database\"\n                )\n            else:\n                await self.database_storage.delete(session_id)\n                logger.debug(\n                    f\"Session {session_id} deleted from both Redis and Database\"\n                )\n        except Exception as e:\n            logger.warning(f\"Failed to update session audit trail on delete: {e}\")\n\n        return result\n\n    async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n        \"\"\"Extend the expiration of a session in Redis.\n\n        Args:\n            session_id: The session ID\n            expiration: Optional custom expiration in seconds\n\n        Returns:\n            True if the session was extended in Redis, False if it didn't exist\n        \"\"\"\n        result = await self.redis_storage.extend(session_id, expiration)\n\n        try:\n            await self.database_storage.extend(session_id, None)\n            logger.debug(\n                f\"Session {session_id} extended in Redis and last_activity updated in Database\"\n            )\n        except Exception as e:\n            logger.warning(f\"Failed to update last_activity in database: {e}\")\n\n        return result\n\n    async def exists(self, session_id: str) -&gt; bool:\n        \"\"\"Check if a session exists in Redis (active sessions only).\n\n        Args:\n            session_id: The session ID\n\n        Returns:\n            True if the session exists in Redis, False otherwise\n        \"\"\"\n        return await self.redis_storage.exists(session_id)\n\n    async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n        \"\"\"Get all active session IDs for a user from Redis.\n\n        Args:\n            user_id: The user ID\n\n        Returns:\n            List of active session IDs for the user\n        \"\"\"\n        try:\n            if hasattr(self.redis_storage, \"get_user_sessions\"):\n                result = await self.redis_storage.get_user_sessions(user_id)\n                return result if isinstance(result, list) else []\n            else:\n                return []\n        except Exception as e:\n            logger.warning(f\"Failed to get user sessions from Redis: {e}\")\n            try:\n                if hasattr(self.database_storage, \"get_user_sessions\"):\n                    result = await self.database_storage.get_user_sessions(user_id)\n                    return result if isinstance(result, list) else []\n                else:\n                    return []\n            except Exception as db_e:\n                logger.error(\n                    f\"Failed to get user sessions from Database fallback: {db_e}\"\n                )\n                return []\n\n    async def close(self) -&gt; None:\n        \"\"\"Close both storage connections.\"\"\"\n        await self.redis_storage.close()\n        await self.database_storage.close()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.__init__","title":"<code>__init__(redis_storage, database_storage, prefix='session:', expiration=1800)</code>","text":"<p>Initialize the Hybrid session storage.</p> <p>Parameters:</p> Name Type Description Default <code>redis_storage</code> <code>AbstractSessionStorage[T]</code> <p>Redis storage instance for active sessions</p> required <code>database_storage</code> <code>AbstractSessionStorage[T]</code> <p>Database storage instance for audit trail</p> required <code>prefix</code> <code>str</code> <p>Prefix for all session keys (inherited from redis_storage)</p> <code>'session:'</code> <code>expiration</code> <code>int</code> <p>Default session expiration in seconds</p> <code>1800</code> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>def __init__(\n    self,\n    redis_storage: AbstractSessionStorage[T],\n    database_storage: AbstractSessionStorage[T],\n    prefix: str = \"session:\",\n    expiration: int = 1800,\n):\n    \"\"\"Initialize the Hybrid session storage.\n\n    Args:\n        redis_storage: Redis storage instance for active sessions\n        database_storage: Database storage instance for audit trail\n        prefix: Prefix for all session keys (inherited from redis_storage)\n        expiration: Default session expiration in seconds\n    \"\"\"\n    super().__init__(prefix=prefix, expiration=expiration)\n    self.redis_storage = redis_storage\n    self.database_storage = database_storage\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close both storage connections.</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close both storage connections.\"\"\"\n    await self.redis_storage.close()\n    await self.database_storage.close()\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.create","title":"<code>create(data, session_id=None, expiration=None)</code>  <code>async</code>","text":"<p>Create a new session in both Redis and Database.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>Session data (must be a Pydantic model)</p> required <code>session_id</code> <code>Optional[str]</code> <p>Optional session ID. If not provided, one will be generated</p> <code>None</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The session ID</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def create(\n    self,\n    data: T,\n    session_id: Optional[str] = None,\n    expiration: Optional[int] = None,\n) -&gt; str:\n    \"\"\"Create a new session in both Redis and Database.\n\n    Args:\n        data: Session data (must be a Pydantic model)\n        session_id: Optional session ID. If not provided, one will be generated\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        The session ID\n    \"\"\"\n    session_id = await self.redis_storage.create(data, session_id, expiration)\n\n    try:\n        await self.database_storage.create(data, session_id, None)\n        logger.debug(f\"Session {session_id} stored in both Redis and Database\")\n    except Exception as e:\n        logger.warning(f\"Failed to store session audit trail in database: {e}\")\n\n    return session_id\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.delete","title":"<code>delete(session_id)</code>  <code>async</code>","text":"<p>Delete session from Redis and mark as inactive in Database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was deleted from Redis, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def delete(self, session_id: str) -&gt; bool:\n    \"\"\"Delete session from Redis and mark as inactive in Database.\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session was deleted from Redis, False if it didn't exist\n    \"\"\"\n    result = await self.redis_storage.delete(session_id)\n\n    try:\n        session_data = None\n\n        if hasattr(self.database_storage, \"get_raw\"):\n            session_data = await self.database_storage.get_raw(session_id)\n        else:\n            try:\n                session_data = await self.database_storage.get(\n                    session_id, cast(\"type[T]\", BaseModel)\n                )\n            except TypeError:\n                await self.database_storage.delete(session_id)\n                logger.debug(\n                    f\"Session {session_id} deleted from Redis and hard-deleted from Database\"\n                )\n                return result\n\n        if session_data:\n            if hasattr(session_data, \"is_active\"):\n                session_data.is_active = False\n            elif isinstance(session_data, dict):\n                session_data[\"is_active\"] = False\n\n            await self.database_storage.update(\n                session_id, session_data, False, None\n            )\n            logger.debug(\n                f\"Session {session_id} deleted from Redis and marked inactive in Database\"\n            )\n        else:\n            await self.database_storage.delete(session_id)\n            logger.debug(\n                f\"Session {session_id} deleted from both Redis and Database\"\n            )\n    except Exception as e:\n        logger.warning(f\"Failed to update session audit trail on delete: {e}\")\n\n    return result\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.exists","title":"<code>exists(session_id)</code>  <code>async</code>","text":"<p>Check if a session exists in Redis (active sessions only).</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the session exists in Redis, False otherwise</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def exists(self, session_id: str) -&gt; bool:\n    \"\"\"Check if a session exists in Redis (active sessions only).\n\n    Args:\n        session_id: The session ID\n\n    Returns:\n        True if the session exists in Redis, False otherwise\n    \"\"\"\n    return await self.redis_storage.exists(session_id)\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.extend","title":"<code>extend(session_id, expiration=None)</code>  <code>async</code>","text":"<p>Extend the expiration of a session in Redis.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was extended in Redis, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def extend(self, session_id: str, expiration: Optional[int] = None) -&gt; bool:\n    \"\"\"Extend the expiration of a session in Redis.\n\n    Args:\n        session_id: The session ID\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was extended in Redis, False if it didn't exist\n    \"\"\"\n    result = await self.redis_storage.extend(session_id, expiration)\n\n    try:\n        await self.database_storage.extend(session_id, None)\n        logger.debug(\n            f\"Session {session_id} extended in Redis and last_activity updated in Database\"\n        )\n    except Exception as e:\n        logger.warning(f\"Failed to update last_activity in database: {e}\")\n\n    return result\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.get","title":"<code>get(session_id, model_class)</code>  <code>async</code>","text":"<p>Get session data from Redis (active sessions only).</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>model_class</code> <code>type[T]</code> <p>The Pydantic model class to decode the data into</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The session data or None if session doesn't exist or expired</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def get(self, session_id: str, model_class: type[T]) -&gt; Optional[T]:\n    \"\"\"Get session data from Redis (active sessions only).\n\n    Args:\n        session_id: The session ID\n        model_class: The Pydantic model class to decode the data into\n\n    Returns:\n        The session data or None if session doesn't exist or expired\n    \"\"\"\n    return await self.redis_storage.get(session_id, model_class)\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.get_user_sessions","title":"<code>get_user_sessions(user_id)</code>  <code>async</code>","text":"<p>Get all active session IDs for a user from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of active session IDs for the user</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def get_user_sessions(self, user_id: int) -&gt; list[str]:\n    \"\"\"Get all active session IDs for a user from Redis.\n\n    Args:\n        user_id: The user ID\n\n    Returns:\n        List of active session IDs for the user\n    \"\"\"\n    try:\n        if hasattr(self.redis_storage, \"get_user_sessions\"):\n            result = await self.redis_storage.get_user_sessions(user_id)\n            return result if isinstance(result, list) else []\n        else:\n            return []\n    except Exception as e:\n        logger.warning(f\"Failed to get user sessions from Redis: {e}\")\n        try:\n            if hasattr(self.database_storage, \"get_user_sessions\"):\n                result = await self.database_storage.get_user_sessions(user_id)\n                return result if isinstance(result, list) else []\n            else:\n                return []\n        except Exception as db_e:\n            logger.error(\n                f\"Failed to get user sessions from Database fallback: {db_e}\"\n            )\n            return []\n</code></pre>"},{"location":"api/session/#crudadmin.session.backends.hybrid.HybridSessionStorage.update","title":"<code>update(session_id, data, reset_expiration=True, expiration=None)</code>  <code>async</code>","text":"<p>Update session data in both Redis and Database.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>The session ID</p> required <code>data</code> <code>T</code> <p>New session data</p> required <code>reset_expiration</code> <code>bool</code> <p>Whether to reset the expiration</p> <code>True</code> <code>expiration</code> <code>Optional[int]</code> <p>Optional custom expiration in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the session was updated in Redis, False if it didn't exist</p> Source code in <code>crudadmin/session/backends/hybrid.py</code> <pre><code>async def update(\n    self,\n    session_id: str,\n    data: T,\n    reset_expiration: bool = True,\n    expiration: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Update session data in both Redis and Database.\n\n    Args:\n        session_id: The session ID\n        data: New session data\n        reset_expiration: Whether to reset the expiration\n        expiration: Optional custom expiration in seconds\n\n    Returns:\n        True if the session was updated in Redis, False if it didn't exist\n    \"\"\"\n    result = await self.redis_storage.update(\n        session_id, data, reset_expiration, expiration\n    )\n\n    try:\n        await self.database_storage.update(session_id, data, reset_expiration, None)\n        logger.debug(f\"Session {session_id} updated in both Redis and Database\")\n    except Exception as e:\n        logger.warning(f\"Failed to update session audit trail in database: {e}\")\n\n    return result\n</code></pre>"},{"location":"api/session/#session-schemas","title":"Session Schemas","text":""},{"location":"api/session/#core-session-data","title":"Core Session Data","text":"<p>               Bases: <code>BaseModel</code></p> <p>Common base data for any user session.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class SessionData(BaseModel):\n    \"\"\"Common base data for any user session.\"\"\"\n\n    user_id: int\n    session_id: str = Field(default_factory=lambda: str(uuid4()))\n    ip_address: str\n    user_agent: str\n    device_info: dict[str, Any] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))\n    last_activity: datetime = Field(default_factory=lambda: datetime.now(UTC))\n    is_active: bool = True\n    metadata: dict[str, Any] = Field(default_factory=dict)\n</code></pre> <p>               Bases: <code>SessionData</code></p> <p>Schema for creating a new session.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class SessionCreate(SessionData):\n    \"\"\"Schema for creating a new session.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/session/#csrf-protection","title":"CSRF Protection","text":"<p>               Bases: <code>BaseModel</code></p> <p>CSRF token data.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class CSRFToken(BaseModel):\n    \"\"\"CSRF token data.\"\"\"\n\n    token: str\n    user_id: int\n    session_id: str\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))\n    expires_at: datetime\n</code></pre>"},{"location":"api/session/#user-agent-information","title":"User Agent Information","text":"<p>               Bases: <code>BaseModel</code></p> <p>User agent information parsed from the User-Agent header.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class UserAgentInfo(BaseModel):\n    \"\"\"User agent information parsed from the User-Agent header.\"\"\"\n\n    browser: str\n    browser_version: str\n    os: str\n    device: str\n    is_mobile: bool\n    is_tablet: bool\n    is_pc: bool\n</code></pre>"},{"location":"api/session/#database-session-models","title":"Database Session Models","text":"<p>               Bases: <code>AdminSessionBase</code></p> <p>Schema for creating AdminSession in database.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class AdminSessionCreate(AdminSessionBase):\n    \"\"\"Schema for creating AdminSession in database.\"\"\"\n\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))\n    last_activity: datetime = Field(default_factory=lambda: datetime.now(UTC))\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Schema for reading AdminSession data.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class AdminSessionRead(BaseModel):\n    \"\"\"Schema for reading AdminSession data.\"\"\"\n\n    id: int\n    user_id: int\n    session_id: str\n    ip_address: str\n    user_agent: str\n    device_info: dict[str, Any]\n    session_metadata: dict[str, Any]\n    created_at: datetime\n    last_activity: datetime\n    is_active: bool\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Schema for updating AdminSession.</p> Source code in <code>crudadmin/session/schemas.py</code> <pre><code>class AdminSessionUpdate(BaseModel):\n    \"\"\"Schema for updating AdminSession.\"\"\"\n\n    last_activity: Optional[datetime] = None\n    is_active: Optional[bool] = None\n    session_metadata: Optional[dict[str, Any]] = None\n</code></pre>"},{"location":"api/session/#usage-examples","title":"Usage Examples","text":""},{"location":"api/session/#basic-session-management","title":"Basic Session Management","text":"<pre><code>from crudadmin.session.manager import SessionManager\nfrom crudadmin.session.storage import get_session_storage\n\n# Create session manager with memory backend\nsession_manager = SessionManager(\n    session_backend=\"memory\",\n    max_sessions_per_user=5,\n    session_timeout_minutes=30\n)\n\n# Create a new session\nsession_id, csrf_token = await session_manager.create_session(\n    request=request,\n    user_id=user.id,\n    metadata={\"role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\n)\n\n# Validate session\nsession_data = await session_manager.validate_session(session_id)\nif session_data:\n    print(f\"Valid session for user {session_data.user_id}\")\n</code></pre>"},{"location":"api/session/#redis-backend-configuration","title":"Redis Backend Configuration","text":"<pre><code># Configure with Redis for production\nsession_manager = SessionManager(\n    session_backend=\"redis\",\n    redis_host=\"localhost\",\n    redis_port=6379,\n    redis_db=0,\n    redis_password=\"your-redis-password\",\n    max_sessions_per_user=10,\n    session_timeout_minutes=60\n)\n</code></pre>"},{"location":"api/session/#database-backend-for-audit-trail","title":"Database Backend for Audit Trail","text":"<pre><code>from your_app.database import DatabaseConfig\n\n# Configure with database backend for admin visibility\ndb_config = DatabaseConfig(...)  # Your database configuration\n\nsession_manager = SessionManager(\n    session_backend=\"database\",\n    db_config=db_config,\n    max_sessions_per_user=5,\n    session_timeout_minutes=30\n)\n</code></pre>"},{"location":"api/session/#hybrid-backend-best-of-both-worlds","title":"Hybrid Backend (Best of Both Worlds)","text":"<pre><code># Hybrid: Redis for performance + Database for audit\nsession_manager = SessionManager(\n    session_backend=\"hybrid\",\n    db_config=db_config,\n    redis_host=\"localhost\",\n    redis_port=6379,\n    max_sessions_per_user=10,\n    session_timeout_minutes=60\n)\n</code></pre>"},{"location":"api/session/#csrf-protection_1","title":"CSRF Protection","text":"<pre><code># Validate CSRF token for state-changing operations\nis_valid = await session_manager.validate_csrf_token(\n    csrf_token=request.headers.get(\"X-CSRF-Token\"),\n    session_id=session_id,\n    user_id=current_user.id\n)\n\nif not is_valid:\n    raise HTTPException(status_code=403, detail=\"Invalid CSRF token\")\n</code></pre>"},{"location":"api/session/#session-cleanup","title":"Session Cleanup","text":"<pre><code># Cleanup expired sessions (should be called periodically)\nawait session_manager.cleanup_expired_sessions()\n\n# Terminate specific session\nawait session_manager.terminate_session(session_id)\n\n# Terminate all user sessions\nawait session_manager.terminate_user_sessions(user_id)\n</code></pre>"},{"location":"api/session/#backend-comparison","title":"Backend Comparison","text":"Backend Performance Scalability Persistence Admin Visibility Use Case Memory Excellent Single node No No Development, testing Redis Excellent Horizontal Yes* No Production, high traffic Memcached Excellent Horizontal No No High performance caching Database Good Vertical Yes Yes Audit requirements Hybrid Excellent Horizontal Yes Yes Best of all worlds <p>*Redis persistence depends on configuration</p>"},{"location":"api/session/#security-features","title":"Security Features","text":""},{"location":"api/session/#session-security","title":"Session Security","text":"<pre><code># Session manager provides multiple security layers\nsession_manager = SessionManager(\n    # Limit concurrent sessions per user\n    max_sessions_per_user=5,\n\n    # Automatic session expiration\n    session_timeout_minutes=30,\n\n    # CSRF protection\n    csrf_token_bytes=32,\n\n    # Login rate limiting\n    login_max_attempts=5,\n    login_window_minutes=15\n)\n</code></pre>"},{"location":"api/session/#device-tracking","title":"Device Tracking","text":"<p>Sessions automatically track device information:</p> <pre><code># Device info is automatically parsed and stored\nsession_data = await session_manager.validate_session(session_id)\ndevice_info = session_data.device_info\n\nprint(f\"Browser: {device_info['browser']}\")\nprint(f\"OS: {device_info['os']}\")\nprint(f\"Mobile: {device_info['is_mobile']}\")\n</code></pre>"},{"location":"api/session/#ip-address-monitoring","title":"IP Address Monitoring","text":"<pre><code># Sessions track IP addresses for security monitoring\nsession_data = await session_manager.validate_session(session_id)\nprint(f\"Session from IP: {session_data.ip_address}\")\n\n# Detect IP changes (potential session hijacking)\nif session_data.ip_address != request.client.host:\n    # Handle potential security issue\n    await session_manager.terminate_session(session_id)\n</code></pre>"},{"location":"api/session/#configuration-options","title":"Configuration Options","text":""},{"location":"api/session/#session-manager-settings","title":"Session Manager Settings","text":"<pre><code>session_manager = SessionManager(\n    # Storage configuration\n    session_backend=\"redis\",\n    redis_host=\"localhost\",\n    redis_port=6379,\n    redis_db=0,\n    redis_password=None,\n\n    # Session limits\n    max_sessions_per_user=5,\n    session_timeout_minutes=30,\n\n    # Cleanup\n    cleanup_interval_minutes=15,\n\n    # CSRF\n    csrf_token_bytes=32,\n\n    # Rate limiting\n    login_max_attempts=5,\n    login_window_minutes=15\n)\n</code></pre>"},{"location":"api/session/#backend-specific-options","title":"Backend-Specific Options","text":""},{"location":"api/session/#redis-configuration","title":"Redis Configuration","text":"<pre><code>redis_storage = get_session_storage(\n    backend=\"redis\",\n    model_type=SessionData,\n    host=\"localhost\",\n    port=6379,\n    db=0,\n    password=\"your-password\",\n    pool_size=10,\n    connect_timeout=10,\n    prefix=\"session:\",\n    expiration=1800  # 30 minutes\n)\n</code></pre>"},{"location":"api/session/#database-configuration","title":"Database Configuration","text":"<pre><code>database_storage = get_session_storage(\n    backend=\"database\",\n    model_type=SessionData,\n    db_config=your_db_config,\n    prefix=\"session:\",\n    expiration=1800\n)\n</code></pre>"},{"location":"api/session/#integration-with-crudadmin","title":"Integration with CRUDAdmin","text":""},{"location":"api/session/#automatic-session-management","title":"Automatic Session Management","text":"<pre><code>from crudadmin import CRUDAdmin\n\n# CRUDAdmin automatically creates and manages sessions\ncrud_admin = CRUDAdmin(\n    # Session backend configuration\n    session_backend=\"redis\",\n    redis_url=\"redis://localhost:6379\",\n\n    # Session settings\n    session_timeout=30,  # minutes\n    max_sessions_per_user=5,\n\n    # Security\n    secret_key=\"your-secret-key\",\n    csrf_protection=True\n)\n</code></pre>"},{"location":"api/session/#custom-session-storage","title":"Custom Session Storage","text":"<pre><code># Use custom session storage\ncustom_storage = YourCustomSessionStorage()\n\ncrud_admin = CRUDAdmin(\n    session_storage=custom_storage,\n    secret_key=\"your-secret-key\"\n)\n</code></pre>"},{"location":"api/session/#session-data-structure","title":"Session Data Structure","text":""},{"location":"api/session/#sessiondata-fields","title":"SessionData Fields","text":"Field Type Description <code>user_id</code> int ID of the authenticated user <code>session_id</code> str Unique session identifier <code>ip_address</code> str IP address when session was created <code>user_agent</code> str User agent string from browser <code>device_info</code> dict Parsed device/browser information <code>created_at</code> datetime When the session was created <code>last_activity</code> datetime Last time session was validated <code>is_active</code> bool Whether the session is active <code>metadata</code> dict Additional session-specific data"},{"location":"api/session/#device-information","title":"Device Information","text":"<pre><code>device_info = {\n    \"browser\": \"Chrome\",\n    \"browser_version\": \"120.0.0.0\",\n    \"os\": \"Windows\",\n    \"device\": \"PC\",\n    \"is_mobile\": False,\n    \"is_tablet\": False,\n    \"is_pc\": True\n}\n</code></pre>"},{"location":"api/session/#error-handling","title":"Error Handling","text":""},{"location":"api/session/#session-validation-errors","title":"Session Validation Errors","text":"<pre><code>try:\n    session_data = await session_manager.validate_session(session_id)\n    if not session_data:\n        # Session not found, expired, or inactive\n        raise HTTPException(status_code=401, detail=\"Invalid session\")\nexcept Exception as e:\n    logger.error(f\"Session validation error: {e}\")\n    raise HTTPException(status_code=500, detail=\"Session validation failed\")\n</code></pre>"},{"location":"api/session/#backend-connection-errors","title":"Backend Connection Errors","text":"<pre><code>try:\n    await session_manager.create_session(request, user_id)\nexcept ConnectionError:\n    # Backend (Redis/Memcached) unavailable\n    # Fallback to memory storage or return error\n    pass\nexcept Exception as e:\n    logger.error(f\"Session creation failed: {e}\")\n    raise\n</code></pre>"},{"location":"api/session/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/session/#session-cleanup_1","title":"Session Cleanup","text":"<pre><code>import asyncio\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\n# Schedule periodic cleanup\nscheduler = AsyncIOScheduler()\nscheduler.add_job(\n    session_manager.cleanup_expired_sessions,\n    'interval',\n    minutes=15,\n    id='session_cleanup'\n)\nscheduler.start()\n</code></pre>"},{"location":"api/session/#connection-pooling","title":"Connection Pooling","text":"<pre><code># Redis with connection pooling\nredis_storage = get_session_storage(\n    backend=\"redis\",\n    model_type=SessionData,\n    host=\"localhost\",\n    port=6379,\n    pool_size=20,  # Increase pool size for high traffic\n    connect_timeout=10\n)\n</code></pre>"},{"location":"api/session/#session-limits","title":"Session Limits","text":"<pre><code># Prevent memory exhaustion\nsession_manager = SessionManager(\n    max_sessions_per_user=10,  # Limit per user\n    session_timeout_minutes=30,  # Auto-expire\n    cleanup_interval_minutes=15  # Regular cleanup\n)\n</code></pre>"},{"location":"api/session/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"api/session/#session-metrics","title":"Session Metrics","text":"<pre><code># Get active session count for user\nuser_sessions = await session_manager.get_user_sessions(user_id)\nprint(f\"User has {len(user_sessions)} active sessions\")\n\n# Monitor session activity\nsession_data = await session_manager.validate_session(session_id)\nif session_data:\n    session_age = datetime.now(UTC) - session_data.last_activity\n    print(f\"Session last active {session_age} ago\")\n</code></pre>"},{"location":"api/session/#debug-information","title":"Debug Information","text":"<pre><code># Enable detailed logging\nimport logging\nlogging.getLogger('crudadmin.session').setLevel(logging.DEBUG)\n\n# Session data includes debug information\nprint(f\"Session metadata: {session_data.metadata}\")\nprint(f\"Device info: {session_data.device_info}\")\n</code></pre> <p>The session management system provides a robust, secure foundation for authentication in CRUDAdmin with flexibility to scale from development to production environments. </p>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to CRUDAdmin","text":"<p>Thank you for your interest in contributing to CRUDAdmin! This guide is meant to make it easy for you to get started.</p>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"community/CONTRIBUTING/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Start by forking and cloning the CRUDAdmin repository:</p> <pre><code>git clone https://github.com/igorbenav/crudadmin.git\n</code></pre>"},{"location":"community/CONTRIBUTING/#using-uv-for-dependency-management","title":"Using UV for Dependency Management","text":"<p>CRUDAdmin uses UV for managing dependencies. If you don't have UV installed, follow the instructions on the official UV website.</p> <p>Once UV is installed, navigate to the cloned repository.</p>"},{"location":"community/CONTRIBUTING/#activating-the-virtual-environment","title":"Activating the Virtual Environment","text":"<p>UV can a virtual environment for your project. Activate it using:</p> <pre><code>uv venv\n</code></pre> <p>Then</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"community/CONTRIBUTING/#making-contributions","title":"Making Contributions","text":""},{"location":"community/CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Write meaningful tests for new features or bug fixes.</li> </ul>"},{"location":"community/CONTRIBUTING/#testing-with-pytest","title":"Testing with Pytest","text":"<p>CRUDAdmin uses pytest for testing. Run tests using: <pre><code>uv run pytest\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#linting","title":"Linting","text":"<p>Use mypy for type checking: <pre><code>uv run mypy crudadmin\n</code></pre></p> <p>Use ruff for style: <pre><code>uv run ruff check --fix\nuv run ruff format\n</code></pre></p> <p>Ensure your code passes linting before submitting.</p>"},{"location":"community/CONTRIBUTING/#submitting-your-contributions","title":"Submitting Your Contributions","text":""},{"location":"community/CONTRIBUTING/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>After making your changes:</p> <ul> <li>Push your changes to your fork.</li> <li>Open a pull request with a clear description of your changes.</li> <li>Update the README.md if necessary.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-reviews","title":"Code Reviews","text":"<ul> <li>Address any feedback from code reviews.</li> <li>Once approved, your contributions will be merged into the main branch.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to our Code of Conduct to maintain a welcoming and inclusive environment.</p> <p>Thank you for contributing to CRUDAdmin\ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Igor Benav</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the project's community hub. Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, and the process for submitting pull requests.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"usage/adding-models/","title":"Adding Models to Your Admin Interface","text":"<p>This guide explains how to register your SQLAlchemy models with CRUDAdmin to create a fully functional admin interface. You'll learn how to configure models, set up schemas, control actions, and handle special field types.</p>"},{"location":"usage/adding-models/#prerequisites","title":"Prerequisites","text":"<p>Before adding models to your admin interface, ensure you have:</p> <ul> <li>SQLAlchemy models defined with proper table structure</li> <li>Corresponding Pydantic schemas for data validation</li> <li>CRUDAdmin instance created and configured (see Quick Start)</li> </ul>"},{"location":"usage/adding-models/#basic-model-registration","title":"Basic Model Registration","text":""},{"location":"usage/adding-models/#step-1-define-your-sqlalchemy-model","title":"Step 1: Define Your SQLAlchemy Model","text":"<p>First, create your SQLAlchemy model with proper field definitions:</p> User Model Example <pre><code>from sqlalchemy import Column, Integer, String, Boolean, DateTime, func\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String(50), unique=True, nullable=False)\n    email = Column(String(100), unique=True, nullable=False)\n    role = Column(String(20), default=\"user\")\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=func.now())\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())\n</code></pre>"},{"location":"usage/adding-models/#step-2-create-pydantic-schemas","title":"Step 2: Create Pydantic Schemas","text":"<p>Define schemas for create and update operations:</p> User Schema Examples <pre><code>from pydantic import BaseModel, EmailStr, Field\nfrom typing import Optional\nfrom datetime import datetime\n\nclass UserCreate(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    role: str = Field(default=\"user\", pattern=\"^(admin|user|moderator)$\")\n    is_active: bool = True\n\n    class Config:\n        json_schema_extra = {\n            \"example\": {\n                \"username\": \"johndoe\",\n                \"email\": \"john@example.com\",\n                \"role\": \"user\",\n                \"is_active\": True\n            }\n        }\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    role: Optional[str] = Field(None, pattern=\"^(admin|user|moderator)$\")\n    is_active: Optional[bool] = None\n\n    class Config:\n        json_schema_extra = {\n            \"example\": {\n                \"email\": \"newemail@example.com\",\n                \"role\": \"moderator\",\n                \"is_active\": False\n            }\n        }\n</code></pre>"},{"location":"usage/adding-models/#step-3-register-with-crudadmin","title":"Step 3: Register with CRUDAdmin","text":"<p>Use the <code>add_view()</code> method to register your model:</p> <pre><code># Basic model registration\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#action-control","title":"Action Control","text":""},{"location":"usage/adding-models/#configuring-allowed-actions","title":"Configuring Allowed Actions","text":"<p>Control which operations are available for each model:</p> <pre><code># Read-only model (view only)\nadmin.add_view(\n    model=AuditLog,\n    create_schema=AuditLogSchema,\n    update_schema=AuditLogSchema,\n    allowed_actions={\"view\"}  # Only viewing allowed\n)\n\n# No deletion allowed\nadmin.add_view(\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No delete\n)\n\n# Full access (default)\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#available-actions","title":"Available Actions","text":"Action Description Generated Routes <code>\"view\"</code> Read and list records <code>GET /admin/{model}/</code>, <code>GET /admin/{model}/{id}</code> <code>\"create\"</code> Create new records <code>GET /admin/{model}/create</code>, <code>POST /admin/{model}/create</code> <code>\"update\"</code> Edit existing records <code>GET /admin/{model}/update/{id}</code>, <code>POST /admin/{model}/update/{id}</code> <code>\"delete\"</code> Delete records <code>POST /admin/{model}/delete/{id}</code>"},{"location":"usage/adding-models/#advanced-schema-configuration","title":"Advanced Schema Configuration","text":""},{"location":"usage/adding-models/#using-different-schemas-for-different-operations","title":"Using Different Schemas for Different Operations","text":"<pre><code>class UserCreateAdmin(BaseModel):\n    \"\"\"Schema with more fields for admin creation\"\"\"\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    role: str = Field(..., pattern=\"^(admin|user|moderator)$\")\n    is_active: bool = True\n    notes: Optional[str] = Field(None, max_length=500)\n\nclass UserUpdateAdmin(BaseModel):\n    \"\"\"Schema with admin-specific update fields\"\"\"\n    email: Optional[EmailStr] = None\n    role: Optional[str] = Field(None, pattern=\"^(admin|user|moderator)$\")\n    is_active: Optional[bool] = None\n    notes: Optional[str] = Field(None, max_length=500)\n\nclass UserUpdateInternal(BaseModel):\n    \"\"\"Internal schema for system updates\"\"\"\n    last_login: Optional[datetime] = None\n    login_count: Optional[int] = None\n\nadmin.add_view(\n    model=User,\n    create_schema=UserCreateAdmin,\n    update_schema=UserUpdateAdmin,\n    update_internal_schema=UserUpdateInternal,  # For internal operations\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#custom-delete-schema","title":"Custom Delete Schema","text":"<p>Define specific fields required for deletion:</p> <pre><code>class ProductDelete(BaseModel):\n    \"\"\"Require reason for product deletion\"\"\"\n    reason: str = Field(..., min_length=10, max_length=200)\n    archive_inventory: bool = Field(default=True)\n\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    delete_schema=ProductDelete,  # Custom deletion form\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#password-field-handling","title":"Password Field Handling","text":""},{"location":"usage/adding-models/#setting-up-password-transformation","title":"Setting Up Password Transformation","text":"<p>For models with password fields, use <code>PasswordTransformer</code>:</p> <pre><code>from crudadmin.admin_interface.model_view import PasswordTransformer\nimport bcrypt\n\ndef hash_password(password: str) -&gt; str:\n    \"\"\"Hash password using bcrypt\"\"\"\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\nclass UserCreateWithPassword(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)  # This gets transformed\n    role: str = Field(default=\"user\")\n\nclass UserUpdateWithPassword(BaseModel):\n    email: Optional[EmailStr] = None\n    password: Optional[str] = Field(None, min_length=8)  # Optional password update\n    role: Optional[str] = None\n\n# Create password transformer\npassword_transformer = PasswordTransformer(\n    password_field=\"password\",           # Field in Pydantic schema\n    hashed_field=\"hashed_password\",      # Field in SQLAlchemy model\n    hash_function=hash_password,         # Your hashing function\n    required_fields=[\"username\", \"email\"] # Required fields for validation\n)\n\nadmin.add_view(\n    model=User,\n    create_schema=UserCreateWithPassword,\n    update_schema=UserUpdateWithPassword,\n    password_transformer=password_transformer,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#real-world-examples","title":"Real-World Examples","text":""},{"location":"usage/adding-models/#e-commerce-models","title":"E-commerce Models","text":"<pre><code># Product Management\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=2, max_length=100)\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    description: Optional[str] = Field(None, max_length=1000)\n    category_id: Optional[int] = None\n    sku: str = Field(..., regex=r'^[A-Z0-9-]+$')\n    in_stock: bool = True\n\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No deletion for products\n)\n\n# Order Management (Read-only for admins)\nadmin.add_view(\n    model=Order,\n    create_schema=OrderSchema,\n    update_schema=OrderSchema,\n    allowed_actions={\"view\"}  # Orders are read-only in admin\n)\n</code></pre>"},{"location":"usage/adding-models/#content-management","title":"Content Management","text":"<pre><code># Blog Post Management\nclass BlogPostCreate(BaseModel):\n    title: str = Field(..., min_length=5, max_length=200)\n    content: str = Field(..., min_length=50)\n    author_id: int\n    category: str = Field(..., pattern=\"^(tech|business|personal)$\")\n    published: bool = False\n    tags: List[str] = Field(default_factory=list, max_items=10)\n\nclass BlogPostUpdate(BaseModel):\n    title: Optional[str] = Field(None, min_length=5, max_length=200)\n    content: Optional[str] = Field(None, min_length=50)\n    category: Optional[str] = Field(None, pattern=\"^(tech|business|personal)$\")\n    published: Optional[bool] = None\n    tags: Optional[List[str]] = Field(None, max_items=10)\n\nadmin.add_view(\n    model=BlogPost,\n    create_schema=BlogPostCreate,\n    update_schema=BlogPostUpdate,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#user-management-with-roles","title":"User Management with Roles","text":"<pre><code>class UserManagementCreate(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n    role: str = Field(..., pattern=\"^(admin|moderator|user)$\")\n    department: Optional[str] = None\n    is_active: bool = True\n\n    @validator('password')\n    def validate_password(cls, v):\n        if not re.search(r'^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&amp;])[A-Za-z\\d@$!%*#?&amp;]', v):\n            raise ValueError('Password must contain letters, numbers, and special characters')\n        return v\n\nadmin.add_view(\n    model=User,\n    create_schema=UserManagementCreate,\n    update_schema=UserManagementUpdate,\n    password_transformer=password_transformer,\n    allowed_actions={\"view\", \"create\", \"update\"}  # No user deletion\n)\n</code></pre>"},{"location":"usage/adding-models/#advanced-configuration-options","title":"Advanced Configuration Options","text":""},{"location":"usage/adding-models/#excluding-models-from-navigation","title":"Excluding Models from Navigation","text":"<pre><code># Add model but don't show in main navigation\nadmin.add_view(\n    model=InternalLog,\n    create_schema=InternalLogSchema,\n    update_schema=InternalLogSchema,\n    include_in_models=False,  # Hidden from main navigation\n    allowed_actions={\"view\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#custom-field-validation","title":"Custom Field Validation","text":"<pre><code>class ProductCreateAdvanced(BaseModel):\n    name: str = Field(..., min_length=2, max_length=100)\n    price: Decimal = Field(..., gt=0, le=999999.99, decimal_places=2)\n    weight: Optional[float] = Field(None, gt=0, le=1000)\n    dimensions: Optional[str] = Field(None, regex=r'^\\d+x\\d+x\\d+$')\n\n    @validator('name')\n    def validate_name(cls, v):\n        if any(char in v for char in ['&lt;', '&gt;', '&amp;']):\n            raise ValueError('Product name cannot contain HTML characters')\n        return v.title()  # Auto-capitalize\n\n    @validator('price')\n    def validate_price(cls, v):\n        if v &gt; 10000:\n            raise ValueError('Price cannot exceed $10,000')\n        return v\n\nadmin.add_view(\n    model=Product,\n    create_schema=ProductCreateAdvanced,\n    update_schema=ProductUpdateAdvanced,\n    allowed_actions={\"view\", \"create\", \"update\", \"delete\"}\n)\n</code></pre>"},{"location":"usage/adding-models/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"usage/adding-models/#1-audit-fields","title":"1. Audit Fields","text":"<pre><code>class BaseSchema(BaseModel):\n    \"\"\"Base schema with common audit fields\"\"\"\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n\n    class Config:\n        # Don't include audit fields in forms (auto-generated)\n        fields = {'created_at': {'exclude': True}, 'updated_at': {'exclude': True}}\n</code></pre>"},{"location":"usage/adding-models/#2-enum-fields","title":"2. Enum Fields","text":"<pre><code>from enum import Enum\n\nclass UserRole(str, Enum):\n    ADMIN = \"admin\"\n    MODERATOR = \"moderator\"\n    USER = \"user\"\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    role: UserRole = UserRole.USER  # Enum becomes dropdown in admin\n</code></pre>"},{"location":"usage/adding-models/#3-file-upload-fields","title":"3. File Upload Fields","text":"<pre><code>class DocumentCreate(BaseModel):\n    title: str = Field(..., min_length=2, max_length=100)\n    file_path: str  # File handling would be custom\n    file_type: str = Field(..., pattern=\"^(pdf|doc|docx|txt)$\")\n    size_mb: float = Field(..., gt=0, le=50)\n</code></pre>"},{"location":"usage/adding-models/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/adding-models/#common-issues","title":"Common Issues","text":"<p>Schema Validation Errors: <pre><code># \u274c Incorrect - Field names don't match model\nclass UserCreate(BaseModel):\n    user_name: str  # Model has 'username'\n\n# \u2705 Correct - Field names match model\nclass UserCreate(BaseModel):\n    username: str\n</code></pre></p> <p>Missing Required Fields: <pre><code># \u274c Incorrect - Missing required model fields\nclass UserCreate(BaseModel):\n    username: str\n    # Missing 'email' which is required in model\n\n# \u2705 Correct - All required fields included\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n</code></pre></p> <p>Action Configuration: <pre><code># \u274c Incorrect - Typo in action name\nadmin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    allowed_actions={\"view\", \"create\", \"updates\"}  # Should be \"update\"\n)\n</code></pre></p>"},{"location":"usage/adding-models/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Check Model Field Names: Ensure Pydantic schema fields match SQLAlchemy model columns</li> <li>Validate Schema Examples: Use Pydantic's validation to test your schemas</li> <li>Test Action Permissions: Verify allowed_actions contain valid strings</li> <li>Check Password Transformer: Ensure field names match between schema and model</li> </ol>"},{"location":"usage/adding-models/#next-steps","title":"Next Steps","text":"<p>Once you've successfully added models to your admin interface:</p> <ul> <li>Configure Basic Settings to customize your admin interface</li> <li>Manage Admin Users to set up proper access control</li> <li>Learn the Interface to effectively use your new admin panel</li> </ul> <p>For more advanced features like custom field widgets and complex relationships, see the Advanced Section. </p>"},{"location":"usage/admin-users/","title":"Managing Admin Users","text":"<p>This guide covers how to create, manage, and configure admin user accounts for accessing your CRUDAdmin interface. You'll learn about user creation, editing user details, understanding permissions, and following security best practices.</p>"},{"location":"usage/admin-users/#prerequisites","title":"Prerequisites","text":"<p>Before managing admin users, ensure you have:</p> <ul> <li>A configured CRUDAdmin instance (see Basic Configuration)</li> <li>Access to your admin interface (typically at <code>/admin</code>)</li> <li>Understanding of password security requirements</li> </ul>"},{"location":"usage/admin-users/#creating-admin-users","title":"Creating Admin Users","text":""},{"location":"usage/admin-users/#automatic-creation-initial-admin","title":"Automatic Creation (Initial Admin)","text":"<p>The easiest way to create your first admin user is during CRUDAdmin initialization:</p> <pre><code># Create admin interface with initial admin user\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=os.environ[\"ADMIN_SECRET_KEY\"],\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"SecurePassword123!\"\n    }\n)\n</code></pre> <p>How it works:</p> <ul> <li>Only creates the admin user if no admin users exist</li> <li>Password is automatically hashed using bcrypt</li> <li>User is created with superuser privileges</li> <li>Runs during <code>admin.initialize()</code> or at startup</li> </ul>"},{"location":"usage/admin-users/#manual-creation-via-admin-interface","title":"Manual Creation via Admin Interface","text":"<p>Once you have access to the admin interface:</p> <ol> <li>Navigate to Admin Users: Go to <code>/admin/AdminUser</code></li> <li>Click \"Add AdminUser\": Use the create button</li> <li>Fill the form:<ul> <li>Username: 2-20 characters, lowercase letters and numbers only (<code>a-z0-9</code>)</li> <li>Password: Minimum 8 characters with letters, numbers, and special characters</li> </ul> </li> <li>Submit: User is created with superuser privileges</li> </ol>"},{"location":"usage/admin-users/#creation-via-code","title":"Creation via Code","text":"<p>For programmatic user creation:</p> <pre><code>from crudadmin.admin_user.schemas import AdminUserCreate\n\nasync def create_admin_user(username: str, password: str):\n    # Create the user data\n    user_data = AdminUserCreate(\n        username=username,\n        password=password  # Will be hashed automatically\n    )\n\n    # Get admin database session\n    async for admin_session in admin.db_config.get_admin_db():\n        try:\n            # Create user using the admin user service\n            hashed_password = admin.admin_user_service.get_password_hash(password)\n            internal_data = AdminUserCreateInternal(\n                username=username,\n                hashed_password=hashed_password,\n            )\n\n            await admin.db_config.crud_users.create(\n                admin_session, object=internal_data\n            )\n            await admin_session.commit()\n            print(f\"Created admin user: {username}\")\n\n        except Exception as e:\n            print(f\"Error creating user: {e}\")\n            await admin_session.rollback()\n\n# Usage\nawait create_admin_user(\"manager\", \"SecurePass456!\")\n</code></pre>"},{"location":"usage/admin-users/#user-requirements-and-validation","title":"User Requirements and Validation","text":""},{"location":"usage/admin-users/#username-requirements","title":"Username Requirements","text":"<p>Admin usernames must follow specific rules:</p> <pre><code># \u2705 Valid usernames\n\"admin\"      # Basic admin\n\"user123\"    # Numbers allowed\n\"manager2\"   # Alphanumeric\n\n# \u274c Invalid usernames\n\"Admin\"      # No uppercase letters\n\"user-name\"  # No hyphens\n\"user_name\"  # No underscores\n\"ab\"         # Too short (minimum 2 characters)\n\"verylongusernamethatexceedslimit\"  # Too long (maximum 20 characters)\n</code></pre> <p>Pattern: <code>^[a-z0-9]+$</code> (lowercase letters and numbers only)</p>"},{"location":"usage/admin-users/#password-requirements","title":"Password Requirements","text":"<p>Passwords must meet security standards:</p> <pre><code># \u2705 Valid passwords\n\"SecurePass123!\"    # Letters, numbers, special chars\n\"MyPassword2024#\"   # Mixed case, numbers, symbols\n\"admin@2024!pass\"   # Complex combination\n\n# \u274c Invalid passwords\n\"simple\"           # Too short (minimum 8 characters)\n\"password\"         # No numbers or special characters\n\"12345678\"         # Only numbers\n\"UPPERCASE\"        # No lowercase or numbers\n</code></pre> <p>Requirements:</p> <ul> <li>Minimum 8 characters</li> <li>Must contain letters, numbers, or special characters</li> <li>Pattern validation: <code>^.{8,}|[0-9]+|[A-Z]+|[a-z]+|[^a-zA-Z0-9]+$</code></li> </ul>"},{"location":"usage/admin-users/#managing-existing-users","title":"Managing Existing Users","text":""},{"location":"usage/admin-users/#viewing-admin-users","title":"Viewing Admin Users","text":"<p>To see all admin users:</p> <ol> <li>Access AdminUser section: Navigate to <code>/admin/AdminUser</code></li> <li>View user list: See all admin accounts with:<ul> <li>Username</li> <li>Creation date</li> <li>Last updated date</li> <li>Superuser status</li> </ul> </li> </ol>"},{"location":"usage/admin-users/#editing-user-details","title":"Editing User Details","text":"<p>To modify an existing admin user:</p> <ol> <li>Select user: Check the box next to the user in the list</li> <li>Click \"Update\": Opens the edit form</li> <li>Modify fields:<ul> <li>Username: Change if needed (subject to validation rules)</li> <li>Password: Leave blank to keep current password, or enter new password</li> </ul> </li> <li>Save changes: Submit the form</li> </ol> <p>Code example for programmatic updates:</p> <pre><code>from crudadmin.admin_user.schemas import AdminUserUpdate\n\nasync def update_admin_user(\n    user_id: int,\n    new_password: str = None,\n    new_username: str = None\n):\n    # Prepare update data (only include fields that are changing)\n    update_data = {}\n    if new_username:\n        update_data[\"username\"] = new_username\n    if new_password:\n        update_data[\"password\"] = new_password  # Will be hashed automatically\n\n    if not update_data:\n        print(\"No changes to make\")\n        return\n\n    user_update = AdminUserUpdate(**update_data)\n\n    async for admin_session in admin.db_config.get_admin_db():\n        try:\n            await admin.db_config.crud_users.update(\n                admin_session, \n                object=user_update, \n                id=user_id\n            )\n            await admin_session.commit()\n            print(f\"Updated user ID {user_id}\")\n\n        except Exception as e:\n            print(f\"Error updating user: {e}\")\n            await admin_session.rollback()\n\n# Usage\nawait update_admin_user(user_id=1, new_password=\"NewSecurePass789!\")\n</code></pre>"},{"location":"usage/admin-users/#password-changes","title":"Password Changes","text":"<p>When changing passwords:</p> <ol> <li>Via Interface: Enter new password in the password field during edit</li> <li>Via Code: Use the update method with a new password</li> <li>Security: Old password is completely replaced (no password history)</li> </ol> <p>Important Notes:</p> <ul> <li>Passwords are automatically hashed using bcrypt</li> <li>Empty password field during update means \"no change\"</li> <li>New password must meet all validation requirements</li> </ul>"},{"location":"usage/admin-users/#user-permissions-and-access-control","title":"User Permissions and Access Control","text":""},{"location":"usage/admin-users/#superuser-status","title":"Superuser Status","text":"<p>All admin users in CRUDAdmin have superuser privileges by default:</p> <pre><code># User model structure\nclass AdminUser:\n    id: int\n    username: str\n    hashed_password: str\n    created_at: datetime\n    updated_at: Optional[datetime]\n    is_superuser: bool = True  # Always True for admin users\n</code></pre> <p>What superuser means: - Full access to all admin interface features - Can view, create, update, and delete all records - Access to management features (health checks, event logs) - Can manage other admin users</p>"},{"location":"usage/admin-users/#available-actions","title":"Available Actions","text":"<p>Admin users can perform these actions in the interface:</p> Action AdminUser AdminSession Your Models View \u2705 \u2705 \u2705* Create \u2705 \u274c \u2705* Update \u2705 \u274c \u2705* Delete \u274c \u2705 \u2705* <p>Notes:</p> <ul> <li><code>*</code> = Depends on <code>allowed_actions</code> configuration for your models</li> <li>AdminUser deletion is disabled to prevent accidental lockouts</li> <li>AdminSessions can be deleted to force logout</li> </ul>"},{"location":"usage/admin-users/#session-management","title":"Session Management","text":"<p>Each admin user can have multiple concurrent sessions:</p> <pre><code># Configure session limits (in CRUDAdmin initialization)\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=key,\n    max_sessions_per_user=3,        # Limit concurrent sessions\n    session_timeout_minutes=30,     # Auto-logout after inactivity\n    cleanup_interval_minutes=15,    # How often to clean expired sessions\n)\n</code></pre> <p>Session behavior:</p> <ul> <li>Each login creates a new session</li> <li>Sessions expire after inactivity timeout</li> <li>Exceeding max sessions removes oldest session</li> <li>Sessions can be viewed/deleted in AdminSession section</li> </ul>"},{"location":"usage/admin-users/#security-best-practices","title":"Security Best Practices","text":""},{"location":"usage/admin-users/#environment-based-user-management","title":"Environment-Based User Management","text":"<pre><code># Development: Simple auto-admin\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=\"dev-key-change-in-production\",\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"admin123\"  # Simple for development\n    }\n)\n\n# Production: No auto-admin, manual creation\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=os.environ[\"ADMIN_SECRET_KEY\"],\n    initial_admin=None  # Create admin users manually\n)\n</code></pre>"},{"location":"usage/admin-users/#strong-password-policies","title":"Strong Password Policies","text":"<p>Implement additional password checks:</p> <pre><code>import re\n\ndef validate_strong_password(password: str) -&gt; bool:\n    \"\"\"Enhanced password validation\"\"\"\n    checks = [\n        len(password) &gt;= 12,  # Longer minimum\n        re.search(r'[A-Z]', password),  # Uppercase letter\n        re.search(r'[a-z]', password),  # Lowercase letter\n        re.search(r'\\d', password),     # Number\n        re.search(r'[!@#$%^&amp;*(),.?\":{}|&lt;&gt;]', password),  # Special char\n        password != password.lower(),   # Mixed case\n        password != password.upper(),   # Mixed case\n    ]\n    return all(checks)\n\n# Use in your application\ndef create_secure_admin(username: str, password: str):\n    if not validate_strong_password(password):\n        raise ValueError(\"Password does not meet security requirements\")\n\n    # Create user...\n</code></pre>"},{"location":"usage/admin-users/#regular-user-auditing","title":"Regular User Auditing","text":"<p>Monitor and audit admin users:</p> <pre><code>async def audit_admin_users():\n    \"\"\"List all admin users with their last activity\"\"\"\n    async for admin_session in admin.db_config.get_admin_db():\n        # Get all admin users\n        users = await admin.db_config.crud_users.get_multi(admin_session)\n\n        print(\"Admin Users Audit:\")\n        print(\"-\" * 50)\n        for user in users:\n            print(f\"Username: {user.username}\")\n            print(f\"Created: {user.created_at}\")\n            print(f\"Updated: {user.updated_at}\")\n            print(f\"Superuser: {user.is_superuser}\")\n            print(\"-\" * 30)\n\n# Run periodically\nawait audit_admin_users()\n</code></pre>"},{"location":"usage/admin-users/#session-security","title":"Session Security","text":"<p>Monitor active sessions:</p> <pre><code>async def check_active_sessions():\n    \"\"\"Review active admin sessions\"\"\"\n    async for admin_session in admin.db_config.get_admin_db():\n        sessions = await admin.db_config.crud_sessions.get_multi(admin_session)\n\n        print(\"Active Sessions:\")\n        print(\"-\" * 40)\n        for session in sessions:\n            print(f\"User: {session.user_id}\")\n            print(f\"Created: {session.created_at}\")\n            print(f\"Expires: {session.expires_at}\")\n            print(\"-\" * 20)\n\nawait check_active_sessions()\n</code></pre>"},{"location":"usage/admin-users/#common-tasks","title":"Common Tasks","text":""},{"location":"usage/admin-users/#resetting-a-user-password","title":"Resetting a User Password","text":"<pre><code>async def reset_user_password(username: str, new_password: str):\n    \"\"\"Reset password for a specific user\"\"\"\n    if not validate_strong_password(new_password):\n        raise ValueError(\"New password does not meet requirements\")\n\n    async for admin_session in admin.db_config.get_admin_db():\n        try:\n            # Find user by username\n            user = await admin.db_config.crud_users.get(\n                admin_session, \n                username=username\n            )\n\n            if not user:\n                print(f\"User '{username}' not found\")\n                return\n\n            # Update password\n            update_data = AdminUserUpdate(password=new_password)\n            await admin.db_config.crud_users.update(\n                admin_session,\n                object=update_data,\n                id=user.id\n            )\n            await admin_session.commit()\n            print(f\"Password reset for user '{username}'\")\n\n        except Exception as e:\n            print(f\"Error resetting password: {e}\")\n            await admin_session.rollback()\n\n# Usage\nawait reset_user_password(\"admin\", \"NewSecurePassword123!\")\n</code></pre>"},{"location":"usage/admin-users/#disabling-a-user-workaround","title":"Disabling a User (Workaround)","text":"<p>Since there's no built-in disable feature, you can change their password:</p> <pre><code>async def disable_user(username: str):\n    \"\"\"Effectively disable a user by setting an unusable password\"\"\"\n    import secrets\n\n    # Set a random, unknown password\n    random_password = secrets.token_urlsafe(32)\n    await reset_user_password(username, random_password)\n    print(f\"User '{username}' has been effectively disabled\")\n    print(\"Store this password securely if you need to re-enable:\")\n    print(f\"Password: {random_password}\")\n\n# Usage\nawait disable_user(\"oldadmin\")\n</code></pre>"},{"location":"usage/admin-users/#force-logout-session-termination","title":"Force Logout (Session Termination)","text":"<pre><code>async def force_user_logout(username: str):\n    \"\"\"Terminate all sessions for a specific user\"\"\"\n    async for admin_session in admin.db_config.get_admin_db():\n        try:\n            # Get user\n            user = await admin.db_config.crud_users.get(\n                admin_session,\n                username=username\n            )\n\n            if not user:\n                print(f\"User '{username}' not found\")\n                return\n\n            # Delete all sessions for this user\n            await admin.db_config.crud_sessions.delete(\n                admin_session,\n                user_id=user.id\n            )\n            await admin_session.commit()\n            print(f\"All sessions terminated for user '{username}'\")\n\n        except Exception as e:\n            print(f\"Error terminating sessions: {e}\")\n            await admin_session.rollback()\n\n# Usage\nawait force_user_logout(\"admin\")\n</code></pre>"},{"location":"usage/admin-users/#next-steps","title":"Next Steps","text":"<p>After setting up admin users:</p> <ol> <li>Learn the Interface to effectively navigate and use the admin panel</li> <li>Add Models to manage your application data</li> <li>Explore Advanced Topics for production-level user management and security features </li> </ol>"},{"location":"usage/common-patterns/","title":"Common Patterns","text":"<p>This guide demonstrates common real-world patterns and scenarios you'll encounter when building admin interfaces with CRUDAdmin. Each pattern includes complete examples with models, schemas, and configuration.</p>"},{"location":"usage/common-patterns/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic understanding of Adding Models</li> <li>Familiarity with Admin Interface operations</li> <li>Knowledge of SQLAlchemy relationships and Pydantic schemas</li> </ul>"},{"location":"usage/common-patterns/#multi-model-relationships","title":"Multi-Model Relationships","text":""},{"location":"usage/common-patterns/#blog-system-pattern","title":"Blog System Pattern","text":"<p>A common pattern is managing content with related models (users, posts, comments, tags).</p> Complete Blog System Models <pre><code># models.py\nfrom sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, Boolean, Table\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom datetime import datetime\n\nBase = declarative_base()\n\n# Many-to-many association table\npost_tags = Table('post_tags', Base.metadata,\n    Column('post_id', Integer, ForeignKey('posts.id')),\n    Column('tag_id', Integer, ForeignKey('tags.id'))\n)\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(50), unique=True, index=True)\n    email = Column(String(100), unique=True, index=True)\n    full_name = Column(String(100))\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"author\")\n    comments = relationship(\"Comment\", back_populates=\"author\")\n\nclass Category(Base):\n    __tablename__ = \"categories\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(50), unique=True)\n    description = Column(Text)\n\n    # Relationships\n    posts = relationship(\"Post\", back_populates=\"category\")\n\nclass Tag(Base):\n    __tablename__ = \"tags\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(30), unique=True)\n    color = Column(String(7))  # Hex color code\n\n    # Relationships\n    posts = relationship(\"Post\", secondary=post_tags, back_populates=\"tags\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(200))\n    content = Column(Text)\n    excerpt = Column(String(500))\n    author_id = Column(Integer, ForeignKey(\"users.id\"))\n    category_id = Column(Integer, ForeignKey(\"categories.id\"))\n    published = Column(Boolean, default=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"posts\")\n    category = relationship(\"Category\", back_populates=\"posts\")\n    comments = relationship(\"Comment\", back_populates=\"post\")\n    tags = relationship(\"Tag\", secondary=post_tags, back_populates=\"posts\")\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    content = Column(Text)\n    author_id = Column(Integer, ForeignKey(\"users.id\"))\n    post_id = Column(Integer, ForeignKey(\"posts.id\"))\n    approved = Column(Boolean, default=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    author = relationship(\"User\", back_populates=\"comments\")\n    post = relationship(\"Post\", back_populates=\"comments\")\n</code></pre> Pydantic Schemas for Blog System <pre><code># schemas.py\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\nfrom typing import Optional, List\n\n# User Schemas\nclass UserBase(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    full_name: str = Field(..., max_length=100)\n    is_active: bool = True\n\nclass UserCreate(UserBase):\n    pass\n\nclass UserUpdate(UserBase):\n    username: Optional[str] = Field(None, min_length=3, max_length=50)\n    email: Optional[EmailStr] = None\n    full_name: Optional[str] = Field(None, max_length=100)\n    is_active: Optional[bool] = None\n\nclass UserRead(UserBase):\n    id: int\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n# Category Schemas\nclass CategoryBase(BaseModel):\n    name: str = Field(..., max_length=50)\n    description: Optional[str] = None\n\nclass CategoryCreate(CategoryBase):\n    pass\n\nclass CategoryUpdate(CategoryBase):\n    name: Optional[str] = Field(None, max_length=50)\n\nclass CategoryRead(CategoryBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\n# Tag Schemas\nclass TagBase(BaseModel):\n    name: str = Field(..., max_length=30)\n    color: str = Field(..., regex=r'^#[0-9A-Fa-f]{6}$')\n\nclass TagCreate(TagBase):\n    pass\n\nclass TagUpdate(TagBase):\n    name: Optional[str] = Field(None, max_length=30)\n    color: Optional[str] = Field(None, regex=r'^#[0-9A-Fa-f]{6}$')\n\nclass TagRead(TagBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\n# Post Schemas\nclass PostBase(BaseModel):\n    title: str = Field(..., max_length=200)\n    content: str\n    excerpt: Optional[str] = Field(None, max_length=500)\n    category_id: int\n    published: bool = False\n\nclass PostCreate(PostBase):\n    author_id: int\n\nclass PostUpdate(PostBase):\n    title: Optional[str] = Field(None, max_length=200)\n    content: Optional[str] = None\n    category_id: Optional[int] = None\n    published: Optional[bool] = None\n\nclass PostRead(PostBase):\n    id: int\n    author_id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\n# Comment Schemas\nclass CommentBase(BaseModel):\n    content: str\n\nclass CommentCreate(CommentBase):\n    author_id: int\n    post_id: int\n\nclass CommentUpdate(CommentBase):\n    content: Optional[str] = None\n    approved: Optional[bool] = None\n\nclass CommentRead(CommentBase):\n    id: int\n    author_id: int\n    post_id: int\n    approved: bool\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"usage/common-patterns/#registration-pattern","title":"Registration Pattern","text":"<pre><code>from crudadmin import CRUDAdmin\nfrom models import User, Category, Tag, Post, Comment\nfrom schemas import (\n    UserCreate, UserUpdate, UserRead,\n    CategoryCreate, CategoryUpdate, CategoryRead,\n    TagCreate, TagUpdate, TagRead,\n    PostCreate, PostUpdate, PostRead,\n    CommentCreate, CommentUpdate, CommentRead\n)\n\n# Initialize CRUDAdmin\ncrud_admin = CRUDAdmin(\n    session_backend=\"database\",\n    secret_key=\"your-secret-key-here\",\n    title=\"Blog Admin\"\n)\n\n# Register models in logical order\ncrud_admin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    read_schema=UserRead\n)\n\ncrud_admin.add_view(\n    model=Category,\n    create_schema=CategoryCreate,\n    update_schema=CategoryUpdate,\n    read_schema=CategoryRead\n)\n\ncrud_admin.add_view(\n    model=Tag,\n    create_schema=TagCreate,\n    update_schema=TagUpdate,\n    read_schema=TagRead\n)\n\ncrud_admin.add_view(\n    model=Post,\n    create_schema=PostCreate,\n    update_schema=PostUpdate,\n    read_schema=PostRead\n)\n\ncrud_admin.add_view(\n    model=Comment,\n    create_schema=CommentCreate,\n    update_schema=CommentUpdate,\n    read_schema=CommentRead\n)\n</code></pre>"},{"location":"usage/common-patterns/#why-this-pattern-works","title":"Why This Pattern Works","text":"<ol> <li>Clear hierarchy: Users \u2192 Categories/Tags \u2192 Posts \u2192 Comments</li> <li>Manageable complexity: Each model has focused responsibility</li> <li>Relationship visibility: Foreign key fields show in forms</li> <li>Data integrity: Relationships enforce referential integrity</li> </ol>"},{"location":"usage/common-patterns/#e-commerce-management-pattern","title":"E-commerce Management Pattern","text":""},{"location":"usage/common-patterns/#product-catalog-system","title":"Product Catalog System","text":"<p>Managing products, inventory, orders, and customers in an e-commerce admin.</p> E-commerce Models <pre><code># ecommerce_models.py\nfrom sqlalchemy import Column, Integer, String, Decimal, ForeignKey, DateTime, Boolean, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom datetime import datetime\nfrom decimal import Decimal as PyDecimal\n\nBase = declarative_base()\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String(100), unique=True, index=True)\n    first_name = Column(String(50))\n    last_name = Column(String(50))\n    phone = Column(String(20))\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    orders = relationship(\"Order\", back_populates=\"customer\")\n\nclass ProductCategory(Base):\n    __tablename__ = \"product_categories\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), unique=True)\n    description = Column(Text)\n    is_active = Column(Boolean, default=True)\n\n    # Relationships\n    products = relationship(\"Product\", back_populates=\"category\")\n\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    sku = Column(String(50), unique=True, index=True)\n    name = Column(String(200))\n    description = Column(Text)\n    price = Column(Decimal(10, 2))\n    cost = Column(Decimal(10, 2))\n    category_id = Column(Integer, ForeignKey(\"product_categories.id\"))\n    stock_quantity = Column(Integer, default=0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    category = relationship(\"ProductCategory\", back_populates=\"products\")\n    order_items = relationship(\"OrderItem\", back_populates=\"product\")\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    order_number = Column(String(20), unique=True, index=True)\n    customer_id = Column(Integer, ForeignKey(\"customers.id\"))\n    status = Column(String(20), default=\"pending\")  # pending, processing, shipped, delivered, cancelled\n    total_amount = Column(Decimal(10, 2))\n    shipping_address = Column(Text)\n    order_date = Column(DateTime, default=datetime.utcnow)\n    shipped_date = Column(DateTime, nullable=True)\n\n    # Relationships\n    customer = relationship(\"Customer\", back_populates=\"orders\")\n    items = relationship(\"OrderItem\", back_populates=\"order\")\n\nclass OrderItem(Base):\n    __tablename__ = \"order_items\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"))\n    product_id = Column(Integer, ForeignKey(\"products.id\"))\n    quantity = Column(Integer)\n    unit_price = Column(Decimal(10, 2))\n    total_price = Column(Decimal(10, 2))\n\n    # Relationships\n    order = relationship(\"Order\", back_populates=\"items\")\n    product = relationship(\"Product\", back_populates=\"order_items\")\n</code></pre> E-commerce Schemas <pre><code># ecommerce_schemas.py\nfrom pydantic import BaseModel, EmailStr, Field, field_validator\nfrom datetime import datetime\nfrom typing import Optional\nfrom decimal import Decimal\nfrom enum import Enum\n\nclass OrderStatus(str, Enum):\n    pending = \"pending\"\n    processing = \"processing\"\n    shipped = \"shipped\"\n    delivered = \"delivered\"\n    cancelled = \"cancelled\"\n\n# Customer Schemas\nclass CustomerBase(BaseModel):\n    email: EmailStr\n    first_name: str = Field(..., max_length=50)\n    last_name: str = Field(..., max_length=50)\n    phone: Optional[str] = Field(None, max_length=20)\n    is_active: bool = True\n\nclass CustomerCreate(CustomerBase):\n    pass\n\nclass CustomerUpdate(CustomerBase):\n    email: Optional[EmailStr] = None\n    first_name: Optional[str] = Field(None, max_length=50)\n    last_name: Optional[str] = Field(None, max_length=50)\n\nclass CustomerRead(CustomerBase):\n    id: int\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n# Product Category Schemas\nclass ProductCategoryBase(BaseModel):\n    name: str = Field(..., max_length=100)\n    description: Optional[str] = None\n    is_active: bool = True\n\nclass ProductCategoryCreate(ProductCategoryBase):\n    pass\n\nclass ProductCategoryUpdate(ProductCategoryBase):\n    name: Optional[str] = Field(None, max_length=100)\n    is_active: Optional[bool] = None\n\nclass ProductCategoryRead(ProductCategoryBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\n# Product Schemas\nclass ProductBase(BaseModel):\n    sku: str = Field(..., max_length=50)\n    name: str = Field(..., max_length=200)\n    description: Optional[str] = None\n    price: Decimal = Field(..., gt=0, decimal_places=2)\n    cost: Decimal = Field(..., ge=0, decimal_places=2)\n    category_id: int\n    stock_quantity: int = Field(..., ge=0)\n    is_active: bool = True\n\n    @field_validator('price', 'cost')\n    @classmethod\n    def validate_price(cls, v):\n        if v &lt;= 0:\n            raise ValueError('Price and cost must be positive')\n        return v\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass ProductUpdate(ProductBase):\n    sku: Optional[str] = Field(None, max_length=50)\n    name: Optional[str] = Field(None, max_length=200)\n    price: Optional[Decimal] = Field(None, gt=0, decimal_places=2)\n    cost: Optional[Decimal] = Field(None, ge=0, decimal_places=2)\n    category_id: Optional[int] = None\n    stock_quantity: Optional[int] = Field(None, ge=0)\n    is_active: Optional[bool] = None\n\nclass ProductRead(ProductBase):\n    id: int\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n# Order Schemas\nclass OrderBase(BaseModel):\n    customer_id: int\n    status: OrderStatus = OrderStatus.pending\n    shipping_address: str\n\nclass OrderCreate(OrderBase):\n    order_number: str = Field(..., max_length=20)\n    total_amount: Decimal = Field(..., ge=0, decimal_places=2)\n\nclass OrderUpdate(BaseModel):\n    status: Optional[OrderStatus] = None\n    shipping_address: Optional[str] = None\n    shipped_date: Optional[datetime] = None\n\nclass OrderRead(OrderBase):\n    id: int\n    order_number: str\n    total_amount: Decimal\n    order_date: datetime\n    shipped_date: Optional[datetime]\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"usage/common-patterns/#e-commerce-admin-setup","title":"E-commerce Admin Setup","text":"<pre><code>from crudadmin import CRUDAdmin\nfrom ecommerce_models import Customer, ProductCategory, Product, Order, OrderItem\nfrom ecommerce_schemas import (\n    CustomerCreate, CustomerUpdate, CustomerRead,\n    ProductCategoryCreate, ProductCategoryUpdate, ProductCategoryRead,\n    ProductCreate, ProductUpdate, ProductRead,\n    OrderCreate, OrderUpdate, OrderRead\n)\n\n# Configure for e-commerce scale\ncrud_admin = CRUDAdmin(\n    session_backend=\"redis\",  # Better for high traffic\n    redis_url=\"redis://localhost:6379\",\n    secret_key=\"your-ecommerce-secret-key\",\n    title=\"E-commerce Admin\",\n    default_page_size=50,  # More records per page\n    max_page_size=200\n)\n\n# Register in business workflow order\ncrud_admin.add_view(\n    model=ProductCategory,\n    create_schema=ProductCategoryCreate,\n    update_schema=ProductCategoryUpdate,\n    read_schema=ProductCategoryRead\n)\n\ncrud_admin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    read_schema=ProductRead\n)\n\ncrud_admin.add_view(\n    model=Customer,\n    create_schema=CustomerCreate,\n    update_schema=CustomerUpdate,\n    read_schema=CustomerRead\n)\n\ncrud_admin.add_view(\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    read_schema=OrderRead\n)\n</code></pre>"},{"location":"usage/common-patterns/#why-this-e-commerce-pattern-works","title":"Why This E-commerce Pattern Works","text":"<ol> <li>Business logic validation: Price/cost validation in schemas</li> <li>Enum handling: Order status as proper enums</li> <li>Decimal precision: Proper handling of money values</li> <li>Scalable session backend: Redis for high traffic</li> <li>Larger page sizes: Better for inventory management</li> </ol>"},{"location":"usage/common-patterns/#role-based-access-pattern","title":"Role-Based Access Pattern","text":"<p>Workaround Pattern</p> <p>Important: CRUDAdmin does not currently support built-in role-based access control. The patterns shown below are workarounds that create separate admin instances with different configurations to simulate different access levels. </p> <p>Future versions of CRUDAdmin may include native RBAC features. For now, use these patterns if you need different admin interfaces for different user roles.</p>"},{"location":"usage/common-patterns/#different-admin-levels","title":"Different Admin Levels","text":"<p>Creating different access levels for various admin roles using separate CRUDAdmin instances.</p>"},{"location":"usage/common-patterns/#super-admin-pattern","title":"Super Admin Pattern","text":"<pre><code>from crudadmin import CRUDAdmin\n\n# Super Admin - Full access\nsuper_admin = CRUDAdmin(\n    session_backend=\"redis\",\n    secret_key=\"super-admin-secret\",\n    title=\"Super Admin Panel\",\n    mount_path=\"/superadmin\"\n)\n\n# All models with full CRUD\nsuper_admin.add_view(\n    model=User,\n    create_schema=UserCreate,\n    update_schema=UserUpdate,\n    read_schema=UserRead,\n    # Full permissions (default)\n)\n\nsuper_admin.add_view(\n    model=Order,\n    create_schema=OrderCreate,\n    update_schema=OrderUpdate,\n    read_schema=OrderRead\n)\n</code></pre>"},{"location":"usage/common-patterns/#content-editor-pattern","title":"Content Editor Pattern","text":"<pre><code># Content Editor - Limited access\ncontent_admin = CRUDAdmin(\n    session_backend=\"redis\",\n    secret_key=\"content-editor-secret\", \n    title=\"Content Editor\",\n    mount_path=\"/content\"\n)\n\n# Posts - Full access\ncontent_admin.add_view(\n    model=Post,\n    create_schema=PostCreate,\n    update_schema=PostUpdate,\n    read_schema=PostRead\n)\n\n# Comments - Read and moderate only\ncontent_admin.add_view(\n    model=Comment,\n    create_schema=None,  # No creation\n    update_schema=CommentModerationUpdate,  # Limited updates\n    read_schema=CommentRead,\n    delete_permission=True  # Can delete inappropriate comments\n)\n\n# Users - Read only\ncontent_admin.add_view(\n    model=User,\n    create_schema=None,\n    update_schema=None,\n    read_schema=UserRead,\n    delete_permission=False\n)\n</code></pre>"},{"location":"usage/common-patterns/#customer-service-pattern","title":"Customer Service Pattern","text":"<pre><code># Customer Service - Customer and order focus\nservice_admin = CRUDAdmin(\n    session_backend=\"redis\",\n    secret_key=\"service-secret\",\n    title=\"Customer Service\",\n    mount_path=\"/service\"\n)\n\n# Customers - Full access\nservice_admin.add_view(\n    model=Customer,\n    create_schema=CustomerCreate,\n    update_schema=CustomerUpdate,\n    read_schema=CustomerRead\n)\n\n# Orders - Update status only\nservice_admin.add_view(\n    model=Order,\n    create_schema=None,  # No new order creation\n    update_schema=OrderStatusUpdate,  # Status changes only\n    read_schema=OrderRead,\n    delete_permission=False  # Cannot delete orders\n)\n\n# Products - Read only for reference\nservice_admin.add_view(\n    model=Product,\n    create_schema=None,\n    update_schema=None,\n    read_schema=ProductRead,\n    delete_permission=False\n)\n</code></pre>"},{"location":"usage/common-patterns/#implementation-considerations","title":"Implementation Considerations","text":"<p>When using this workaround pattern:</p> <p>Pros:</p> <ul> <li>\u2705 Simple to implement and understand</li> <li>\u2705 Complete separation between different access levels</li> <li>\u2705 Different URLs for different roles (<code>/superadmin</code>, <code>/content</code>, <code>/service</code>)</li> <li>\u2705 Independent authentication for each role</li> </ul> <p>Cons:</p> <ul> <li>\u274c Requires separate admin instances and maintenance</li> <li>\u274c No shared user session across different admin interfaces</li> <li>\u274c Duplicate configuration and setup code</li> <li>\u274c Users need separate credentials for different admin areas</li> </ul> <p>Future RBAC Features:</p> <p>When CRUDAdmin adds native role-based access control, you'll be able to:</p> <ul> <li>Define roles and permissions in a single admin instance</li> <li>Control model visibility and actions per user role</li> <li>Share sessions across the same admin interface</li> <li>Dynamically show/hide features based on user permissions</li> </ul>"},{"location":"usage/common-patterns/#advanced-validation-patterns","title":"Advanced Validation Patterns","text":""},{"location":"usage/common-patterns/#business-logic-validation","title":"Business Logic Validation","text":"<p>Complex validation rules that go beyond basic field validation.</p>"},{"location":"usage/common-patterns/#inventory-management-validation","title":"Inventory Management Validation","text":"<pre><code>from pydantic import BaseModel, field_validator, model_validator\nfrom typing import Optional, Dict, Any\nfrom typing_extensions import Self\n\nclass ProductUpdateAdvanced(BaseModel):\n    name: Optional[str] = None\n    price: Optional[Decimal] = None\n    cost: Optional[Decimal] = None\n    stock_quantity: Optional[int] = None\n    is_active: Optional[bool] = None\n\n    @field_validator('price')\n    @classmethod\n    def price_must_be_reasonable(cls, v):\n        if v is not None and v &gt; 10000:\n            raise ValueError('Price cannot exceed $10,000')\n        return v\n\n    @field_validator('stock_quantity') \n    @classmethod\n    def stock_cannot_be_negative(cls, v):\n        if v is not None and v &lt; 0:\n            raise ValueError('Stock quantity cannot be negative')\n        return v\n\n    @model_validator(mode='after')\n    def price_above_cost(self) -&gt; Self:\n        if self.price is not None and self.cost is not None:\n            if self.price &lt;= self.cost:\n                raise ValueError('Price must be greater than cost')\n        return self\n\n    @model_validator(mode='after')\n    def deactivate_out_of_stock(self) -&gt; Self:\n        if self.stock_quantity is not None and self.stock_quantity == 0 and self.is_active is True:\n            raise ValueError('Cannot activate product with zero stock')\n        return self\n</code></pre>"},{"location":"usage/common-patterns/#order-processing-validation","title":"Order Processing Validation","text":"<pre><code>from pydantic import BaseModel, field_validator, model_validator\nfrom typing import Optional\nfrom typing_extensions import Self\nfrom datetime import datetime, timedelta\n\nclass OrderUpdateAdvanced(BaseModel):\n    status: Optional[OrderStatus] = None\n    shipped_date: Optional[datetime] = None\n    tracking_number: Optional[str] = None\n\n    @field_validator('shipped_date')\n    @classmethod\n    def shipped_date_reasonable(cls, v):\n        if v is not None:\n            if v &lt; datetime.utcnow().replace(tzinfo=None):\n                raise ValueError('Shipped date cannot be in the past')\n            if v &gt; datetime.utcnow().replace(tzinfo=None) + timedelta(days=30):\n                raise ValueError('Shipped date too far in future')\n        return v\n\n    @model_validator(mode='after')\n    def status_transition_rules(self) -&gt; Self:\n        if self.status == OrderStatus.shipped:\n            if not self.shipped_date:\n                raise ValueError('Shipped orders must have shipped date')\n            if not self.tracking_number:\n                raise ValueError('Shipped orders must have tracking number')\n\n        if self.status == OrderStatus.delivered:\n            if not self.shipped_date:\n                raise ValueError('Delivered orders must have been shipped first')\n\n        return self\n</code></pre>"},{"location":"usage/common-patterns/#performance-optimization-patterns","title":"Performance Optimization Patterns","text":""},{"location":"usage/common-patterns/#large-dataset-management","title":"Large Dataset Management","text":"<p>Optimizing CRUDAdmin for applications with millions of records.</p>"},{"location":"usage/common-patterns/#pagination-strategy","title":"Pagination Strategy","text":"<pre><code># Configure for large datasets\ncrud_admin = CRUDAdmin(\n    session_backend=\"redis\",\n    secret_key=\"your-key\",\n    title=\"High Volume Admin\",\n    default_page_size=25,  # Smaller default for faster loading\n    max_page_size=100,     # Prevent excessive queries\n    session_timeout=1800   # 30 minutes for long admin sessions\n)\n\n# Enable database indexes in your models\nclass Product(Base):\n    __tablename__ = \"products\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    sku = Column(String(50), unique=True, index=True)  # Indexed for fast lookup\n    name = Column(String(200), index=True)             # Indexed for search\n    category_id = Column(Integer, ForeignKey(\"categories.id\"), index=True)  # Indexed FK\n    price = Column(Decimal(10, 2), index=True)         # Indexed for sorting\n    is_active = Column(Boolean, default=True, index=True)  # Indexed for filtering\n    created_at = Column(DateTime, default=datetime.utcnow, index=True)  # Indexed for sorting\n</code></pre>"},{"location":"usage/common-patterns/#memory-efficient-schema-patterns","title":"Memory-Efficient Schema Patterns","text":"<pre><code># Lightweight read schemas for list views\nclass ProductListRead(BaseModel):\n    id: int\n    sku: str\n    name: str\n    price: Decimal\n    is_active: bool\n\n    class Config:\n        from_attributes = True\n\n# Detailed schema for individual record views\nclass ProductDetailRead(BaseModel):\n    id: int\n    sku: str\n    name: str\n    description: str\n    price: Decimal\n    cost: Decimal\n    category_id: int\n    stock_quantity: int\n    is_active: bool\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n# Use lightweight schema for list operations\ncrud_admin.add_view(\n    model=Product,\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    read_schema=ProductListRead  # Faster list loading\n)\n</code></pre>"},{"location":"usage/common-patterns/#integration-patterns","title":"Integration Patterns","text":""},{"location":"usage/common-patterns/#existing-fastapi-application","title":"Existing FastAPI Application","text":"<p>Integrating CRUDAdmin into an existing FastAPI application without conflicts.</p>"},{"location":"usage/common-patterns/#modular-integration","title":"Modular Integration","text":"<pre><code># main.py - Your existing FastAPI app\nfrom fastapi import FastAPI\nfrom your_app.routers import api_router\nfrom admin.setup import setup_admin\n\n# Your existing app\napp = FastAPI(title=\"Your API\")\n\n# Your existing routes\napp.include_router(api_router, prefix=\"/api/v1\")\n\n# Add admin interface\nadmin_app = setup_admin()\napp.mount(\"/admin\", admin_app)\n\n# Your existing startup/shutdown events\n@app.on_event(\"startup\")\nasync def startup():\n    # Your existing startup code\n    pass\n</code></pre> <pre><code># admin/setup.py - Separate admin configuration\nfrom crudadmin import CRUDAdmin\nfrom your_app.models import User, Product, Order\nfrom admin.schemas import AdminUserRead, AdminProductRead, AdminOrderRead\n\ndef setup_admin():\n    \"\"\"Configure and return admin application\"\"\"\n    crud_admin = CRUDAdmin(\n        session_backend=\"database\",\n        database_url=\"sqlite:///./admin_sessions.db\",  # Separate admin DB\n        secret_key=\"admin-secret-key\",\n        title=\"Your App Admin\",\n        mount_path=\"\"  # Mounted at /admin already\n    )\n\n    # Register your models\n    crud_admin.add_view(\n        model=User,\n        create_schema=UserCreate,\n        update_schema=UserUpdate,\n        read_schema=AdminUserRead\n    )\n\n    crud_admin.add_view(\n        model=Product,\n        create_schema=ProductCreate,\n        update_schema=ProductUpdate,\n        read_schema=AdminProductRead\n    )\n\n    crud_admin.add_view(\n        model=Order,\n        create_schema=OrderCreate,\n        update_schema=OrderUpdate,\n        read_schema=AdminOrderRead\n    )\n\n    return crud_admin.get_app()\n</code></pre>"},{"location":"usage/common-patterns/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># admin/config.py\nimport os\nfrom typing import Optional\n\nclass AdminConfig:\n    SECRET_KEY: str = os.getenv(\"ADMIN_SECRET_KEY\", \"change-this-in-production\")\n    SESSION_BACKEND: str = os.getenv(\"ADMIN_SESSION_BACKEND\", \"database\")\n    REDIS_URL: Optional[str] = os.getenv(\"ADMIN_REDIS_URL\")\n    DATABASE_URL: str = os.getenv(\"ADMIN_DATABASE_URL\", \"sqlite:///./admin_sessions.db\")\n    TITLE: str = os.getenv(\"ADMIN_TITLE\", \"Admin Panel\")\n    DEBUG: bool = os.getenv(\"ADMIN_DEBUG\", \"false\").lower() == \"true\"\n\n# Use in setup\ndef setup_admin():\n    config = AdminConfig()\n\n    crud_admin = CRUDAdmin(\n        session_backend=config.SESSION_BACKEND,\n        redis_url=config.REDIS_URL,\n        database_url=config.DATABASE_URL,\n        secret_key=config.SECRET_KEY,\n        title=config.TITLE\n    )\n\n    # Register models...\n    return crud_admin.get_app()\n</code></pre>"},{"location":"usage/common-patterns/#security-patterns","title":"Security Patterns","text":""},{"location":"usage/common-patterns/#production-security-configuration","title":"Production Security Configuration","text":"<p>Comprehensive security setup for production environments using built-in CRUDAdmin security features.</p>"},{"location":"usage/common-patterns/#built-in-ip-restrictions","title":"Built-in IP Restrictions","text":"<p>CRUDAdmin provides built-in IP restriction functionality:</p> <pre><code>from crudadmin import CRUDAdmin\nimport os\n\n# Production security configuration with built-in IP restrictions\ncrud_admin = CRUDAdmin(\n    # Session security\n    session_backend=\"redis\",\n    redis_url=os.getenv(\"REDIS_URL\"),\n    secret_key=os.getenv(\"ADMIN_SECRET_KEY\"),  # Strong random key\n    session_timeout_minutes=60,  # 1 hour timeout\n\n    # Built-in IP restrictions\n    allowed_ips=[\"127.0.0.1\", \"192.168.1.100\"],  # Specific IPs\n    allowed_networks=[\"192.168.1.0/24\", \"10.0.0.0/8\"],  # Network ranges\n\n    # Additional security\n    secure_cookies=True,\n    enforce_https=True,\n    max_sessions_per_user=5\n)\n</code></pre>"},{"location":"usage/common-patterns/#next-steps","title":"Next Steps","text":"<p>Master these common patterns to build robust admin interfaces. For more advanced features and configurations, see the Advanced Topics section.</p> <p>These patterns provide the foundation for most real-world CRUDAdmin implementations. Combine them based on your specific requirements to create powerful, efficient admin interfaces.</p>"},{"location":"usage/configuration/","title":"Basic Configuration","text":"<p>This guide covers the essential configuration steps for setting up your CRUDAdmin instance. You'll learn how to create the admin interface with the most common settings to get up and running quickly.</p>"},{"location":"usage/configuration/#prerequisites","title":"Prerequisites","text":"<p>Before configuring CRUDAdmin, ensure you have:</p> <ul> <li>A working FastAPI application</li> <li>SQLAlchemy models defined (see Quick Start)</li> <li>CRUDAdmin installed (<code>uv add crudadmin</code>)</li> <li>Basic understanding of FastAPI application structure</li> </ul>"},{"location":"usage/configuration/#creating-your-crudadmin-instance","title":"Creating Your CRUDAdmin Instance","text":""},{"location":"usage/configuration/#minimal-setup","title":"Minimal Setup","text":"<p>The simplest CRUDAdmin setup requires only two parameters:</p> <pre><code>from crudadmin import CRUDAdmin\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n# Minimal CRUDAdmin instance\nadmin = CRUDAdmin(\n    session=your_async_session,  # Your SQLAlchemy async session\n    SECRET_KEY=\"your-secret-key-here\"\n)\n</code></pre>"},{"location":"usage/configuration/#common-configuration","title":"Common Configuration","text":"<p>Here are the most commonly customized settings for getting started:</p> <pre><code>import os\nfrom crudadmin import CRUDAdmin\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup\nDATABASE_URL = \"sqlite+aiosqlite:///./app.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Create admin with common settings\nadmin = CRUDAdmin(\n    # Required parameters (no defaults)\n    session=async_session,\n    SECRET_KEY=os.environ.get(\"ADMIN_SECRET_KEY\", \"dev-key-change-in-production\"),\n\n    # Basic interface settings\n    mount_path=\"/admin\",  # Default: \"/admin\"\n    theme=\"dark-theme\",   # Default: \"dark-theme\" (or \"light-theme\")\n\n    # Database configuration\n    admin_db_path=None,   # Default: None (creates ./crudadmin_data/admin.db)\n\n    # Initial admin user\n    initial_admin={       # Default: None - no auto-creation\n        \"username\": \"admin\",\n        \"password\": \"secure_password_123\"\n    },\n)\n</code></pre> <p>Understanding Defaults:</p> <ul> <li>Required parameters: <code>session</code> and <code>SECRET_KEY</code> have no defaults and must be provided</li> <li>Optional parameters: All other parameters have sensible defaults and can be omitted</li> <li>Most minimal setup: <code>CRUDAdmin(session=async_session, SECRET_KEY=\"your-key\")</code> uses all defaults</li> </ul>"},{"location":"usage/configuration/#essential-configuration-parameters","title":"Essential Configuration Parameters","text":""},{"location":"usage/configuration/#required-parameters","title":"Required Parameters","text":""},{"location":"usage/configuration/#session-asyncsession","title":"<code>session</code> (AsyncSession)","text":"<p>Your SQLAlchemy async session factory or callable that returns sessions:</p> <pre><code># Session factory (most common)\nfrom sqlalchemy.orm import sessionmaker\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\nadmin = CRUDAdmin(session=async_session, SECRET_KEY=secret_key)\n</code></pre>"},{"location":"usage/configuration/#secret_key-str","title":"<code>SECRET_KEY</code> (str)","text":"<p>Critical for session security and cookie signing. Never use default values in production!</p> <pre><code># \u2705 Use environment variables\nadmin = CRUDAdmin(\n    session=session, \n    SECRET_KEY=os.environ[\"ADMIN_SECRET_KEY\"]\n)\n\n# \u2705 Generate secure keys\n# python -c \"import secrets; print(secrets.token_urlsafe(32))\"\n</code></pre>"},{"location":"usage/configuration/#common-optional-parameters","title":"Common Optional Parameters","text":""},{"location":"usage/configuration/#mount_path-str-default-admin","title":"<code>mount_path</code> (str, default: \"/admin\")","text":"<p>URL path where the admin interface will be accessible. If you want a different path than \"/admin\", you must explicitly pass the <code>mount_path</code> parameter to CRUDAdmin.</p> <pre><code># Default: accessible at /admin (no mount_path parameter needed)\nadmin = CRUDAdmin(session=session, SECRET_KEY=key)\n\n# Custom path: accessible at /dashboard (must specify mount_path)\nadmin = CRUDAdmin(\n    session=session, \n    SECRET_KEY=key,\n    mount_path=\"/dashboard\"  # Required for non-default paths\n)\n</code></pre> <p>Important: Remember to also update your FastAPI mount call to match:</p> <pre><code># If using custom mount_path=\"/dashboard\"\napp.mount(\"/dashboard\", admin.app)  # Must match the mount_path\n\n# Or dynamically\napp.mount(admin.mount_path, admin.app)  # Uses the configured path\n</code></pre>"},{"location":"usage/configuration/#theme-str-default-dark-theme","title":"<code>theme</code> (str, default: \"dark-theme\")","text":"<p>Choose between light and dark themes:</p> <pre><code># Dark theme (default)\nadmin = CRUDAdmin(session=session, SECRET_KEY=key, theme=\"dark-theme\")\n\n# Light theme\nadmin = CRUDAdmin(session=session, SECRET_KEY=key, theme=\"light-theme\")\n</code></pre>"},{"location":"usage/configuration/#admin_db_path-str-default-none","title":"<code>admin_db_path</code> (str, default: None)","text":"<p>Custom location for the admin database (used for admin users, sessions, etc.):</p> <pre><code># Default: creates ./crudadmin_data/admin.db\nadmin = CRUDAdmin(session=session, SECRET_KEY=key)\n\n# Custom path\nadmin = CRUDAdmin(\n    session=session, \n    SECRET_KEY=key,\n    admin_db_path=\"./admin/admin_database.db\"\n)\n</code></pre>"},{"location":"usage/configuration/#initial_admin-dict-default-none","title":"<code>initial_admin</code> (dict, default: None)","text":"<p>Automatically create an admin user when the system initializes:</p> <pre><code># No initial admin (default - create manually later)\nadmin = CRUDAdmin(session=session, SECRET_KEY=key)\n\n# Create initial admin automatically\nadmin = CRUDAdmin(\n    session=session,\n    SECRET_KEY=key,\n    initial_admin={\n        \"username\": \"admin\",\n        \"password\": \"secure_password_123\"\n    }\n)\n</code></pre>"},{"location":"usage/configuration/#fastapi-integration","title":"FastAPI Integration","text":""},{"location":"usage/configuration/#basic-integration","title":"Basic Integration","text":"<pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Initialize database\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    # Initialize admin\n    await admin.initialize()\n    yield\n\napp = FastAPI(lifespan=lifespan)\napp.mount(\"/admin\", admin.app)\n</code></pre>"},{"location":"usage/configuration/#custom-mount-path","title":"Custom Mount Path","text":"<pre><code># If you configured a custom mount_path\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=key,\n    mount_path=\"/dashboard\"\n)\n\n# Mount at the same path\napp.mount(\"/dashboard\", admin.app)\n</code></pre>"},{"location":"usage/configuration/#development-vs-production","title":"Development vs Production","text":""},{"location":"usage/configuration/#development-setup","title":"Development Setup","text":"<pre><code># Simple development configuration\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=\"dev-key-change-in-production\",  # Simple key for development\n    initial_admin={                             # Convenient auto-admin\n        \"username\": \"admin\",\n        \"password\": \"admin123\"\n    }\n)\n</code></pre>"},{"location":"usage/configuration/#production-considerations","title":"Production Considerations","text":"<pre><code># Basic production configuration\nadmin = CRUDAdmin(\n    session=async_session,\n    SECRET_KEY=os.environ[\"ADMIN_SECRET_KEY\"],  # Required environment variable\n    initial_admin=None,                         # Create admin users manually\n    secure_cookies=True,                        # Default: True (good for production)\n    enforce_https=True,                         # Redirect HTTP to HTTPS\n)\n</code></pre> <p>For comprehensive production configuration, see the Advanced Topics section.</p>"},{"location":"usage/configuration/#next-steps","title":"Next Steps","text":"<p>After configuring your CRUDAdmin instance:</p> <ol> <li>Add Models to create your admin interface</li> <li>Set up Admin Users for access control  </li> <li>Learn the Interface to manage your data effectively</li> </ol> <p>For production deployments and advanced configurations, explore the Advanced Topics section for scalable session handling, comprehensive security, and audit logging.</p>"},{"location":"usage/interface/","title":"Using the Admin Interface","text":"<p>This guide covers the essential operations for using the CRUDAdmin interface in your daily workflow. You'll learn how to navigate the dashboard, manage records, search and filter data, and work with forms effectively.</p>"},{"location":"usage/interface/#prerequisites","title":"Prerequisites","text":"<p>Before using the admin interface, ensure you have:</p> <ul> <li>A configured CRUDAdmin instance with models registered (see Adding Models)</li> <li>Admin user credentials (see Managing Admin Users)</li> <li>Access to your admin interface (typically at <code>/admin</code>)</li> </ul>"},{"location":"usage/interface/#dashboard-navigation","title":"Dashboard Navigation","text":""},{"location":"usage/interface/#accessing-the-admin-interface","title":"Accessing the Admin Interface","text":"<ol> <li>Navigate to your admin URL: Go to <code>/admin</code> (or your configured mount path)</li> <li>Login: Enter your admin credentials</li> <li>Dashboard loads: Main interface with sidebar navigation and content area</li> </ol>"},{"location":"usage/interface/#understanding-the-dashboard-layout","title":"Understanding the Dashboard Layout","text":"<p>The admin interface is organized into clear sections:</p> <p></p>"},{"location":"usage/interface/#sidebar-navigation","title":"Sidebar Navigation","text":"<p>The left sidebar contains collapsible sections:</p> <ul> <li>Navigation: Dashboard overview with system statistics</li> <li>Authentication: Admin Users and Sessions management</li> <li>Models: Your registered models with record counts</li> <li>Management: Health checks and event logs (if enabled)</li> </ul>"},{"location":"usage/interface/#main-content-area","title":"Main Content Area","text":"<ul> <li>Dashboard: Overview cards showing model statistics</li> <li>Model pages: List, create, and edit interfaces for each model</li> <li>Management tools: System monitoring and audit features</li> </ul>"},{"location":"usage/interface/#navigating-between-models","title":"Navigating Between Models","text":"<ol> <li>Click any model in the sidebar (e.g., \"User\", \"Product\")</li> <li>View the model list with all records</li> <li>Use action buttons to create, edit, or delete records</li> </ol>"},{"location":"usage/interface/#data-management","title":"Data Management","text":""},{"location":"usage/interface/#creating-new-records","title":"Creating New Records","text":""},{"location":"usage/interface/#step-1-access-create-form","title":"Step 1: Access Create Form","text":"<ul> <li>Click \"+ Add [ModelName]\" button on any model list page</li> <li>Form opens with fields based on your Pydantic schema</li> </ul>"},{"location":"usage/interface/#step-2-fill-required-fields","title":"Step 2: Fill Required Fields","text":"<p>Forms include different field types automatically generated from your schemas:</p> <ul> <li>Text inputs: Username, description, notes</li> <li>Email fields: With built-in email validation</li> <li>Select dropdowns: For choice fields like roles or status</li> <li>Checkboxes: For boolean fields like \"active\" or \"featured\"</li> <li>Date/time pickers: For datetime fields</li> </ul> <p></p>"},{"location":"usage/interface/#step-3-submit-or-cancel","title":"Step 3: Submit or Cancel","text":"<ul> <li>Create: Saves the record and returns to list</li> <li>Cancel: Returns to list without saving</li> <li>Validation errors: Show immediately with helpful messages</li> </ul>"},{"location":"usage/interface/#viewing-and-sorting-records","title":"Viewing and Sorting Records","text":""},{"location":"usage/interface/#list-view-features","title":"List View Features","text":"<ul> <li>Table display: All model fields in columns</li> <li>Record counts: Total number of records shown</li> <li>Sortable columns: Click headers to sort ascending/descending</li> <li>Pagination: Navigate large datasets efficiently</li> </ul>"},{"location":"usage/interface/#sorting-data","title":"Sorting Data","text":"<ol> <li>Click any column header to sort by that field</li> <li>Click again to reverse the sort order</li> <li>Sort indicators show current direction (\u25b2 asc, \u25bc desc)</li> </ol>"},{"location":"usage/interface/#updating-existing-records","title":"Updating Existing Records","text":""},{"location":"usage/interface/#step-1-select-record","title":"Step 1: Select Record","text":"<ul> <li>Check the checkbox next to the record you want to edit</li> <li>Update button appears in the action bar</li> </ul>"},{"location":"usage/interface/#step-2-edit-fields","title":"Step 2: Edit Fields","text":"<ul> <li>Click \"\u270e Update\" to open the edit form</li> <li>Current values are pre-filled in all fields</li> <li>Modify only the fields you want to change</li> </ul>"},{"location":"usage/interface/#step-3-save-changes","title":"Step 3: Save Changes","text":"<ul> <li>Update: Saves changes and returns to list</li> <li>Cancel: Discards changes and returns to list</li> </ul>"},{"location":"usage/interface/#deleting-records","title":"Deleting Records","text":""},{"location":"usage/interface/#single-record-deletion","title":"Single Record Deletion","text":"<ol> <li>Select one record using its checkbox</li> <li>Click \"\ud83d\uddd1 Delete Selected\" button</li> <li>Confirm deletion in the dialog that appears</li> </ol>"},{"location":"usage/interface/#bulk-deletion","title":"Bulk Deletion","text":"<ol> <li>Select multiple records using checkboxes</li> <li>Click \"\ud83d\uddd1 Delete Selected\" button  </li> <li>Confirm bulk deletion for all selected items</li> </ol> <p>Note: The action buttons change dynamically:</p> <ul> <li>No selection: Only \"Add\" button visible</li> <li>One selected: \"Update\" and \"Delete\" buttons appear</li> <li>Multiple selected: Only \"Delete\" button appears (bulk operation)</li> </ul> <p></p>"},{"location":"usage/interface/#search-and-filtering","title":"Search and Filtering","text":""},{"location":"usage/interface/#basic-search","title":"Basic Search","text":"<p>Use the search interface to find specific records quickly:</p> <p></p>"},{"location":"usage/interface/#how-to-search","title":"How to Search","text":"<ol> <li>Select the column to search in from the dropdown</li> <li>Enter your search term in the text field</li> <li>Search automatically as you type (with a short delay)</li> <li>Click \"Search\" for immediate results</li> </ol>"},{"location":"usage/interface/#search-behavior","title":"Search Behavior","text":"<ul> <li>Partial matching: Finds records containing your search term</li> <li>Case insensitive: \"Admin\" matches \"admin\", \"ADMIN\", etc.</li> <li>Real-time results: Updates as you type</li> <li>Persistent: Search terms remain when you change pages</li> </ul>"},{"location":"usage/interface/#column-specific-searching","title":"Column-Specific Searching","text":"<p>Different column types support different search patterns:</p> <ul> <li>Text fields: Partial word matching</li> <li>Email fields: Search by domain (@company.com) or username</li> <li>Number fields: Exact or partial number matching</li> <li>Date fields: Search by date patterns</li> <li>Choice fields: Search by specific option values</li> </ul>"},{"location":"usage/interface/#pagination","title":"Pagination","text":""},{"location":"usage/interface/#managing-large-datasets","title":"Managing Large Datasets","text":"<p>When you have many records, pagination helps you navigate efficiently:</p> <p></p>"},{"location":"usage/interface/#pagination-features","title":"Pagination Features","text":"<p>Records Per Page:</p> <ul> <li>Choose from 10, 20, 50, or 100 records per page</li> <li>Changes apply immediately</li> <li>Preserves your current search and sort settings</li> </ul> <p>Page Navigation:</p> <ul> <li>Previous/Next buttons for page-by-page navigation</li> <li>Page indicator shows current position (e.g., \"Page 2 of 15\")</li> <li>Automatic adjustment if you delete records from current page</li> </ul>"},{"location":"usage/interface/#smart-pagination-behavior","title":"Smart Pagination Behavior","text":"<ul> <li>Maintains search terms when changing pages</li> <li>Preserves sort order across all pages</li> <li>Adjusts current page if necessary after deletions</li> <li>Shows filtered totals when search is active</li> </ul>"},{"location":"usage/interface/#form-handling","title":"Form Handling","text":""},{"location":"usage/interface/#understanding-auto-generated-forms","title":"Understanding Auto-Generated Forms","text":"<p>CRUDAdmin creates forms automatically from your Pydantic schemas.</p>"},{"location":"usage/interface/#field-type-examples","title":"Field Type Examples","text":"<p>Text Input Fields: <pre><code># Schema definition\nusername: str = Field(..., min_length=3, max_length=50)\n# Generates: Username* [text input] (required field marked with *)\n</code></pre></p> <p>Email Fields: <pre><code># Schema definition\nemail: EmailStr\n# Generates: Email* [email input] (with validation)\n</code></pre></p> <p>Select Dropdowns: <pre><code># Schema definition\nrole: str = Field(..., pattern=\"^(admin|user|moderator)$\")\n# Generates: Role* [dropdown] with options\n</code></pre></p> <p>Boolean Checkboxes: <pre><code># Schema definition\nis_active: bool = True\n# Generates: \u2611 Active (checkbox, checked by default)\n</code></pre></p>"},{"location":"usage/interface/#form-validation","title":"Form Validation","text":""},{"location":"usage/interface/#validation-feedback","title":"Validation Feedback","text":"<ul> <li>Required fields marked with asterisk (*)</li> <li>Format validation for emails, patterns, etc.</li> <li>Length restrictions enforced (min/max characters)</li> <li>Real-time feedback as you fill fields</li> </ul>"},{"location":"usage/interface/#error-handling","title":"Error Handling","text":"<ul> <li>Field-level errors appear below problematic fields</li> <li>Clear error messages explain what needs to be fixed</li> <li>Form-level errors show at the top for general issues</li> <li>Automatic focus moves to first error field</li> </ul>"},{"location":"usage/interface/#bulk-operations","title":"Bulk Operations","text":""},{"location":"usage/interface/#working-with-multiple-records","title":"Working with Multiple Records","text":"<p>Select multiple records to perform bulk actions:</p>"},{"location":"usage/interface/#selecting-records","title":"Selecting Records","text":"<ul> <li>Individual selection: Check boxes next to specific records</li> <li>Select all: Use the header checkbox to select all visible records</li> <li>Partial selection: Mix individual selections as needed</li> </ul>"},{"location":"usage/interface/#available-bulk-operations","title":"Available Bulk Operations","text":"<ul> <li>Bulk deletion: Delete multiple records at once</li> <li>Batch updates: Update multiple records simultaneously (if configured)</li> <li>Export operations: Download selected records (if enabled)</li> </ul>"},{"location":"usage/interface/#bulk-deletion-process","title":"Bulk Deletion Process","text":"<ol> <li>Select target records using checkboxes</li> <li>Click \"Delete Selected\" (appears when multiple items selected)</li> <li>Review selection in confirmation dialog</li> <li>Confirm deletion to remove all selected records</li> </ol> <p>Important: Bulk operations cannot be undone, so review your selection carefully before confirming.</p>"},{"location":"usage/interface/#management-features","title":"Management Features","text":""},{"location":"usage/interface/#system-health-monitoring","title":"System Health Monitoring","text":"<p>Access system status through the Management section:</p> <p></p> <ul> <li>Database connectivity: Connection status and response times</li> <li>Session storage: Health of your session backend (memory/Redis/etc.)</li> <li>Event system: Status of audit logging (if enabled)</li> <li>Manual refresh: Update health checks on demand</li> </ul>"},{"location":"usage/interface/#event-logs-if-enabled","title":"Event Logs (if enabled)","text":"<p>Monitor admin activity through the event log system:</p> <p></p>"},{"location":"usage/interface/#event-tracking","title":"Event Tracking","text":"<ul> <li>User actions: Login, logout, record changes</li> <li>CRUD operations: Create, update, delete activities</li> <li>System events: Authentication failures, system errors</li> <li>Filterable history: Search by user, date range, event type</li> </ul>"},{"location":"usage/interface/#next-steps","title":"Next Steps","text":"<p>After mastering the basic interface operations, explore the Advanced Topics section for production features and sophisticated configurations.</p> <p>The admin interface provides everything you need for daily data management. With practice, you'll develop efficient workflows that make managing your application data quick and reliable. </p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>This section guides you through everything you need to know about using CRUDAdmin effectively in your projects. Follow these topics in order for the best learning experience.</p>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":""},{"location":"usage/overview/#1-basic-configuration","title":"1. Basic Configuration","text":"<p>Learn how to set up and configure your CRUDAdmin instance for different environments.</p> <ul> <li>Creating your first admin interface with essential settings</li> <li>Session backend configuration (Memory, Redis, Memcached, Database, Hybrid)</li> <li>Security settings for authentication and access control</li> <li>Environment-based configuration for development vs production</li> <li>FastAPI integration patterns and best practices</li> </ul>"},{"location":"usage/overview/#2-adding-models","title":"2. Adding Models","text":"<p>Master the core functionality of registering your SQLAlchemy models with CRUDAdmin.</p> <ul> <li>Model registration with create, update, and read schemas</li> <li>Action control (view, create, update, delete permissions)</li> <li>Password field handling with automatic transformation</li> <li>Advanced schema configuration for different operations</li> <li>Real-world examples and troubleshooting tips</li> </ul>"},{"location":"usage/overview/#3-managing-admin-users","title":"3. Managing Admin Users","text":"<p>Set up authentication and manage who can access your admin interface.</p> <ul> <li>Creating admin users and managing credentials</li> <li>Authentication flow and session management</li> <li>User roles and permissions (if applicable)</li> <li>Security best practices for admin access</li> </ul>"},{"location":"usage/overview/#4-using-the-interface","title":"4. Using the Interface","text":"<p>Navigate and operate the admin interface effectively for daily tasks.</p> <ul> <li>Dashboard navigation and understanding the layout</li> <li>CRUD operations (Create, Read, Update, Delete)</li> <li>Search and filtering data efficiently</li> <li>Bulk operations for managing multiple records</li> <li>Form handling and validation</li> </ul>"},{"location":"usage/overview/#5-common-patterns","title":"5. Common Patterns","text":"<p>Real-world usage patterns and scenarios you'll encounter in practice.</p> <ul> <li>Multi-model relationships (blog systems, e-commerce catalogs)</li> <li>Role-based access patterns for different admin levels</li> <li>Advanced validation patterns with business logic</li> <li>Performance optimization for large datasets</li> <li>Integration patterns with existing FastAPI applications</li> <li>Security patterns for production environments</li> </ul>"},{"location":"usage/overview/#whats-next","title":"What's Next?","text":"<p>After completing the Usage section, you'll have a solid foundation for building and managing admin interfaces with CRUDAdmin. From here, you can explore:</p> <ul> <li>Advanced Features - Production-grade features like event tracking, advanced session management, and security</li> <li>API Reference - Detailed technical documentation for all classes and methods</li> <li>Community - Contributing guidelines and getting help</li> </ul>"},{"location":"usage/overview/#quick-navigation","title":"Quick Navigation","text":"<p>Need to jump to a specific topic? Here are the most commonly accessed sections:</p> <ul> <li>Quick setup example - Get running in 5 minutes</li> <li>Adding your first model - Register a model and start managing data</li> <li>Search and filtering - Find records quickly</li> <li>Performance tips - Optimize for large datasets</li> <li>Security setup - Production security configuration </li> </ul>"}]}